import {
  AddressSchema,
  AmountSchema,
  BigNumberishSchema,
  ContractEncoder,
  ContractEvents,
  ContractInterceptor,
  ContractMetadata,
  ContractOwner,
  ContractRoles,
  ContractRoyalty,
  ContractWrapper,
  Erc1155,
  GasCostEstimator,
  NFTInputOrUriSchema,
  PackContractSchema,
  RawDateSchema,
  StandardErc1155,
  _defineProperty,
  fetchCurrencyMetadata,
  getRoleHash,
  hasERC20Allowance,
  isTokenApprovedForTransfer,
  mod,
  normalizePriceValue,
  require_browser_ponyfill,
  require_bs58,
  require_dist,
  require_fast_deep_equal,
  uploadOrExtractURI
} from "./chunk-HDJNXEED.js";
import "./chunk-GMTZS4FR.js";
import "./chunk-UXXT4I5S.js";
import {
  BigNumber,
  ethers_exports,
  require_bn
} from "./chunk-3CTDGBZJ.js";
import "./chunk-WGAG4NG4.js";
import {
  __toESM
} from "./chunk-NZZIBU5Z.js";

// node_modules/@thirdweb-dev/sdk/dist/pack-2f8c55e9.esm.js
var import_cross_fetch = __toESM(require_browser_ponyfill());
var import_bs58 = __toESM(require_bs58());
var import_merkletreejs = __toESM(require_dist());
var import_fast_deep_equal = __toESM(require_fast_deep_equal());
var import_bn = __toESM(require_bn());
var CommonWrappableSchema = mod.object({
  contractAddress: AddressSchema
});
var ERC20WrappableSchema = CommonWrappableSchema.extend({
  quantity: AmountSchema
});
var ERC721WrappableSchema = CommonWrappableSchema.extend({
  tokenId: BigNumberishSchema
});
var ERC1155WrappableSchema = CommonWrappableSchema.extend({
  tokenId: BigNumberishSchema,
  quantity: BigNumberishSchema
});
var ERC20RewardSchema = ERC20WrappableSchema.omit({
  quantity: true
}).extend({
  quantityPerReward: AmountSchema
});
var ERC721RewardSchema = ERC721WrappableSchema;
var ERC1155RewardSchema = ERC1155WrappableSchema.omit({
  quantity: true
}).extend({
  quantityPerReward: BigNumberishSchema
});
var ERC20RewardContentsSchema = ERC20RewardSchema.extend({
  totalRewards: BigNumberishSchema.default("1")
});
var ERC721RewardContentsSchema = ERC721RewardSchema;
var ERC1155RewardContentsSchema = ERC1155RewardSchema.extend({
  totalRewards: BigNumberishSchema.default("1")
});
mod.object({
  erc20Rewards: mod.array(ERC20RewardSchema).default([]),
  erc721Rewards: mod.array(ERC721RewardSchema).default([]),
  erc1155Rewards: mod.array(ERC1155RewardSchema).default([])
});
var PackRewardsOutputSchema = mod.object({
  erc20Rewards: mod.array(ERC20RewardContentsSchema).default([]),
  erc721Rewards: mod.array(ERC721RewardContentsSchema).default([]),
  erc1155Rewards: mod.array(ERC1155RewardContentsSchema).default([])
});
var PackMetadataInputSchema = PackRewardsOutputSchema.extend({
  packMetadata: NFTInputOrUriSchema,
  rewardsPerPack: BigNumberishSchema.default("1"),
  openStartTime: RawDateSchema.default(new Date())
});
var Pack = class extends StandardErc1155 {
  constructor(network, address, storage) {
    let options = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
    let abi = arguments.length > 4 ? arguments[4] : void 0;
    let chainId = arguments.length > 5 ? arguments[5] : void 0;
    let contractWrapper = arguments.length > 6 && arguments[6] !== void 0 ? arguments[6] : new ContractWrapper(network, address, abi, options.gasless && "openzeppelin" in options.gasless ? {
      ...options,
      gasless: {
        openzeppelin: {
          ...options.gasless.openzeppelin,
          useEOAForwarder: true
        }
      }
    } : options);
    super(contractWrapper, storage, chainId);
    _defineProperty(this, "abi", void 0);
    _defineProperty(this, "metadata", void 0);
    _defineProperty(this, "roles", void 0);
    _defineProperty(this, "encoder", void 0);
    _defineProperty(this, "events", void 0);
    _defineProperty(this, "estimator", void 0);
    _defineProperty(this, "royalties", void 0);
    _defineProperty(this, "interceptor", void 0);
    _defineProperty(this, "erc1155", void 0);
    _defineProperty(this, "owner", void 0);
    this.abi = abi;
    this.erc1155 = new Erc1155(this.contractWrapper, this.storage, chainId);
    this.metadata = new ContractMetadata(this.contractWrapper, PackContractSchema, this.storage);
    this.roles = new ContractRoles(this.contractWrapper, Pack.contractRoles);
    this.royalties = new ContractRoyalty(this.contractWrapper, this.metadata);
    this.encoder = new ContractEncoder(this.contractWrapper);
    this.estimator = new GasCostEstimator(this.contractWrapper);
    this.events = new ContractEvents(this.contractWrapper);
    this.interceptor = new ContractInterceptor(this.contractWrapper);
    this.owner = new ContractOwner(this.contractWrapper);
  }
  onNetworkUpdated(network) {
    this.contractWrapper.updateSignerOrProvider(network);
  }
  getAddress() {
    return this.contractWrapper.readContract.address;
  }
  async get(tokenId) {
    return this.erc1155.get(tokenId);
  }
  async getAll(queryParams) {
    return this.erc1155.getAll(queryParams);
  }
  async getOwned(walletAddress) {
    return this.erc1155.getOwned(walletAddress);
  }
  async getTotalCount() {
    return this.erc1155.totalCount();
  }
  async isTransferRestricted() {
    const anyoneCanTransfer = await this.contractWrapper.readContract.hasRole(getRoleHash("transfer"), ethers_exports.constants.AddressZero);
    return !anyoneCanTransfer;
  }
  async getPackContents(packId) {
    const {
      contents,
      perUnitAmounts
    } = await this.contractWrapper.readContract.getPackContents(packId);
    const erc20Rewards = [];
    const erc721Rewards = [];
    const erc1155Rewards = [];
    for (let i = 0; i < contents.length; i++) {
      const reward = contents[i];
      const amount = perUnitAmounts[i];
      switch (reward.tokenType) {
        case 0: {
          const tokenMetadata = await fetchCurrencyMetadata(this.contractWrapper.getProvider(), reward.assetContract);
          const rewardAmount = ethers_exports.utils.formatUnits(reward.totalAmount, tokenMetadata.decimals);
          erc20Rewards.push({
            contractAddress: reward.assetContract,
            quantityPerReward: amount.toString(),
            totalRewards: BigNumber.from(rewardAmount).div(amount).toString()
          });
          break;
        }
        case 1: {
          erc721Rewards.push({
            contractAddress: reward.assetContract,
            tokenId: reward.tokenId.toString()
          });
          break;
        }
        case 2: {
          erc1155Rewards.push({
            contractAddress: reward.assetContract,
            tokenId: reward.tokenId.toString(),
            quantityPerReward: amount.toString(),
            totalRewards: BigNumber.from(reward.totalAmount).div(amount).toString()
          });
          break;
        }
      }
    }
    return {
      erc20Rewards,
      erc721Rewards,
      erc1155Rewards
    };
  }
  async create(metadataWithRewards) {
    const signerAddress = await this.contractWrapper.getSignerAddress();
    return this.createTo(signerAddress, metadataWithRewards);
  }
  async addPackContents(packId, packContents) {
    const signerAddress = await this.contractWrapper.getSignerAddress();
    const parsedContents = PackRewardsOutputSchema.parse(packContents);
    const {
      contents,
      numOfRewardUnits
    } = await this.toPackContentArgs(parsedContents);
    const receipt = await this.contractWrapper.sendTransaction("addPackContents", [packId, contents, numOfRewardUnits, signerAddress]);
    const event = this.contractWrapper.parseLogs("PackUpdated", receipt == null ? void 0 : receipt.logs);
    if (event.length === 0) {
      throw new Error("PackUpdated event not found");
    }
    const id = event[0].args.packId;
    return {
      id,
      receipt,
      data: () => this.erc1155.get(id)
    };
  }
  async createTo(to, metadataWithRewards) {
    const uri = await uploadOrExtractURI(metadataWithRewards.packMetadata, this.storage);
    const parsedMetadata = PackMetadataInputSchema.parse(metadataWithRewards);
    const {
      erc20Rewards,
      erc721Rewards,
      erc1155Rewards
    } = parsedMetadata;
    const rewardsData = {
      erc20Rewards,
      erc721Rewards,
      erc1155Rewards
    };
    const {
      contents,
      numOfRewardUnits
    } = await this.toPackContentArgs(rewardsData);
    const receipt = await this.contractWrapper.sendTransaction("createPack", [contents, numOfRewardUnits, uri, parsedMetadata.openStartTime, parsedMetadata.rewardsPerPack, to]);
    const event = this.contractWrapper.parseLogs("PackCreated", receipt == null ? void 0 : receipt.logs);
    if (event.length === 0) {
      throw new Error("PackCreated event not found");
    }
    const packId = event[0].args.packId;
    return {
      id: packId,
      receipt,
      data: () => this.erc1155.get(packId)
    };
  }
  async open(tokenId) {
    let amount = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 1;
    const receipt = await this.contractWrapper.sendTransaction("openPack", [tokenId, amount], {
      gasLimit: 5e5
    });
    const event = this.contractWrapper.parseLogs("PackOpened", receipt == null ? void 0 : receipt.logs);
    if (event.length === 0) {
      throw new Error("PackOpened event not found");
    }
    const rewards = event[0].args.rewardUnitsDistributed;
    const erc20Rewards = [];
    const erc721Rewards = [];
    const erc1155Rewards = [];
    for (const reward of rewards) {
      switch (reward.tokenType) {
        case 0: {
          const tokenMetadata = await fetchCurrencyMetadata(this.contractWrapper.getProvider(), reward.assetContract);
          erc20Rewards.push({
            contractAddress: reward.assetContract,
            quantityPerReward: ethers_exports.utils.formatUnits(reward.totalAmount, tokenMetadata.decimals).toString()
          });
          break;
        }
        case 1: {
          erc721Rewards.push({
            contractAddress: reward.assetContract,
            tokenId: reward.tokenId.toString()
          });
          break;
        }
        case 2: {
          erc1155Rewards.push({
            contractAddress: reward.assetContract,
            tokenId: reward.tokenId.toString(),
            quantityPerReward: reward.totalAmount.toString()
          });
          break;
        }
      }
    }
    return {
      erc20Rewards,
      erc721Rewards,
      erc1155Rewards
    };
  }
  async toPackContentArgs(metadataWithRewards) {
    const contents = [];
    const numOfRewardUnits = [];
    const {
      erc20Rewards,
      erc721Rewards,
      erc1155Rewards
    } = metadataWithRewards;
    const provider = this.contractWrapper.getProvider();
    const owner = await this.contractWrapper.getSignerAddress();
    for (const erc20 of erc20Rewards) {
      const normalizedQuantity = await normalizePriceValue(provider, erc20.quantityPerReward, erc20.contractAddress);
      const totalQuantity = normalizedQuantity.mul(erc20.totalRewards);
      const hasAllowance = await hasERC20Allowance(this.contractWrapper, erc20.contractAddress, totalQuantity);
      if (!hasAllowance) {
        throw new Error(`ERC20 token with contract address "${erc20.contractAddress}" does not have enough allowance to transfer.

You can set allowance to the multiwrap contract to transfer these tokens by running:

await sdk.getToken("${erc20.contractAddress}").setAllowance("${this.getAddress()}", ${totalQuantity});

`);
      }
      numOfRewardUnits.push(erc20.totalRewards);
      contents.push({
        assetContract: erc20.contractAddress,
        tokenType: 0,
        totalAmount: totalQuantity,
        tokenId: 0
      });
    }
    for (const erc721 of erc721Rewards) {
      const isApproved = await isTokenApprovedForTransfer(this.contractWrapper.getProvider(), this.getAddress(), erc721.contractAddress, erc721.tokenId, owner);
      if (!isApproved) {
        throw new Error(`ERC721 token "${erc721.tokenId}" with contract address "${erc721.contractAddress}" is not approved for transfer.

You can give approval the multiwrap contract to transfer this token by running:

await sdk.getNFTCollection("${erc721.contractAddress}").setApprovalForToken("${this.getAddress()}", ${erc721.tokenId});

`);
      }
      numOfRewardUnits.push("1");
      contents.push({
        assetContract: erc721.contractAddress,
        tokenType: 1,
        totalAmount: 1,
        tokenId: erc721.tokenId
      });
    }
    for (const erc1155 of erc1155Rewards) {
      const isApproved = await isTokenApprovedForTransfer(this.contractWrapper.getProvider(), this.getAddress(), erc1155.contractAddress, erc1155.tokenId, owner);
      if (!isApproved) {
        throw new Error(`ERC1155 token "${erc1155.tokenId}" with contract address "${erc1155.contractAddress}" is not approved for transfer.

You can give approval the multiwrap contract to transfer this token by running:

await sdk.getEdition("${erc1155.contractAddress}").setApprovalForAll("${this.getAddress()}", true);

`);
      }
      numOfRewardUnits.push(erc1155.totalRewards);
      contents.push({
        assetContract: erc1155.contractAddress,
        tokenType: 2,
        totalAmount: BigNumber.from(erc1155.quantityPerReward).mul(BigNumber.from(erc1155.totalRewards)),
        tokenId: erc1155.tokenId
      });
    }
    return {
      contents,
      numOfRewardUnits
    };
  }
  async call(functionName) {
    for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      args[_key - 1] = arguments[_key];
    }
    return this.contractWrapper.call(functionName, ...args);
  }
};
_defineProperty(Pack, "contractRoles", ["admin", "minter", "asset", "transfer"]);
export {
  Pack
};
//# sourceMappingURL=pack-2f8c55e9.esm-YRYLRL65.js.map
