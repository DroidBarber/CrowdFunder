import {
  DropERC721_V3_default
} from "./chunk-GMTZS4FR.js";
import {
  DropERC1155_V2_default
} from "./chunk-UXXT4I5S.js";
import {
  BigNumber,
  Contract,
  Signer,
  ethers_exports,
  lib_exports21 as lib_exports2,
  lib_exports7 as lib_exports,
  require_bn,
  utils_exports
} from "./chunk-3CTDGBZJ.js";
import {
  DropERC20_V2_default
} from "./chunk-WGAG4NG4.js";
import {
  __commonJS,
  __toESM
} from "./chunk-NZZIBU5Z.js";

// node_modules/@thirdweb-dev/sdk/node_modules/eventemitter3/index.js
var require_eventemitter3 = __commonJS({
  "node_modules/@thirdweb-dev/sdk/node_modules/eventemitter3/index.js"(exports, module) {
    "use strict";
    var has = Object.prototype.hasOwnProperty;
    var prefix2 = "~";
    function Events() {
    }
    if (Object.create) {
      Events.prototype = /* @__PURE__ */ Object.create(null);
      if (!new Events().__proto__)
        prefix2 = false;
    }
    function EE(fn, context, once) {
      this.fn = fn;
      this.context = context;
      this.once = once || false;
    }
    function addListener(emitter, event, fn, context, once) {
      if (typeof fn !== "function") {
        throw new TypeError("The listener must be a function");
      }
      var listener = new EE(fn, context || emitter, once), evt = prefix2 ? prefix2 + event : event;
      if (!emitter._events[evt])
        emitter._events[evt] = listener, emitter._eventsCount++;
      else if (!emitter._events[evt].fn)
        emitter._events[evt].push(listener);
      else
        emitter._events[evt] = [emitter._events[evt], listener];
      return emitter;
    }
    function clearEvent(emitter, evt) {
      if (--emitter._eventsCount === 0)
        emitter._events = new Events();
      else
        delete emitter._events[evt];
    }
    function EventEmitter2() {
      this._events = new Events();
      this._eventsCount = 0;
    }
    EventEmitter2.prototype.eventNames = function eventNames() {
      var names = [], events, name;
      if (this._eventsCount === 0)
        return names;
      for (name in events = this._events) {
        if (has.call(events, name))
          names.push(prefix2 ? name.slice(1) : name);
      }
      if (Object.getOwnPropertySymbols) {
        return names.concat(Object.getOwnPropertySymbols(events));
      }
      return names;
    };
    EventEmitter2.prototype.listeners = function listeners(event) {
      var evt = prefix2 ? prefix2 + event : event, handlers = this._events[evt];
      if (!handlers)
        return [];
      if (handlers.fn)
        return [handlers.fn];
      for (var i = 0, l = handlers.length, ee = new Array(l); i < l; i++) {
        ee[i] = handlers[i].fn;
      }
      return ee;
    };
    EventEmitter2.prototype.listenerCount = function listenerCount(event) {
      var evt = prefix2 ? prefix2 + event : event, listeners = this._events[evt];
      if (!listeners)
        return 0;
      if (listeners.fn)
        return 1;
      return listeners.length;
    };
    EventEmitter2.prototype.emit = function emit(event, a1, a2, a3, a4, a5) {
      var evt = prefix2 ? prefix2 + event : event;
      if (!this._events[evt])
        return false;
      var listeners = this._events[evt], len = arguments.length, args, i;
      if (listeners.fn) {
        if (listeners.once)
          this.removeListener(event, listeners.fn, void 0, true);
        switch (len) {
          case 1:
            return listeners.fn.call(listeners.context), true;
          case 2:
            return listeners.fn.call(listeners.context, a1), true;
          case 3:
            return listeners.fn.call(listeners.context, a1, a2), true;
          case 4:
            return listeners.fn.call(listeners.context, a1, a2, a3), true;
          case 5:
            return listeners.fn.call(listeners.context, a1, a2, a3, a4), true;
          case 6:
            return listeners.fn.call(listeners.context, a1, a2, a3, a4, a5), true;
        }
        for (i = 1, args = new Array(len - 1); i < len; i++) {
          args[i - 1] = arguments[i];
        }
        listeners.fn.apply(listeners.context, args);
      } else {
        var length = listeners.length, j;
        for (i = 0; i < length; i++) {
          if (listeners[i].once)
            this.removeListener(event, listeners[i].fn, void 0, true);
          switch (len) {
            case 1:
              listeners[i].fn.call(listeners[i].context);
              break;
            case 2:
              listeners[i].fn.call(listeners[i].context, a1);
              break;
            case 3:
              listeners[i].fn.call(listeners[i].context, a1, a2);
              break;
            case 4:
              listeners[i].fn.call(listeners[i].context, a1, a2, a3);
              break;
            default:
              if (!args)
                for (j = 1, args = new Array(len - 1); j < len; j++) {
                  args[j - 1] = arguments[j];
                }
              listeners[i].fn.apply(listeners[i].context, args);
          }
        }
      }
      return true;
    };
    EventEmitter2.prototype.on = function on(event, fn, context) {
      return addListener(this, event, fn, context, false);
    };
    EventEmitter2.prototype.once = function once(event, fn, context) {
      return addListener(this, event, fn, context, true);
    };
    EventEmitter2.prototype.removeListener = function removeListener(event, fn, context, once) {
      var evt = prefix2 ? prefix2 + event : event;
      if (!this._events[evt])
        return this;
      if (!fn) {
        clearEvent(this, evt);
        return this;
      }
      var listeners = this._events[evt];
      if (listeners.fn) {
        if (listeners.fn === fn && (!once || listeners.once) && (!context || listeners.context === context)) {
          clearEvent(this, evt);
        }
      } else {
        for (var i = 0, events = [], length = listeners.length; i < length; i++) {
          if (listeners[i].fn !== fn || once && !listeners[i].once || context && listeners[i].context !== context) {
            events.push(listeners[i]);
          }
        }
        if (events.length)
          this._events[evt] = events.length === 1 ? events[0] : events;
        else
          clearEvent(this, evt);
      }
      return this;
    };
    EventEmitter2.prototype.removeAllListeners = function removeAllListeners(event) {
      var evt;
      if (event) {
        evt = prefix2 ? prefix2 + event : event;
        if (this._events[evt])
          clearEvent(this, evt);
      } else {
        this._events = new Events();
        this._eventsCount = 0;
      }
      return this;
    };
    EventEmitter2.prototype.off = EventEmitter2.prototype.removeListener;
    EventEmitter2.prototype.addListener = EventEmitter2.prototype.on;
    EventEmitter2.prefixed = prefix2;
    EventEmitter2.EventEmitter = EventEmitter2;
    if ("undefined" !== typeof module) {
      module.exports = EventEmitter2;
    }
  }
});

// node_modules/cross-fetch/dist/browser-ponyfill.js
var require_browser_ponyfill = __commonJS({
  "node_modules/cross-fetch/dist/browser-ponyfill.js"(exports, module) {
    var global2 = typeof self !== "undefined" ? self : exports;
    var __self__ = function() {
      function F() {
        this.fetch = false;
        this.DOMException = global2.DOMException;
      }
      F.prototype = global2;
      return new F();
    }();
    (function(self2) {
      var irrelevant = function(exports2) {
        var support = {
          searchParams: "URLSearchParams" in self2,
          iterable: "Symbol" in self2 && "iterator" in Symbol,
          blob: "FileReader" in self2 && "Blob" in self2 && function() {
            try {
              new Blob();
              return true;
            } catch (e) {
              return false;
            }
          }(),
          formData: "FormData" in self2,
          arrayBuffer: "ArrayBuffer" in self2
        };
        function isDataView(obj) {
          return obj && DataView.prototype.isPrototypeOf(obj);
        }
        if (support.arrayBuffer) {
          var viewClasses = [
            "[object Int8Array]",
            "[object Uint8Array]",
            "[object Uint8ClampedArray]",
            "[object Int16Array]",
            "[object Uint16Array]",
            "[object Int32Array]",
            "[object Uint32Array]",
            "[object Float32Array]",
            "[object Float64Array]"
          ];
          var isArrayBufferView = ArrayBuffer.isView || function(obj) {
            return obj && viewClasses.indexOf(Object.prototype.toString.call(obj)) > -1;
          };
        }
        function normalizeName(name) {
          if (typeof name !== "string") {
            name = String(name);
          }
          if (/[^a-z0-9\-#$%&'*+.^_`|~]/i.test(name)) {
            throw new TypeError("Invalid character in header field name");
          }
          return name.toLowerCase();
        }
        function normalizeValue(value) {
          if (typeof value !== "string") {
            value = String(value);
          }
          return value;
        }
        function iteratorFor(items) {
          var iterator = {
            next: function() {
              var value = items.shift();
              return { done: value === void 0, value };
            }
          };
          if (support.iterable) {
            iterator[Symbol.iterator] = function() {
              return iterator;
            };
          }
          return iterator;
        }
        function Headers(headers) {
          this.map = {};
          if (headers instanceof Headers) {
            headers.forEach(function(value, name) {
              this.append(name, value);
            }, this);
          } else if (Array.isArray(headers)) {
            headers.forEach(function(header) {
              this.append(header[0], header[1]);
            }, this);
          } else if (headers) {
            Object.getOwnPropertyNames(headers).forEach(function(name) {
              this.append(name, headers[name]);
            }, this);
          }
        }
        Headers.prototype.append = function(name, value) {
          name = normalizeName(name);
          value = normalizeValue(value);
          var oldValue = this.map[name];
          this.map[name] = oldValue ? oldValue + ", " + value : value;
        };
        Headers.prototype["delete"] = function(name) {
          delete this.map[normalizeName(name)];
        };
        Headers.prototype.get = function(name) {
          name = normalizeName(name);
          return this.has(name) ? this.map[name] : null;
        };
        Headers.prototype.has = function(name) {
          return this.map.hasOwnProperty(normalizeName(name));
        };
        Headers.prototype.set = function(name, value) {
          this.map[normalizeName(name)] = normalizeValue(value);
        };
        Headers.prototype.forEach = function(callback, thisArg) {
          for (var name in this.map) {
            if (this.map.hasOwnProperty(name)) {
              callback.call(thisArg, this.map[name], name, this);
            }
          }
        };
        Headers.prototype.keys = function() {
          var items = [];
          this.forEach(function(value, name) {
            items.push(name);
          });
          return iteratorFor(items);
        };
        Headers.prototype.values = function() {
          var items = [];
          this.forEach(function(value) {
            items.push(value);
          });
          return iteratorFor(items);
        };
        Headers.prototype.entries = function() {
          var items = [];
          this.forEach(function(value, name) {
            items.push([name, value]);
          });
          return iteratorFor(items);
        };
        if (support.iterable) {
          Headers.prototype[Symbol.iterator] = Headers.prototype.entries;
        }
        function consumed(body) {
          if (body.bodyUsed) {
            return Promise.reject(new TypeError("Already read"));
          }
          body.bodyUsed = true;
        }
        function fileReaderReady(reader) {
          return new Promise(function(resolve, reject) {
            reader.onload = function() {
              resolve(reader.result);
            };
            reader.onerror = function() {
              reject(reader.error);
            };
          });
        }
        function readBlobAsArrayBuffer(blob) {
          var reader = new FileReader();
          var promise = fileReaderReady(reader);
          reader.readAsArrayBuffer(blob);
          return promise;
        }
        function readBlobAsText(blob) {
          var reader = new FileReader();
          var promise = fileReaderReady(reader);
          reader.readAsText(blob);
          return promise;
        }
        function readArrayBufferAsText(buf) {
          var view = new Uint8Array(buf);
          var chars = new Array(view.length);
          for (var i = 0; i < view.length; i++) {
            chars[i] = String.fromCharCode(view[i]);
          }
          return chars.join("");
        }
        function bufferClone(buf) {
          if (buf.slice) {
            return buf.slice(0);
          } else {
            var view = new Uint8Array(buf.byteLength);
            view.set(new Uint8Array(buf));
            return view.buffer;
          }
        }
        function Body() {
          this.bodyUsed = false;
          this._initBody = function(body) {
            this._bodyInit = body;
            if (!body) {
              this._bodyText = "";
            } else if (typeof body === "string") {
              this._bodyText = body;
            } else if (support.blob && Blob.prototype.isPrototypeOf(body)) {
              this._bodyBlob = body;
            } else if (support.formData && FormData.prototype.isPrototypeOf(body)) {
              this._bodyFormData = body;
            } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {
              this._bodyText = body.toString();
            } else if (support.arrayBuffer && support.blob && isDataView(body)) {
              this._bodyArrayBuffer = bufferClone(body.buffer);
              this._bodyInit = new Blob([this._bodyArrayBuffer]);
            } else if (support.arrayBuffer && (ArrayBuffer.prototype.isPrototypeOf(body) || isArrayBufferView(body))) {
              this._bodyArrayBuffer = bufferClone(body);
            } else {
              this._bodyText = body = Object.prototype.toString.call(body);
            }
            if (!this.headers.get("content-type")) {
              if (typeof body === "string") {
                this.headers.set("content-type", "text/plain;charset=UTF-8");
              } else if (this._bodyBlob && this._bodyBlob.type) {
                this.headers.set("content-type", this._bodyBlob.type);
              } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {
                this.headers.set("content-type", "application/x-www-form-urlencoded;charset=UTF-8");
              }
            }
          };
          if (support.blob) {
            this.blob = function() {
              var rejected = consumed(this);
              if (rejected) {
                return rejected;
              }
              if (this._bodyBlob) {
                return Promise.resolve(this._bodyBlob);
              } else if (this._bodyArrayBuffer) {
                return Promise.resolve(new Blob([this._bodyArrayBuffer]));
              } else if (this._bodyFormData) {
                throw new Error("could not read FormData body as blob");
              } else {
                return Promise.resolve(new Blob([this._bodyText]));
              }
            };
            this.arrayBuffer = function() {
              if (this._bodyArrayBuffer) {
                return consumed(this) || Promise.resolve(this._bodyArrayBuffer);
              } else {
                return this.blob().then(readBlobAsArrayBuffer);
              }
            };
          }
          this.text = function() {
            var rejected = consumed(this);
            if (rejected) {
              return rejected;
            }
            if (this._bodyBlob) {
              return readBlobAsText(this._bodyBlob);
            } else if (this._bodyArrayBuffer) {
              return Promise.resolve(readArrayBufferAsText(this._bodyArrayBuffer));
            } else if (this._bodyFormData) {
              throw new Error("could not read FormData body as text");
            } else {
              return Promise.resolve(this._bodyText);
            }
          };
          if (support.formData) {
            this.formData = function() {
              return this.text().then(decode2);
            };
          }
          this.json = function() {
            return this.text().then(JSON.parse);
          };
          return this;
        }
        var methods = ["DELETE", "GET", "HEAD", "OPTIONS", "POST", "PUT"];
        function normalizeMethod(method) {
          var upcased = method.toUpperCase();
          return methods.indexOf(upcased) > -1 ? upcased : method;
        }
        function Request(input, options) {
          options = options || {};
          var body = options.body;
          if (input instanceof Request) {
            if (input.bodyUsed) {
              throw new TypeError("Already read");
            }
            this.url = input.url;
            this.credentials = input.credentials;
            if (!options.headers) {
              this.headers = new Headers(input.headers);
            }
            this.method = input.method;
            this.mode = input.mode;
            this.signal = input.signal;
            if (!body && input._bodyInit != null) {
              body = input._bodyInit;
              input.bodyUsed = true;
            }
          } else {
            this.url = String(input);
          }
          this.credentials = options.credentials || this.credentials || "same-origin";
          if (options.headers || !this.headers) {
            this.headers = new Headers(options.headers);
          }
          this.method = normalizeMethod(options.method || this.method || "GET");
          this.mode = options.mode || this.mode || null;
          this.signal = options.signal || this.signal;
          this.referrer = null;
          if ((this.method === "GET" || this.method === "HEAD") && body) {
            throw new TypeError("Body not allowed for GET or HEAD requests");
          }
          this._initBody(body);
        }
        Request.prototype.clone = function() {
          return new Request(this, { body: this._bodyInit });
        };
        function decode2(body) {
          var form = new FormData();
          body.trim().split("&").forEach(function(bytes) {
            if (bytes) {
              var split = bytes.split("=");
              var name = split.shift().replace(/\+/g, " ");
              var value = split.join("=").replace(/\+/g, " ");
              form.append(decodeURIComponent(name), decodeURIComponent(value));
            }
          });
          return form;
        }
        function parseHeaders(rawHeaders) {
          var headers = new Headers();
          var preProcessedHeaders = rawHeaders.replace(/\r?\n[\t ]+/g, " ");
          preProcessedHeaders.split(/\r?\n/).forEach(function(line) {
            var parts = line.split(":");
            var key = parts.shift().trim();
            if (key) {
              var value = parts.join(":").trim();
              headers.append(key, value);
            }
          });
          return headers;
        }
        Body.call(Request.prototype);
        function Response(bodyInit, options) {
          if (!options) {
            options = {};
          }
          this.type = "default";
          this.status = options.status === void 0 ? 200 : options.status;
          this.ok = this.status >= 200 && this.status < 300;
          this.statusText = "statusText" in options ? options.statusText : "OK";
          this.headers = new Headers(options.headers);
          this.url = options.url || "";
          this._initBody(bodyInit);
        }
        Body.call(Response.prototype);
        Response.prototype.clone = function() {
          return new Response(this._bodyInit, {
            status: this.status,
            statusText: this.statusText,
            headers: new Headers(this.headers),
            url: this.url
          });
        };
        Response.error = function() {
          var response = new Response(null, { status: 0, statusText: "" });
          response.type = "error";
          return response;
        };
        var redirectStatuses = [301, 302, 303, 307, 308];
        Response.redirect = function(url, status) {
          if (redirectStatuses.indexOf(status) === -1) {
            throw new RangeError("Invalid status code");
          }
          return new Response(null, { status, headers: { location: url } });
        };
        exports2.DOMException = self2.DOMException;
        try {
          new exports2.DOMException();
        } catch (err) {
          exports2.DOMException = function(message, name) {
            this.message = message;
            this.name = name;
            var error = Error(message);
            this.stack = error.stack;
          };
          exports2.DOMException.prototype = Object.create(Error.prototype);
          exports2.DOMException.prototype.constructor = exports2.DOMException;
        }
        function fetch3(input, init) {
          return new Promise(function(resolve, reject) {
            var request = new Request(input, init);
            if (request.signal && request.signal.aborted) {
              return reject(new exports2.DOMException("Aborted", "AbortError"));
            }
            var xhr = new XMLHttpRequest();
            function abortXhr() {
              xhr.abort();
            }
            xhr.onload = function() {
              var options = {
                status: xhr.status,
                statusText: xhr.statusText,
                headers: parseHeaders(xhr.getAllResponseHeaders() || "")
              };
              options.url = "responseURL" in xhr ? xhr.responseURL : options.headers.get("X-Request-URL");
              var body = "response" in xhr ? xhr.response : xhr.responseText;
              resolve(new Response(body, options));
            };
            xhr.onerror = function() {
              reject(new TypeError("Network request failed"));
            };
            xhr.ontimeout = function() {
              reject(new TypeError("Network request failed"));
            };
            xhr.onabort = function() {
              reject(new exports2.DOMException("Aborted", "AbortError"));
            };
            xhr.open(request.method, request.url, true);
            if (request.credentials === "include") {
              xhr.withCredentials = true;
            } else if (request.credentials === "omit") {
              xhr.withCredentials = false;
            }
            if ("responseType" in xhr && support.blob) {
              xhr.responseType = "blob";
            }
            request.headers.forEach(function(value, name) {
              xhr.setRequestHeader(name, value);
            });
            if (request.signal) {
              request.signal.addEventListener("abort", abortXhr);
              xhr.onreadystatechange = function() {
                if (xhr.readyState === 4) {
                  request.signal.removeEventListener("abort", abortXhr);
                }
              };
            }
            xhr.send(typeof request._bodyInit === "undefined" ? null : request._bodyInit);
          });
        }
        fetch3.polyfill = true;
        if (!self2.fetch) {
          self2.fetch = fetch3;
          self2.Headers = Headers;
          self2.Request = Request;
          self2.Response = Response;
        }
        exports2.Headers = Headers;
        exports2.Request = Request;
        exports2.Response = Response;
        exports2.fetch = fetch3;
        Object.defineProperty(exports2, "__esModule", { value: true });
        return exports2;
      }({});
    })(__self__);
    __self__.fetch.ponyfill = true;
    delete __self__.fetch.polyfill;
    var ctx = __self__;
    exports = ctx.fetch;
    exports.default = ctx.fetch;
    exports.fetch = ctx.fetch;
    exports.Headers = ctx.Headers;
    exports.Request = ctx.Request;
    exports.Response = ctx.Response;
    module.exports = exports;
  }
});

// node_modules/@thirdweb-dev/sdk/node_modules/base-x/src/index.js
var require_src = __commonJS({
  "node_modules/@thirdweb-dev/sdk/node_modules/base-x/src/index.js"(exports, module) {
    "use strict";
    function base(ALPHABET) {
      if (ALPHABET.length >= 255) {
        throw new TypeError("Alphabet too long");
      }
      var BASE_MAP = new Uint8Array(256);
      for (var j = 0; j < BASE_MAP.length; j++) {
        BASE_MAP[j] = 255;
      }
      for (var i = 0; i < ALPHABET.length; i++) {
        var x = ALPHABET.charAt(i);
        var xc = x.charCodeAt(0);
        if (BASE_MAP[xc] !== 255) {
          throw new TypeError(x + " is ambiguous");
        }
        BASE_MAP[xc] = i;
      }
      var BASE = ALPHABET.length;
      var LEADER = ALPHABET.charAt(0);
      var FACTOR = Math.log(BASE) / Math.log(256);
      var iFACTOR = Math.log(256) / Math.log(BASE);
      function encode(source) {
        if (source instanceof Uint8Array) {
        } else if (ArrayBuffer.isView(source)) {
          source = new Uint8Array(source.buffer, source.byteOffset, source.byteLength);
        } else if (Array.isArray(source)) {
          source = Uint8Array.from(source);
        }
        if (!(source instanceof Uint8Array)) {
          throw new TypeError("Expected Uint8Array");
        }
        if (source.length === 0) {
          return "";
        }
        var zeroes = 0;
        var length = 0;
        var pbegin = 0;
        var pend = source.length;
        while (pbegin !== pend && source[pbegin] === 0) {
          pbegin++;
          zeroes++;
        }
        var size = (pend - pbegin) * iFACTOR + 1 >>> 0;
        var b58 = new Uint8Array(size);
        while (pbegin !== pend) {
          var carry = source[pbegin];
          var i2 = 0;
          for (var it1 = size - 1; (carry !== 0 || i2 < length) && it1 !== -1; it1--, i2++) {
            carry += 256 * b58[it1] >>> 0;
            b58[it1] = carry % BASE >>> 0;
            carry = carry / BASE >>> 0;
          }
          if (carry !== 0) {
            throw new Error("Non-zero carry");
          }
          length = i2;
          pbegin++;
        }
        var it2 = size - length;
        while (it2 !== size && b58[it2] === 0) {
          it2++;
        }
        var str = LEADER.repeat(zeroes);
        for (; it2 < size; ++it2) {
          str += ALPHABET.charAt(b58[it2]);
        }
        return str;
      }
      function decodeUnsafe(source) {
        if (typeof source !== "string") {
          throw new TypeError("Expected String");
        }
        if (source.length === 0) {
          return new Uint8Array();
        }
        var psz = 0;
        var zeroes = 0;
        var length = 0;
        while (source[psz] === LEADER) {
          zeroes++;
          psz++;
        }
        var size = (source.length - psz) * FACTOR + 1 >>> 0;
        var b256 = new Uint8Array(size);
        while (source[psz]) {
          var carry = BASE_MAP[source.charCodeAt(psz)];
          if (carry === 255) {
            return;
          }
          var i2 = 0;
          for (var it3 = size - 1; (carry !== 0 || i2 < length) && it3 !== -1; it3--, i2++) {
            carry += BASE * b256[it3] >>> 0;
            b256[it3] = carry % 256 >>> 0;
            carry = carry / 256 >>> 0;
          }
          if (carry !== 0) {
            throw new Error("Non-zero carry");
          }
          length = i2;
          psz++;
        }
        var it4 = size - length;
        while (it4 !== size && b256[it4] === 0) {
          it4++;
        }
        var vch = new Uint8Array(zeroes + (size - it4));
        var j2 = zeroes;
        while (it4 !== size) {
          vch[j2++] = b256[it4++];
        }
        return vch;
      }
      function decode2(string) {
        var buffer = decodeUnsafe(string);
        if (buffer) {
          return buffer;
        }
        throw new Error("Non-base" + BASE + " character");
      }
      return {
        encode,
        decodeUnsafe,
        decode: decode2
      };
    }
    module.exports = base;
  }
});

// node_modules/@thirdweb-dev/sdk/node_modules/bs58/index.js
var require_bs58 = __commonJS({
  "node_modules/@thirdweb-dev/sdk/node_modules/bs58/index.js"(exports, module) {
    var basex = require_src();
    var ALPHABET = "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz";
    module.exports = basex(ALPHABET);
  }
});

// node_modules/base64-js/index.js
var require_base64_js = __commonJS({
  "node_modules/base64-js/index.js"(exports) {
    "use strict";
    exports.byteLength = byteLength;
    exports.toByteArray = toByteArray;
    exports.fromByteArray = fromByteArray;
    var lookup = [];
    var revLookup = [];
    var Arr = typeof Uint8Array !== "undefined" ? Uint8Array : Array;
    var code = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
    for (i = 0, len = code.length; i < len; ++i) {
      lookup[i] = code[i];
      revLookup[code.charCodeAt(i)] = i;
    }
    var i;
    var len;
    revLookup["-".charCodeAt(0)] = 62;
    revLookup["_".charCodeAt(0)] = 63;
    function getLens(b64) {
      var len2 = b64.length;
      if (len2 % 4 > 0) {
        throw new Error("Invalid string. Length must be a multiple of 4");
      }
      var validLen = b64.indexOf("=");
      if (validLen === -1)
        validLen = len2;
      var placeHoldersLen = validLen === len2 ? 0 : 4 - validLen % 4;
      return [validLen, placeHoldersLen];
    }
    function byteLength(b64) {
      var lens = getLens(b64);
      var validLen = lens[0];
      var placeHoldersLen = lens[1];
      return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
    }
    function _byteLength(b64, validLen, placeHoldersLen) {
      return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
    }
    function toByteArray(b64) {
      var tmp;
      var lens = getLens(b64);
      var validLen = lens[0];
      var placeHoldersLen = lens[1];
      var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen));
      var curByte = 0;
      var len2 = placeHoldersLen > 0 ? validLen - 4 : validLen;
      var i2;
      for (i2 = 0; i2 < len2; i2 += 4) {
        tmp = revLookup[b64.charCodeAt(i2)] << 18 | revLookup[b64.charCodeAt(i2 + 1)] << 12 | revLookup[b64.charCodeAt(i2 + 2)] << 6 | revLookup[b64.charCodeAt(i2 + 3)];
        arr[curByte++] = tmp >> 16 & 255;
        arr[curByte++] = tmp >> 8 & 255;
        arr[curByte++] = tmp & 255;
      }
      if (placeHoldersLen === 2) {
        tmp = revLookup[b64.charCodeAt(i2)] << 2 | revLookup[b64.charCodeAt(i2 + 1)] >> 4;
        arr[curByte++] = tmp & 255;
      }
      if (placeHoldersLen === 1) {
        tmp = revLookup[b64.charCodeAt(i2)] << 10 | revLookup[b64.charCodeAt(i2 + 1)] << 4 | revLookup[b64.charCodeAt(i2 + 2)] >> 2;
        arr[curByte++] = tmp >> 8 & 255;
        arr[curByte++] = tmp & 255;
      }
      return arr;
    }
    function tripletToBase64(num) {
      return lookup[num >> 18 & 63] + lookup[num >> 12 & 63] + lookup[num >> 6 & 63] + lookup[num & 63];
    }
    function encodeChunk(uint8, start, end) {
      var tmp;
      var output = [];
      for (var i2 = start; i2 < end; i2 += 3) {
        tmp = (uint8[i2] << 16 & 16711680) + (uint8[i2 + 1] << 8 & 65280) + (uint8[i2 + 2] & 255);
        output.push(tripletToBase64(tmp));
      }
      return output.join("");
    }
    function fromByteArray(uint8) {
      var tmp;
      var len2 = uint8.length;
      var extraBytes = len2 % 3;
      var parts = [];
      var maxChunkLength = 16383;
      for (var i2 = 0, len22 = len2 - extraBytes; i2 < len22; i2 += maxChunkLength) {
        parts.push(encodeChunk(uint8, i2, i2 + maxChunkLength > len22 ? len22 : i2 + maxChunkLength));
      }
      if (extraBytes === 1) {
        tmp = uint8[len2 - 1];
        parts.push(
          lookup[tmp >> 2] + lookup[tmp << 4 & 63] + "=="
        );
      } else if (extraBytes === 2) {
        tmp = (uint8[len2 - 2] << 8) + uint8[len2 - 1];
        parts.push(
          lookup[tmp >> 10] + lookup[tmp >> 4 & 63] + lookup[tmp << 2 & 63] + "="
        );
      }
      return parts.join("");
    }
  }
});

// node_modules/ieee754/index.js
var require_ieee754 = __commonJS({
  "node_modules/ieee754/index.js"(exports) {
    exports.read = function(buffer, offset, isLE, mLen, nBytes) {
      var e, m;
      var eLen = nBytes * 8 - mLen - 1;
      var eMax = (1 << eLen) - 1;
      var eBias = eMax >> 1;
      var nBits = -7;
      var i = isLE ? nBytes - 1 : 0;
      var d = isLE ? -1 : 1;
      var s = buffer[offset + i];
      i += d;
      e = s & (1 << -nBits) - 1;
      s >>= -nBits;
      nBits += eLen;
      for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {
      }
      m = e & (1 << -nBits) - 1;
      e >>= -nBits;
      nBits += mLen;
      for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {
      }
      if (e === 0) {
        e = 1 - eBias;
      } else if (e === eMax) {
        return m ? NaN : (s ? -1 : 1) * Infinity;
      } else {
        m = m + Math.pow(2, mLen);
        e = e - eBias;
      }
      return (s ? -1 : 1) * m * Math.pow(2, e - mLen);
    };
    exports.write = function(buffer, value, offset, isLE, mLen, nBytes) {
      var e, m, c;
      var eLen = nBytes * 8 - mLen - 1;
      var eMax = (1 << eLen) - 1;
      var eBias = eMax >> 1;
      var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
      var i = isLE ? 0 : nBytes - 1;
      var d = isLE ? 1 : -1;
      var s = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;
      value = Math.abs(value);
      if (isNaN(value) || value === Infinity) {
        m = isNaN(value) ? 1 : 0;
        e = eMax;
      } else {
        e = Math.floor(Math.log(value) / Math.LN2);
        if (value * (c = Math.pow(2, -e)) < 1) {
          e--;
          c *= 2;
        }
        if (e + eBias >= 1) {
          value += rt / c;
        } else {
          value += rt * Math.pow(2, 1 - eBias);
        }
        if (value * c >= 2) {
          e++;
          c /= 2;
        }
        if (e + eBias >= eMax) {
          m = 0;
          e = eMax;
        } else if (e + eBias >= 1) {
          m = (value * c - 1) * Math.pow(2, mLen);
          e = e + eBias;
        } else {
          m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
          e = 0;
        }
      }
      for (; mLen >= 8; buffer[offset + i] = m & 255, i += d, m /= 256, mLen -= 8) {
      }
      e = e << mLen | m;
      eLen += mLen;
      for (; eLen > 0; buffer[offset + i] = e & 255, i += d, e /= 256, eLen -= 8) {
      }
      buffer[offset + i - d] |= s * 128;
    };
  }
});

// node_modules/buffer/index.js
var require_buffer = __commonJS({
  "node_modules/buffer/index.js"(exports) {
    "use strict";
    var base64 = require_base64_js();
    var ieee754 = require_ieee754();
    var customInspectSymbol = typeof Symbol === "function" && typeof Symbol["for"] === "function" ? Symbol["for"]("nodejs.util.inspect.custom") : null;
    exports.Buffer = Buffer2;
    exports.SlowBuffer = SlowBuffer;
    exports.INSPECT_MAX_BYTES = 50;
    var K_MAX_LENGTH = 2147483647;
    exports.kMaxLength = K_MAX_LENGTH;
    Buffer2.TYPED_ARRAY_SUPPORT = typedArraySupport();
    if (!Buffer2.TYPED_ARRAY_SUPPORT && typeof console !== "undefined" && typeof console.error === "function") {
      console.error(
        "This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support."
      );
    }
    function typedArraySupport() {
      try {
        const arr = new Uint8Array(1);
        const proto = { foo: function() {
          return 42;
        } };
        Object.setPrototypeOf(proto, Uint8Array.prototype);
        Object.setPrototypeOf(arr, proto);
        return arr.foo() === 42;
      } catch (e) {
        return false;
      }
    }
    Object.defineProperty(Buffer2.prototype, "parent", {
      enumerable: true,
      get: function() {
        if (!Buffer2.isBuffer(this))
          return void 0;
        return this.buffer;
      }
    });
    Object.defineProperty(Buffer2.prototype, "offset", {
      enumerable: true,
      get: function() {
        if (!Buffer2.isBuffer(this))
          return void 0;
        return this.byteOffset;
      }
    });
    function createBuffer(length) {
      if (length > K_MAX_LENGTH) {
        throw new RangeError('The value "' + length + '" is invalid for option "size"');
      }
      const buf = new Uint8Array(length);
      Object.setPrototypeOf(buf, Buffer2.prototype);
      return buf;
    }
    function Buffer2(arg, encodingOrOffset, length) {
      if (typeof arg === "number") {
        if (typeof encodingOrOffset === "string") {
          throw new TypeError(
            'The "string" argument must be of type string. Received type number'
          );
        }
        return allocUnsafe(arg);
      }
      return from(arg, encodingOrOffset, length);
    }
    Buffer2.poolSize = 8192;
    function from(value, encodingOrOffset, length) {
      if (typeof value === "string") {
        return fromString(value, encodingOrOffset);
      }
      if (ArrayBuffer.isView(value)) {
        return fromArrayView(value);
      }
      if (value == null) {
        throw new TypeError(
          "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value
        );
      }
      if (isInstance(value, ArrayBuffer) || value && isInstance(value.buffer, ArrayBuffer)) {
        return fromArrayBuffer(value, encodingOrOffset, length);
      }
      if (typeof SharedArrayBuffer !== "undefined" && (isInstance(value, SharedArrayBuffer) || value && isInstance(value.buffer, SharedArrayBuffer))) {
        return fromArrayBuffer(value, encodingOrOffset, length);
      }
      if (typeof value === "number") {
        throw new TypeError(
          'The "value" argument must not be of type number. Received type number'
        );
      }
      const valueOf = value.valueOf && value.valueOf();
      if (valueOf != null && valueOf !== value) {
        return Buffer2.from(valueOf, encodingOrOffset, length);
      }
      const b = fromObject(value);
      if (b)
        return b;
      if (typeof Symbol !== "undefined" && Symbol.toPrimitive != null && typeof value[Symbol.toPrimitive] === "function") {
        return Buffer2.from(value[Symbol.toPrimitive]("string"), encodingOrOffset, length);
      }
      throw new TypeError(
        "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value
      );
    }
    Buffer2.from = function(value, encodingOrOffset, length) {
      return from(value, encodingOrOffset, length);
    };
    Object.setPrototypeOf(Buffer2.prototype, Uint8Array.prototype);
    Object.setPrototypeOf(Buffer2, Uint8Array);
    function assertSize(size) {
      if (typeof size !== "number") {
        throw new TypeError('"size" argument must be of type number');
      } else if (size < 0) {
        throw new RangeError('The value "' + size + '" is invalid for option "size"');
      }
    }
    function alloc(size, fill, encoding) {
      assertSize(size);
      if (size <= 0) {
        return createBuffer(size);
      }
      if (fill !== void 0) {
        return typeof encoding === "string" ? createBuffer(size).fill(fill, encoding) : createBuffer(size).fill(fill);
      }
      return createBuffer(size);
    }
    Buffer2.alloc = function(size, fill, encoding) {
      return alloc(size, fill, encoding);
    };
    function allocUnsafe(size) {
      assertSize(size);
      return createBuffer(size < 0 ? 0 : checked(size) | 0);
    }
    Buffer2.allocUnsafe = function(size) {
      return allocUnsafe(size);
    };
    Buffer2.allocUnsafeSlow = function(size) {
      return allocUnsafe(size);
    };
    function fromString(string, encoding) {
      if (typeof encoding !== "string" || encoding === "") {
        encoding = "utf8";
      }
      if (!Buffer2.isEncoding(encoding)) {
        throw new TypeError("Unknown encoding: " + encoding);
      }
      const length = byteLength(string, encoding) | 0;
      let buf = createBuffer(length);
      const actual = buf.write(string, encoding);
      if (actual !== length) {
        buf = buf.slice(0, actual);
      }
      return buf;
    }
    function fromArrayLike(array) {
      const length = array.length < 0 ? 0 : checked(array.length) | 0;
      const buf = createBuffer(length);
      for (let i = 0; i < length; i += 1) {
        buf[i] = array[i] & 255;
      }
      return buf;
    }
    function fromArrayView(arrayView) {
      if (isInstance(arrayView, Uint8Array)) {
        const copy = new Uint8Array(arrayView);
        return fromArrayBuffer(copy.buffer, copy.byteOffset, copy.byteLength);
      }
      return fromArrayLike(arrayView);
    }
    function fromArrayBuffer(array, byteOffset, length) {
      if (byteOffset < 0 || array.byteLength < byteOffset) {
        throw new RangeError('"offset" is outside of buffer bounds');
      }
      if (array.byteLength < byteOffset + (length || 0)) {
        throw new RangeError('"length" is outside of buffer bounds');
      }
      let buf;
      if (byteOffset === void 0 && length === void 0) {
        buf = new Uint8Array(array);
      } else if (length === void 0) {
        buf = new Uint8Array(array, byteOffset);
      } else {
        buf = new Uint8Array(array, byteOffset, length);
      }
      Object.setPrototypeOf(buf, Buffer2.prototype);
      return buf;
    }
    function fromObject(obj) {
      if (Buffer2.isBuffer(obj)) {
        const len = checked(obj.length) | 0;
        const buf = createBuffer(len);
        if (buf.length === 0) {
          return buf;
        }
        obj.copy(buf, 0, 0, len);
        return buf;
      }
      if (obj.length !== void 0) {
        if (typeof obj.length !== "number" || numberIsNaN(obj.length)) {
          return createBuffer(0);
        }
        return fromArrayLike(obj);
      }
      if (obj.type === "Buffer" && Array.isArray(obj.data)) {
        return fromArrayLike(obj.data);
      }
    }
    function checked(length) {
      if (length >= K_MAX_LENGTH) {
        throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + K_MAX_LENGTH.toString(16) + " bytes");
      }
      return length | 0;
    }
    function SlowBuffer(length) {
      if (+length != length) {
        length = 0;
      }
      return Buffer2.alloc(+length);
    }
    Buffer2.isBuffer = function isBuffer(b) {
      return b != null && b._isBuffer === true && b !== Buffer2.prototype;
    };
    Buffer2.compare = function compare2(a, b) {
      if (isInstance(a, Uint8Array))
        a = Buffer2.from(a, a.offset, a.byteLength);
      if (isInstance(b, Uint8Array))
        b = Buffer2.from(b, b.offset, b.byteLength);
      if (!Buffer2.isBuffer(a) || !Buffer2.isBuffer(b)) {
        throw new TypeError(
          'The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array'
        );
      }
      if (a === b)
        return 0;
      let x = a.length;
      let y = b.length;
      for (let i = 0, len = Math.min(x, y); i < len; ++i) {
        if (a[i] !== b[i]) {
          x = a[i];
          y = b[i];
          break;
        }
      }
      if (x < y)
        return -1;
      if (y < x)
        return 1;
      return 0;
    };
    Buffer2.isEncoding = function isEncoding(encoding) {
      switch (String(encoding).toLowerCase()) {
        case "hex":
        case "utf8":
        case "utf-8":
        case "ascii":
        case "latin1":
        case "binary":
        case "base64":
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return true;
        default:
          return false;
      }
    };
    Buffer2.concat = function concat(list, length) {
      if (!Array.isArray(list)) {
        throw new TypeError('"list" argument must be an Array of Buffers');
      }
      if (list.length === 0) {
        return Buffer2.alloc(0);
      }
      let i;
      if (length === void 0) {
        length = 0;
        for (i = 0; i < list.length; ++i) {
          length += list[i].length;
        }
      }
      const buffer = Buffer2.allocUnsafe(length);
      let pos = 0;
      for (i = 0; i < list.length; ++i) {
        let buf = list[i];
        if (isInstance(buf, Uint8Array)) {
          if (pos + buf.length > buffer.length) {
            if (!Buffer2.isBuffer(buf))
              buf = Buffer2.from(buf);
            buf.copy(buffer, pos);
          } else {
            Uint8Array.prototype.set.call(
              buffer,
              buf,
              pos
            );
          }
        } else if (!Buffer2.isBuffer(buf)) {
          throw new TypeError('"list" argument must be an Array of Buffers');
        } else {
          buf.copy(buffer, pos);
        }
        pos += buf.length;
      }
      return buffer;
    };
    function byteLength(string, encoding) {
      if (Buffer2.isBuffer(string)) {
        return string.length;
      }
      if (ArrayBuffer.isView(string) || isInstance(string, ArrayBuffer)) {
        return string.byteLength;
      }
      if (typeof string !== "string") {
        throw new TypeError(
          'The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof string
        );
      }
      const len = string.length;
      const mustMatch = arguments.length > 2 && arguments[2] === true;
      if (!mustMatch && len === 0)
        return 0;
      let loweredCase = false;
      for (; ; ) {
        switch (encoding) {
          case "ascii":
          case "latin1":
          case "binary":
            return len;
          case "utf8":
          case "utf-8":
            return utf8ToBytes(string).length;
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return len * 2;
          case "hex":
            return len >>> 1;
          case "base64":
            return base64ToBytes(string).length;
          default:
            if (loweredCase) {
              return mustMatch ? -1 : utf8ToBytes(string).length;
            }
            encoding = ("" + encoding).toLowerCase();
            loweredCase = true;
        }
      }
    }
    Buffer2.byteLength = byteLength;
    function slowToString(encoding, start, end) {
      let loweredCase = false;
      if (start === void 0 || start < 0) {
        start = 0;
      }
      if (start > this.length) {
        return "";
      }
      if (end === void 0 || end > this.length) {
        end = this.length;
      }
      if (end <= 0) {
        return "";
      }
      end >>>= 0;
      start >>>= 0;
      if (end <= start) {
        return "";
      }
      if (!encoding)
        encoding = "utf8";
      while (true) {
        switch (encoding) {
          case "hex":
            return hexSlice(this, start, end);
          case "utf8":
          case "utf-8":
            return utf8Slice(this, start, end);
          case "ascii":
            return asciiSlice(this, start, end);
          case "latin1":
          case "binary":
            return latin1Slice(this, start, end);
          case "base64":
            return base64Slice(this, start, end);
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return utf16leSlice(this, start, end);
          default:
            if (loweredCase)
              throw new TypeError("Unknown encoding: " + encoding);
            encoding = (encoding + "").toLowerCase();
            loweredCase = true;
        }
      }
    }
    Buffer2.prototype._isBuffer = true;
    function swap(b, n, m) {
      const i = b[n];
      b[n] = b[m];
      b[m] = i;
    }
    Buffer2.prototype.swap16 = function swap16() {
      const len = this.length;
      if (len % 2 !== 0) {
        throw new RangeError("Buffer size must be a multiple of 16-bits");
      }
      for (let i = 0; i < len; i += 2) {
        swap(this, i, i + 1);
      }
      return this;
    };
    Buffer2.prototype.swap32 = function swap32() {
      const len = this.length;
      if (len % 4 !== 0) {
        throw new RangeError("Buffer size must be a multiple of 32-bits");
      }
      for (let i = 0; i < len; i += 4) {
        swap(this, i, i + 3);
        swap(this, i + 1, i + 2);
      }
      return this;
    };
    Buffer2.prototype.swap64 = function swap64() {
      const len = this.length;
      if (len % 8 !== 0) {
        throw new RangeError("Buffer size must be a multiple of 64-bits");
      }
      for (let i = 0; i < len; i += 8) {
        swap(this, i, i + 7);
        swap(this, i + 1, i + 6);
        swap(this, i + 2, i + 5);
        swap(this, i + 3, i + 4);
      }
      return this;
    };
    Buffer2.prototype.toString = function toString() {
      const length = this.length;
      if (length === 0)
        return "";
      if (arguments.length === 0)
        return utf8Slice(this, 0, length);
      return slowToString.apply(this, arguments);
    };
    Buffer2.prototype.toLocaleString = Buffer2.prototype.toString;
    Buffer2.prototype.equals = function equals(b) {
      if (!Buffer2.isBuffer(b))
        throw new TypeError("Argument must be a Buffer");
      if (this === b)
        return true;
      return Buffer2.compare(this, b) === 0;
    };
    Buffer2.prototype.inspect = function inspect() {
      let str = "";
      const max = exports.INSPECT_MAX_BYTES;
      str = this.toString("hex", 0, max).replace(/(.{2})/g, "$1 ").trim();
      if (this.length > max)
        str += " ... ";
      return "<Buffer " + str + ">";
    };
    if (customInspectSymbol) {
      Buffer2.prototype[customInspectSymbol] = Buffer2.prototype.inspect;
    }
    Buffer2.prototype.compare = function compare2(target, start, end, thisStart, thisEnd) {
      if (isInstance(target, Uint8Array)) {
        target = Buffer2.from(target, target.offset, target.byteLength);
      }
      if (!Buffer2.isBuffer(target)) {
        throw new TypeError(
          'The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof target
        );
      }
      if (start === void 0) {
        start = 0;
      }
      if (end === void 0) {
        end = target ? target.length : 0;
      }
      if (thisStart === void 0) {
        thisStart = 0;
      }
      if (thisEnd === void 0) {
        thisEnd = this.length;
      }
      if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
        throw new RangeError("out of range index");
      }
      if (thisStart >= thisEnd && start >= end) {
        return 0;
      }
      if (thisStart >= thisEnd) {
        return -1;
      }
      if (start >= end) {
        return 1;
      }
      start >>>= 0;
      end >>>= 0;
      thisStart >>>= 0;
      thisEnd >>>= 0;
      if (this === target)
        return 0;
      let x = thisEnd - thisStart;
      let y = end - start;
      const len = Math.min(x, y);
      const thisCopy = this.slice(thisStart, thisEnd);
      const targetCopy = target.slice(start, end);
      for (let i = 0; i < len; ++i) {
        if (thisCopy[i] !== targetCopy[i]) {
          x = thisCopy[i];
          y = targetCopy[i];
          break;
        }
      }
      if (x < y)
        return -1;
      if (y < x)
        return 1;
      return 0;
    };
    function bidirectionalIndexOf(buffer, val, byteOffset, encoding, dir) {
      if (buffer.length === 0)
        return -1;
      if (typeof byteOffset === "string") {
        encoding = byteOffset;
        byteOffset = 0;
      } else if (byteOffset > 2147483647) {
        byteOffset = 2147483647;
      } else if (byteOffset < -2147483648) {
        byteOffset = -2147483648;
      }
      byteOffset = +byteOffset;
      if (numberIsNaN(byteOffset)) {
        byteOffset = dir ? 0 : buffer.length - 1;
      }
      if (byteOffset < 0)
        byteOffset = buffer.length + byteOffset;
      if (byteOffset >= buffer.length) {
        if (dir)
          return -1;
        else
          byteOffset = buffer.length - 1;
      } else if (byteOffset < 0) {
        if (dir)
          byteOffset = 0;
        else
          return -1;
      }
      if (typeof val === "string") {
        val = Buffer2.from(val, encoding);
      }
      if (Buffer2.isBuffer(val)) {
        if (val.length === 0) {
          return -1;
        }
        return arrayIndexOf(buffer, val, byteOffset, encoding, dir);
      } else if (typeof val === "number") {
        val = val & 255;
        if (typeof Uint8Array.prototype.indexOf === "function") {
          if (dir) {
            return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset);
          } else {
            return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset);
          }
        }
        return arrayIndexOf(buffer, [val], byteOffset, encoding, dir);
      }
      throw new TypeError("val must be string, number or Buffer");
    }
    function arrayIndexOf(arr, val, byteOffset, encoding, dir) {
      let indexSize = 1;
      let arrLength = arr.length;
      let valLength = val.length;
      if (encoding !== void 0) {
        encoding = String(encoding).toLowerCase();
        if (encoding === "ucs2" || encoding === "ucs-2" || encoding === "utf16le" || encoding === "utf-16le") {
          if (arr.length < 2 || val.length < 2) {
            return -1;
          }
          indexSize = 2;
          arrLength /= 2;
          valLength /= 2;
          byteOffset /= 2;
        }
      }
      function read2(buf, i2) {
        if (indexSize === 1) {
          return buf[i2];
        } else {
          return buf.readUInt16BE(i2 * indexSize);
        }
      }
      let i;
      if (dir) {
        let foundIndex = -1;
        for (i = byteOffset; i < arrLength; i++) {
          if (read2(arr, i) === read2(val, foundIndex === -1 ? 0 : i - foundIndex)) {
            if (foundIndex === -1)
              foundIndex = i;
            if (i - foundIndex + 1 === valLength)
              return foundIndex * indexSize;
          } else {
            if (foundIndex !== -1)
              i -= i - foundIndex;
            foundIndex = -1;
          }
        }
      } else {
        if (byteOffset + valLength > arrLength)
          byteOffset = arrLength - valLength;
        for (i = byteOffset; i >= 0; i--) {
          let found = true;
          for (let j = 0; j < valLength; j++) {
            if (read2(arr, i + j) !== read2(val, j)) {
              found = false;
              break;
            }
          }
          if (found)
            return i;
        }
      }
      return -1;
    }
    Buffer2.prototype.includes = function includes(val, byteOffset, encoding) {
      return this.indexOf(val, byteOffset, encoding) !== -1;
    };
    Buffer2.prototype.indexOf = function indexOf(val, byteOffset, encoding) {
      return bidirectionalIndexOf(this, val, byteOffset, encoding, true);
    };
    Buffer2.prototype.lastIndexOf = function lastIndexOf(val, byteOffset, encoding) {
      return bidirectionalIndexOf(this, val, byteOffset, encoding, false);
    };
    function hexWrite(buf, string, offset, length) {
      offset = Number(offset) || 0;
      const remaining = buf.length - offset;
      if (!length) {
        length = remaining;
      } else {
        length = Number(length);
        if (length > remaining) {
          length = remaining;
        }
      }
      const strLen = string.length;
      if (length > strLen / 2) {
        length = strLen / 2;
      }
      let i;
      for (i = 0; i < length; ++i) {
        const parsed = parseInt(string.substr(i * 2, 2), 16);
        if (numberIsNaN(parsed))
          return i;
        buf[offset + i] = parsed;
      }
      return i;
    }
    function utf8Write(buf, string, offset, length) {
      return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length);
    }
    function asciiWrite(buf, string, offset, length) {
      return blitBuffer(asciiToBytes(string), buf, offset, length);
    }
    function base64Write(buf, string, offset, length) {
      return blitBuffer(base64ToBytes(string), buf, offset, length);
    }
    function ucs2Write(buf, string, offset, length) {
      return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length);
    }
    Buffer2.prototype.write = function write(string, offset, length, encoding) {
      if (offset === void 0) {
        encoding = "utf8";
        length = this.length;
        offset = 0;
      } else if (length === void 0 && typeof offset === "string") {
        encoding = offset;
        length = this.length;
        offset = 0;
      } else if (isFinite(offset)) {
        offset = offset >>> 0;
        if (isFinite(length)) {
          length = length >>> 0;
          if (encoding === void 0)
            encoding = "utf8";
        } else {
          encoding = length;
          length = void 0;
        }
      } else {
        throw new Error(
          "Buffer.write(string, encoding, offset[, length]) is no longer supported"
        );
      }
      const remaining = this.length - offset;
      if (length === void 0 || length > remaining)
        length = remaining;
      if (string.length > 0 && (length < 0 || offset < 0) || offset > this.length) {
        throw new RangeError("Attempt to write outside buffer bounds");
      }
      if (!encoding)
        encoding = "utf8";
      let loweredCase = false;
      for (; ; ) {
        switch (encoding) {
          case "hex":
            return hexWrite(this, string, offset, length);
          case "utf8":
          case "utf-8":
            return utf8Write(this, string, offset, length);
          case "ascii":
          case "latin1":
          case "binary":
            return asciiWrite(this, string, offset, length);
          case "base64":
            return base64Write(this, string, offset, length);
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return ucs2Write(this, string, offset, length);
          default:
            if (loweredCase)
              throw new TypeError("Unknown encoding: " + encoding);
            encoding = ("" + encoding).toLowerCase();
            loweredCase = true;
        }
      }
    };
    Buffer2.prototype.toJSON = function toJSON() {
      return {
        type: "Buffer",
        data: Array.prototype.slice.call(this._arr || this, 0)
      };
    };
    function base64Slice(buf, start, end) {
      if (start === 0 && end === buf.length) {
        return base64.fromByteArray(buf);
      } else {
        return base64.fromByteArray(buf.slice(start, end));
      }
    }
    function utf8Slice(buf, start, end) {
      end = Math.min(buf.length, end);
      const res = [];
      let i = start;
      while (i < end) {
        const firstByte = buf[i];
        let codePoint = null;
        let bytesPerSequence = firstByte > 239 ? 4 : firstByte > 223 ? 3 : firstByte > 191 ? 2 : 1;
        if (i + bytesPerSequence <= end) {
          let secondByte, thirdByte, fourthByte, tempCodePoint;
          switch (bytesPerSequence) {
            case 1:
              if (firstByte < 128) {
                codePoint = firstByte;
              }
              break;
            case 2:
              secondByte = buf[i + 1];
              if ((secondByte & 192) === 128) {
                tempCodePoint = (firstByte & 31) << 6 | secondByte & 63;
                if (tempCodePoint > 127) {
                  codePoint = tempCodePoint;
                }
              }
              break;
            case 3:
              secondByte = buf[i + 1];
              thirdByte = buf[i + 2];
              if ((secondByte & 192) === 128 && (thirdByte & 192) === 128) {
                tempCodePoint = (firstByte & 15) << 12 | (secondByte & 63) << 6 | thirdByte & 63;
                if (tempCodePoint > 2047 && (tempCodePoint < 55296 || tempCodePoint > 57343)) {
                  codePoint = tempCodePoint;
                }
              }
              break;
            case 4:
              secondByte = buf[i + 1];
              thirdByte = buf[i + 2];
              fourthByte = buf[i + 3];
              if ((secondByte & 192) === 128 && (thirdByte & 192) === 128 && (fourthByte & 192) === 128) {
                tempCodePoint = (firstByte & 15) << 18 | (secondByte & 63) << 12 | (thirdByte & 63) << 6 | fourthByte & 63;
                if (tempCodePoint > 65535 && tempCodePoint < 1114112) {
                  codePoint = tempCodePoint;
                }
              }
          }
        }
        if (codePoint === null) {
          codePoint = 65533;
          bytesPerSequence = 1;
        } else if (codePoint > 65535) {
          codePoint -= 65536;
          res.push(codePoint >>> 10 & 1023 | 55296);
          codePoint = 56320 | codePoint & 1023;
        }
        res.push(codePoint);
        i += bytesPerSequence;
      }
      return decodeCodePointsArray(res);
    }
    var MAX_ARGUMENTS_LENGTH = 4096;
    function decodeCodePointsArray(codePoints) {
      const len = codePoints.length;
      if (len <= MAX_ARGUMENTS_LENGTH) {
        return String.fromCharCode.apply(String, codePoints);
      }
      let res = "";
      let i = 0;
      while (i < len) {
        res += String.fromCharCode.apply(
          String,
          codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
        );
      }
      return res;
    }
    function asciiSlice(buf, start, end) {
      let ret = "";
      end = Math.min(buf.length, end);
      for (let i = start; i < end; ++i) {
        ret += String.fromCharCode(buf[i] & 127);
      }
      return ret;
    }
    function latin1Slice(buf, start, end) {
      let ret = "";
      end = Math.min(buf.length, end);
      for (let i = start; i < end; ++i) {
        ret += String.fromCharCode(buf[i]);
      }
      return ret;
    }
    function hexSlice(buf, start, end) {
      const len = buf.length;
      if (!start || start < 0)
        start = 0;
      if (!end || end < 0 || end > len)
        end = len;
      let out = "";
      for (let i = start; i < end; ++i) {
        out += hexSliceLookupTable[buf[i]];
      }
      return out;
    }
    function utf16leSlice(buf, start, end) {
      const bytes = buf.slice(start, end);
      let res = "";
      for (let i = 0; i < bytes.length - 1; i += 2) {
        res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256);
      }
      return res;
    }
    Buffer2.prototype.slice = function slice(start, end) {
      const len = this.length;
      start = ~~start;
      end = end === void 0 ? len : ~~end;
      if (start < 0) {
        start += len;
        if (start < 0)
          start = 0;
      } else if (start > len) {
        start = len;
      }
      if (end < 0) {
        end += len;
        if (end < 0)
          end = 0;
      } else if (end > len) {
        end = len;
      }
      if (end < start)
        end = start;
      const newBuf = this.subarray(start, end);
      Object.setPrototypeOf(newBuf, Buffer2.prototype);
      return newBuf;
    };
    function checkOffset(offset, ext, length) {
      if (offset % 1 !== 0 || offset < 0)
        throw new RangeError("offset is not uint");
      if (offset + ext > length)
        throw new RangeError("Trying to access beyond buffer length");
    }
    Buffer2.prototype.readUintLE = Buffer2.prototype.readUIntLE = function readUIntLE(offset, byteLength2, noAssert) {
      offset = offset >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert)
        checkOffset(offset, byteLength2, this.length);
      let val = this[offset];
      let mul = 1;
      let i = 0;
      while (++i < byteLength2 && (mul *= 256)) {
        val += this[offset + i] * mul;
      }
      return val;
    };
    Buffer2.prototype.readUintBE = Buffer2.prototype.readUIntBE = function readUIntBE(offset, byteLength2, noAssert) {
      offset = offset >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert) {
        checkOffset(offset, byteLength2, this.length);
      }
      let val = this[offset + --byteLength2];
      let mul = 1;
      while (byteLength2 > 0 && (mul *= 256)) {
        val += this[offset + --byteLength2] * mul;
      }
      return val;
    };
    Buffer2.prototype.readUint8 = Buffer2.prototype.readUInt8 = function readUInt8(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 1, this.length);
      return this[offset];
    };
    Buffer2.prototype.readUint16LE = Buffer2.prototype.readUInt16LE = function readUInt16LE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 2, this.length);
      return this[offset] | this[offset + 1] << 8;
    };
    Buffer2.prototype.readUint16BE = Buffer2.prototype.readUInt16BE = function readUInt16BE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 2, this.length);
      return this[offset] << 8 | this[offset + 1];
    };
    Buffer2.prototype.readUint32LE = Buffer2.prototype.readUInt32LE = function readUInt32LE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 4, this.length);
      return (this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16) + this[offset + 3] * 16777216;
    };
    Buffer2.prototype.readUint32BE = Buffer2.prototype.readUInt32BE = function readUInt32BE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 4, this.length);
      return this[offset] * 16777216 + (this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3]);
    };
    Buffer2.prototype.readBigUInt64LE = defineBigIntMethod(function readBigUInt64LE(offset) {
      offset = offset >>> 0;
      validateNumber(offset, "offset");
      const first = this[offset];
      const last = this[offset + 7];
      if (first === void 0 || last === void 0) {
        boundsError(offset, this.length - 8);
      }
      const lo = first + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 24;
      const hi = this[++offset] + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + last * 2 ** 24;
      return BigInt(lo) + (BigInt(hi) << BigInt(32));
    });
    Buffer2.prototype.readBigUInt64BE = defineBigIntMethod(function readBigUInt64BE(offset) {
      offset = offset >>> 0;
      validateNumber(offset, "offset");
      const first = this[offset];
      const last = this[offset + 7];
      if (first === void 0 || last === void 0) {
        boundsError(offset, this.length - 8);
      }
      const hi = first * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + this[++offset];
      const lo = this[++offset] * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + last;
      return (BigInt(hi) << BigInt(32)) + BigInt(lo);
    });
    Buffer2.prototype.readIntLE = function readIntLE(offset, byteLength2, noAssert) {
      offset = offset >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert)
        checkOffset(offset, byteLength2, this.length);
      let val = this[offset];
      let mul = 1;
      let i = 0;
      while (++i < byteLength2 && (mul *= 256)) {
        val += this[offset + i] * mul;
      }
      mul *= 128;
      if (val >= mul)
        val -= Math.pow(2, 8 * byteLength2);
      return val;
    };
    Buffer2.prototype.readIntBE = function readIntBE(offset, byteLength2, noAssert) {
      offset = offset >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert)
        checkOffset(offset, byteLength2, this.length);
      let i = byteLength2;
      let mul = 1;
      let val = this[offset + --i];
      while (i > 0 && (mul *= 256)) {
        val += this[offset + --i] * mul;
      }
      mul *= 128;
      if (val >= mul)
        val -= Math.pow(2, 8 * byteLength2);
      return val;
    };
    Buffer2.prototype.readInt8 = function readInt8(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 1, this.length);
      if (!(this[offset] & 128))
        return this[offset];
      return (255 - this[offset] + 1) * -1;
    };
    Buffer2.prototype.readInt16LE = function readInt16LE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 2, this.length);
      const val = this[offset] | this[offset + 1] << 8;
      return val & 32768 ? val | 4294901760 : val;
    };
    Buffer2.prototype.readInt16BE = function readInt16BE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 2, this.length);
      const val = this[offset + 1] | this[offset] << 8;
      return val & 32768 ? val | 4294901760 : val;
    };
    Buffer2.prototype.readInt32LE = function readInt32LE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 4, this.length);
      return this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16 | this[offset + 3] << 24;
    };
    Buffer2.prototype.readInt32BE = function readInt32BE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 4, this.length);
      return this[offset] << 24 | this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3];
    };
    Buffer2.prototype.readBigInt64LE = defineBigIntMethod(function readBigInt64LE(offset) {
      offset = offset >>> 0;
      validateNumber(offset, "offset");
      const first = this[offset];
      const last = this[offset + 7];
      if (first === void 0 || last === void 0) {
        boundsError(offset, this.length - 8);
      }
      const val = this[offset + 4] + this[offset + 5] * 2 ** 8 + this[offset + 6] * 2 ** 16 + (last << 24);
      return (BigInt(val) << BigInt(32)) + BigInt(first + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 24);
    });
    Buffer2.prototype.readBigInt64BE = defineBigIntMethod(function readBigInt64BE(offset) {
      offset = offset >>> 0;
      validateNumber(offset, "offset");
      const first = this[offset];
      const last = this[offset + 7];
      if (first === void 0 || last === void 0) {
        boundsError(offset, this.length - 8);
      }
      const val = (first << 24) + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + this[++offset];
      return (BigInt(val) << BigInt(32)) + BigInt(this[++offset] * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + last);
    });
    Buffer2.prototype.readFloatLE = function readFloatLE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 4, this.length);
      return ieee754.read(this, offset, true, 23, 4);
    };
    Buffer2.prototype.readFloatBE = function readFloatBE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 4, this.length);
      return ieee754.read(this, offset, false, 23, 4);
    };
    Buffer2.prototype.readDoubleLE = function readDoubleLE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 8, this.length);
      return ieee754.read(this, offset, true, 52, 8);
    };
    Buffer2.prototype.readDoubleBE = function readDoubleBE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 8, this.length);
      return ieee754.read(this, offset, false, 52, 8);
    };
    function checkInt(buf, value, offset, ext, max, min) {
      if (!Buffer2.isBuffer(buf))
        throw new TypeError('"buffer" argument must be a Buffer instance');
      if (value > max || value < min)
        throw new RangeError('"value" argument is out of bounds');
      if (offset + ext > buf.length)
        throw new RangeError("Index out of range");
    }
    Buffer2.prototype.writeUintLE = Buffer2.prototype.writeUIntLE = function writeUIntLE(value, offset, byteLength2, noAssert) {
      value = +value;
      offset = offset >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert) {
        const maxBytes = Math.pow(2, 8 * byteLength2) - 1;
        checkInt(this, value, offset, byteLength2, maxBytes, 0);
      }
      let mul = 1;
      let i = 0;
      this[offset] = value & 255;
      while (++i < byteLength2 && (mul *= 256)) {
        this[offset + i] = value / mul & 255;
      }
      return offset + byteLength2;
    };
    Buffer2.prototype.writeUintBE = Buffer2.prototype.writeUIntBE = function writeUIntBE(value, offset, byteLength2, noAssert) {
      value = +value;
      offset = offset >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert) {
        const maxBytes = Math.pow(2, 8 * byteLength2) - 1;
        checkInt(this, value, offset, byteLength2, maxBytes, 0);
      }
      let i = byteLength2 - 1;
      let mul = 1;
      this[offset + i] = value & 255;
      while (--i >= 0 && (mul *= 256)) {
        this[offset + i] = value / mul & 255;
      }
      return offset + byteLength2;
    };
    Buffer2.prototype.writeUint8 = Buffer2.prototype.writeUInt8 = function writeUInt8(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value, offset, 1, 255, 0);
      this[offset] = value & 255;
      return offset + 1;
    };
    Buffer2.prototype.writeUint16LE = Buffer2.prototype.writeUInt16LE = function writeUInt16LE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value, offset, 2, 65535, 0);
      this[offset] = value & 255;
      this[offset + 1] = value >>> 8;
      return offset + 2;
    };
    Buffer2.prototype.writeUint16BE = Buffer2.prototype.writeUInt16BE = function writeUInt16BE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value, offset, 2, 65535, 0);
      this[offset] = value >>> 8;
      this[offset + 1] = value & 255;
      return offset + 2;
    };
    Buffer2.prototype.writeUint32LE = Buffer2.prototype.writeUInt32LE = function writeUInt32LE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value, offset, 4, 4294967295, 0);
      this[offset + 3] = value >>> 24;
      this[offset + 2] = value >>> 16;
      this[offset + 1] = value >>> 8;
      this[offset] = value & 255;
      return offset + 4;
    };
    Buffer2.prototype.writeUint32BE = Buffer2.prototype.writeUInt32BE = function writeUInt32BE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value, offset, 4, 4294967295, 0);
      this[offset] = value >>> 24;
      this[offset + 1] = value >>> 16;
      this[offset + 2] = value >>> 8;
      this[offset + 3] = value & 255;
      return offset + 4;
    };
    function wrtBigUInt64LE(buf, value, offset, min, max) {
      checkIntBI(value, min, max, buf, offset, 7);
      let lo = Number(value & BigInt(4294967295));
      buf[offset++] = lo;
      lo = lo >> 8;
      buf[offset++] = lo;
      lo = lo >> 8;
      buf[offset++] = lo;
      lo = lo >> 8;
      buf[offset++] = lo;
      let hi = Number(value >> BigInt(32) & BigInt(4294967295));
      buf[offset++] = hi;
      hi = hi >> 8;
      buf[offset++] = hi;
      hi = hi >> 8;
      buf[offset++] = hi;
      hi = hi >> 8;
      buf[offset++] = hi;
      return offset;
    }
    function wrtBigUInt64BE(buf, value, offset, min, max) {
      checkIntBI(value, min, max, buf, offset, 7);
      let lo = Number(value & BigInt(4294967295));
      buf[offset + 7] = lo;
      lo = lo >> 8;
      buf[offset + 6] = lo;
      lo = lo >> 8;
      buf[offset + 5] = lo;
      lo = lo >> 8;
      buf[offset + 4] = lo;
      let hi = Number(value >> BigInt(32) & BigInt(4294967295));
      buf[offset + 3] = hi;
      hi = hi >> 8;
      buf[offset + 2] = hi;
      hi = hi >> 8;
      buf[offset + 1] = hi;
      hi = hi >> 8;
      buf[offset] = hi;
      return offset + 8;
    }
    Buffer2.prototype.writeBigUInt64LE = defineBigIntMethod(function writeBigUInt64LE(value, offset = 0) {
      return wrtBigUInt64LE(this, value, offset, BigInt(0), BigInt("0xffffffffffffffff"));
    });
    Buffer2.prototype.writeBigUInt64BE = defineBigIntMethod(function writeBigUInt64BE(value, offset = 0) {
      return wrtBigUInt64BE(this, value, offset, BigInt(0), BigInt("0xffffffffffffffff"));
    });
    Buffer2.prototype.writeIntLE = function writeIntLE(value, offset, byteLength2, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) {
        const limit = Math.pow(2, 8 * byteLength2 - 1);
        checkInt(this, value, offset, byteLength2, limit - 1, -limit);
      }
      let i = 0;
      let mul = 1;
      let sub = 0;
      this[offset] = value & 255;
      while (++i < byteLength2 && (mul *= 256)) {
        if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
          sub = 1;
        }
        this[offset + i] = (value / mul >> 0) - sub & 255;
      }
      return offset + byteLength2;
    };
    Buffer2.prototype.writeIntBE = function writeIntBE(value, offset, byteLength2, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) {
        const limit = Math.pow(2, 8 * byteLength2 - 1);
        checkInt(this, value, offset, byteLength2, limit - 1, -limit);
      }
      let i = byteLength2 - 1;
      let mul = 1;
      let sub = 0;
      this[offset + i] = value & 255;
      while (--i >= 0 && (mul *= 256)) {
        if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
          sub = 1;
        }
        this[offset + i] = (value / mul >> 0) - sub & 255;
      }
      return offset + byteLength2;
    };
    Buffer2.prototype.writeInt8 = function writeInt8(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value, offset, 1, 127, -128);
      if (value < 0)
        value = 255 + value + 1;
      this[offset] = value & 255;
      return offset + 1;
    };
    Buffer2.prototype.writeInt16LE = function writeInt16LE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value, offset, 2, 32767, -32768);
      this[offset] = value & 255;
      this[offset + 1] = value >>> 8;
      return offset + 2;
    };
    Buffer2.prototype.writeInt16BE = function writeInt16BE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value, offset, 2, 32767, -32768);
      this[offset] = value >>> 8;
      this[offset + 1] = value & 255;
      return offset + 2;
    };
    Buffer2.prototype.writeInt32LE = function writeInt32LE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value, offset, 4, 2147483647, -2147483648);
      this[offset] = value & 255;
      this[offset + 1] = value >>> 8;
      this[offset + 2] = value >>> 16;
      this[offset + 3] = value >>> 24;
      return offset + 4;
    };
    Buffer2.prototype.writeInt32BE = function writeInt32BE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value, offset, 4, 2147483647, -2147483648);
      if (value < 0)
        value = 4294967295 + value + 1;
      this[offset] = value >>> 24;
      this[offset + 1] = value >>> 16;
      this[offset + 2] = value >>> 8;
      this[offset + 3] = value & 255;
      return offset + 4;
    };
    Buffer2.prototype.writeBigInt64LE = defineBigIntMethod(function writeBigInt64LE(value, offset = 0) {
      return wrtBigUInt64LE(this, value, offset, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
    });
    Buffer2.prototype.writeBigInt64BE = defineBigIntMethod(function writeBigInt64BE(value, offset = 0) {
      return wrtBigUInt64BE(this, value, offset, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
    });
    function checkIEEE754(buf, value, offset, ext, max, min) {
      if (offset + ext > buf.length)
        throw new RangeError("Index out of range");
      if (offset < 0)
        throw new RangeError("Index out of range");
    }
    function writeFloat(buf, value, offset, littleEndian, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) {
        checkIEEE754(buf, value, offset, 4, 34028234663852886e22, -34028234663852886e22);
      }
      ieee754.write(buf, value, offset, littleEndian, 23, 4);
      return offset + 4;
    }
    Buffer2.prototype.writeFloatLE = function writeFloatLE(value, offset, noAssert) {
      return writeFloat(this, value, offset, true, noAssert);
    };
    Buffer2.prototype.writeFloatBE = function writeFloatBE(value, offset, noAssert) {
      return writeFloat(this, value, offset, false, noAssert);
    };
    function writeDouble(buf, value, offset, littleEndian, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) {
        checkIEEE754(buf, value, offset, 8, 17976931348623157e292, -17976931348623157e292);
      }
      ieee754.write(buf, value, offset, littleEndian, 52, 8);
      return offset + 8;
    }
    Buffer2.prototype.writeDoubleLE = function writeDoubleLE(value, offset, noAssert) {
      return writeDouble(this, value, offset, true, noAssert);
    };
    Buffer2.prototype.writeDoubleBE = function writeDoubleBE(value, offset, noAssert) {
      return writeDouble(this, value, offset, false, noAssert);
    };
    Buffer2.prototype.copy = function copy(target, targetStart, start, end) {
      if (!Buffer2.isBuffer(target))
        throw new TypeError("argument should be a Buffer");
      if (!start)
        start = 0;
      if (!end && end !== 0)
        end = this.length;
      if (targetStart >= target.length)
        targetStart = target.length;
      if (!targetStart)
        targetStart = 0;
      if (end > 0 && end < start)
        end = start;
      if (end === start)
        return 0;
      if (target.length === 0 || this.length === 0)
        return 0;
      if (targetStart < 0) {
        throw new RangeError("targetStart out of bounds");
      }
      if (start < 0 || start >= this.length)
        throw new RangeError("Index out of range");
      if (end < 0)
        throw new RangeError("sourceEnd out of bounds");
      if (end > this.length)
        end = this.length;
      if (target.length - targetStart < end - start) {
        end = target.length - targetStart + start;
      }
      const len = end - start;
      if (this === target && typeof Uint8Array.prototype.copyWithin === "function") {
        this.copyWithin(targetStart, start, end);
      } else {
        Uint8Array.prototype.set.call(
          target,
          this.subarray(start, end),
          targetStart
        );
      }
      return len;
    };
    Buffer2.prototype.fill = function fill(val, start, end, encoding) {
      if (typeof val === "string") {
        if (typeof start === "string") {
          encoding = start;
          start = 0;
          end = this.length;
        } else if (typeof end === "string") {
          encoding = end;
          end = this.length;
        }
        if (encoding !== void 0 && typeof encoding !== "string") {
          throw new TypeError("encoding must be a string");
        }
        if (typeof encoding === "string" && !Buffer2.isEncoding(encoding)) {
          throw new TypeError("Unknown encoding: " + encoding);
        }
        if (val.length === 1) {
          const code = val.charCodeAt(0);
          if (encoding === "utf8" && code < 128 || encoding === "latin1") {
            val = code;
          }
        }
      } else if (typeof val === "number") {
        val = val & 255;
      } else if (typeof val === "boolean") {
        val = Number(val);
      }
      if (start < 0 || this.length < start || this.length < end) {
        throw new RangeError("Out of range index");
      }
      if (end <= start) {
        return this;
      }
      start = start >>> 0;
      end = end === void 0 ? this.length : end >>> 0;
      if (!val)
        val = 0;
      let i;
      if (typeof val === "number") {
        for (i = start; i < end; ++i) {
          this[i] = val;
        }
      } else {
        const bytes = Buffer2.isBuffer(val) ? val : Buffer2.from(val, encoding);
        const len = bytes.length;
        if (len === 0) {
          throw new TypeError('The value "' + val + '" is invalid for argument "value"');
        }
        for (i = 0; i < end - start; ++i) {
          this[i + start] = bytes[i % len];
        }
      }
      return this;
    };
    var errors = {};
    function E(sym, getMessage, Base) {
      errors[sym] = class NodeError extends Base {
        constructor() {
          super();
          Object.defineProperty(this, "message", {
            value: getMessage.apply(this, arguments),
            writable: true,
            configurable: true
          });
          this.name = `${this.name} [${sym}]`;
          this.stack;
          delete this.name;
        }
        get code() {
          return sym;
        }
        set code(value) {
          Object.defineProperty(this, "code", {
            configurable: true,
            enumerable: true,
            value,
            writable: true
          });
        }
        toString() {
          return `${this.name} [${sym}]: ${this.message}`;
        }
      };
    }
    E(
      "ERR_BUFFER_OUT_OF_BOUNDS",
      function(name) {
        if (name) {
          return `${name} is outside of buffer bounds`;
        }
        return "Attempt to access memory outside buffer bounds";
      },
      RangeError
    );
    E(
      "ERR_INVALID_ARG_TYPE",
      function(name, actual) {
        return `The "${name}" argument must be of type number. Received type ${typeof actual}`;
      },
      TypeError
    );
    E(
      "ERR_OUT_OF_RANGE",
      function(str, range, input) {
        let msg = `The value of "${str}" is out of range.`;
        let received = input;
        if (Number.isInteger(input) && Math.abs(input) > 2 ** 32) {
          received = addNumericalSeparator(String(input));
        } else if (typeof input === "bigint") {
          received = String(input);
          if (input > BigInt(2) ** BigInt(32) || input < -(BigInt(2) ** BigInt(32))) {
            received = addNumericalSeparator(received);
          }
          received += "n";
        }
        msg += ` It must be ${range}. Received ${received}`;
        return msg;
      },
      RangeError
    );
    function addNumericalSeparator(val) {
      let res = "";
      let i = val.length;
      const start = val[0] === "-" ? 1 : 0;
      for (; i >= start + 4; i -= 3) {
        res = `_${val.slice(i - 3, i)}${res}`;
      }
      return `${val.slice(0, i)}${res}`;
    }
    function checkBounds(buf, offset, byteLength2) {
      validateNumber(offset, "offset");
      if (buf[offset] === void 0 || buf[offset + byteLength2] === void 0) {
        boundsError(offset, buf.length - (byteLength2 + 1));
      }
    }
    function checkIntBI(value, min, max, buf, offset, byteLength2) {
      if (value > max || value < min) {
        const n = typeof min === "bigint" ? "n" : "";
        let range;
        if (byteLength2 > 3) {
          if (min === 0 || min === BigInt(0)) {
            range = `>= 0${n} and < 2${n} ** ${(byteLength2 + 1) * 8}${n}`;
          } else {
            range = `>= -(2${n} ** ${(byteLength2 + 1) * 8 - 1}${n}) and < 2 ** ${(byteLength2 + 1) * 8 - 1}${n}`;
          }
        } else {
          range = `>= ${min}${n} and <= ${max}${n}`;
        }
        throw new errors.ERR_OUT_OF_RANGE("value", range, value);
      }
      checkBounds(buf, offset, byteLength2);
    }
    function validateNumber(value, name) {
      if (typeof value !== "number") {
        throw new errors.ERR_INVALID_ARG_TYPE(name, "number", value);
      }
    }
    function boundsError(value, length, type) {
      if (Math.floor(value) !== value) {
        validateNumber(value, type);
        throw new errors.ERR_OUT_OF_RANGE(type || "offset", "an integer", value);
      }
      if (length < 0) {
        throw new errors.ERR_BUFFER_OUT_OF_BOUNDS();
      }
      throw new errors.ERR_OUT_OF_RANGE(
        type || "offset",
        `>= ${type ? 1 : 0} and <= ${length}`,
        value
      );
    }
    var INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g;
    function base64clean(str) {
      str = str.split("=")[0];
      str = str.trim().replace(INVALID_BASE64_RE, "");
      if (str.length < 2)
        return "";
      while (str.length % 4 !== 0) {
        str = str + "=";
      }
      return str;
    }
    function utf8ToBytes(string, units) {
      units = units || Infinity;
      let codePoint;
      const length = string.length;
      let leadSurrogate = null;
      const bytes = [];
      for (let i = 0; i < length; ++i) {
        codePoint = string.charCodeAt(i);
        if (codePoint > 55295 && codePoint < 57344) {
          if (!leadSurrogate) {
            if (codePoint > 56319) {
              if ((units -= 3) > -1)
                bytes.push(239, 191, 189);
              continue;
            } else if (i + 1 === length) {
              if ((units -= 3) > -1)
                bytes.push(239, 191, 189);
              continue;
            }
            leadSurrogate = codePoint;
            continue;
          }
          if (codePoint < 56320) {
            if ((units -= 3) > -1)
              bytes.push(239, 191, 189);
            leadSurrogate = codePoint;
            continue;
          }
          codePoint = (leadSurrogate - 55296 << 10 | codePoint - 56320) + 65536;
        } else if (leadSurrogate) {
          if ((units -= 3) > -1)
            bytes.push(239, 191, 189);
        }
        leadSurrogate = null;
        if (codePoint < 128) {
          if ((units -= 1) < 0)
            break;
          bytes.push(codePoint);
        } else if (codePoint < 2048) {
          if ((units -= 2) < 0)
            break;
          bytes.push(
            codePoint >> 6 | 192,
            codePoint & 63 | 128
          );
        } else if (codePoint < 65536) {
          if ((units -= 3) < 0)
            break;
          bytes.push(
            codePoint >> 12 | 224,
            codePoint >> 6 & 63 | 128,
            codePoint & 63 | 128
          );
        } else if (codePoint < 1114112) {
          if ((units -= 4) < 0)
            break;
          bytes.push(
            codePoint >> 18 | 240,
            codePoint >> 12 & 63 | 128,
            codePoint >> 6 & 63 | 128,
            codePoint & 63 | 128
          );
        } else {
          throw new Error("Invalid code point");
        }
      }
      return bytes;
    }
    function asciiToBytes(str) {
      const byteArray = [];
      for (let i = 0; i < str.length; ++i) {
        byteArray.push(str.charCodeAt(i) & 255);
      }
      return byteArray;
    }
    function utf16leToBytes(str, units) {
      let c, hi, lo;
      const byteArray = [];
      for (let i = 0; i < str.length; ++i) {
        if ((units -= 2) < 0)
          break;
        c = str.charCodeAt(i);
        hi = c >> 8;
        lo = c % 256;
        byteArray.push(lo);
        byteArray.push(hi);
      }
      return byteArray;
    }
    function base64ToBytes(str) {
      return base64.toByteArray(base64clean(str));
    }
    function blitBuffer(src2, dst, offset, length) {
      let i;
      for (i = 0; i < length; ++i) {
        if (i + offset >= dst.length || i >= src2.length)
          break;
        dst[i + offset] = src2[i];
      }
      return i;
    }
    function isInstance(obj, type) {
      return obj instanceof type || obj != null && obj.constructor != null && obj.constructor.name != null && obj.constructor.name === type.name;
    }
    function numberIsNaN(obj) {
      return obj !== obj;
    }
    var hexSliceLookupTable = function() {
      const alphabet = "0123456789abcdef";
      const table = new Array(256);
      for (let i = 0; i < 16; ++i) {
        const i16 = i * 16;
        for (let j = 0; j < 16; ++j) {
          table[i16 + j] = alphabet[i] + alphabet[j];
        }
      }
      return table;
    }();
    function defineBigIntMethod(fn) {
      return typeof BigInt === "undefined" ? BufferBigIntNotDefined : fn;
    }
    function BufferBigIntNotDefined() {
      throw new Error("BigInt not supported");
    }
  }
});

// node_modules/buffer-reverse/index.js
var require_buffer_reverse = __commonJS({
  "node_modules/buffer-reverse/index.js"(exports, module) {
    module.exports = function reverse(src2) {
      var buffer = new Buffer(src2.length);
      for (var i = 0, j = src2.length - 1; i <= j; ++i, --j) {
        buffer[i] = src2[j];
        buffer[j] = src2[i];
      }
      return buffer;
    };
  }
});

// node_modules/crypto-js/core.js
var require_core = __commonJS({
  "node_modules/crypto-js/core.js"(exports, module) {
    (function(root, factory) {
      if (typeof exports === "object") {
        module.exports = exports = factory();
      } else if (typeof define === "function" && define.amd) {
        define([], factory);
      } else {
        root.CryptoJS = factory();
      }
    })(exports, function() {
      var CryptoJS = CryptoJS || function(Math2, undefined2) {
        var create = Object.create || function() {
          function F() {
          }
          ;
          return function(obj) {
            var subtype;
            F.prototype = obj;
            subtype = new F();
            F.prototype = null;
            return subtype;
          };
        }();
        var C = {};
        var C_lib = C.lib = {};
        var Base = C_lib.Base = function() {
          return {
            extend: function(overrides) {
              var subtype = create(this);
              if (overrides) {
                subtype.mixIn(overrides);
              }
              if (!subtype.hasOwnProperty("init") || this.init === subtype.init) {
                subtype.init = function() {
                  subtype.$super.init.apply(this, arguments);
                };
              }
              subtype.init.prototype = subtype;
              subtype.$super = this;
              return subtype;
            },
            create: function() {
              var instance = this.extend();
              instance.init.apply(instance, arguments);
              return instance;
            },
            init: function() {
            },
            mixIn: function(properties) {
              for (var propertyName in properties) {
                if (properties.hasOwnProperty(propertyName)) {
                  this[propertyName] = properties[propertyName];
                }
              }
              if (properties.hasOwnProperty("toString")) {
                this.toString = properties.toString;
              }
            },
            clone: function() {
              return this.init.prototype.extend(this);
            }
          };
        }();
        var WordArray = C_lib.WordArray = Base.extend({
          init: function(words, sigBytes) {
            words = this.words = words || [];
            if (sigBytes != undefined2) {
              this.sigBytes = sigBytes;
            } else {
              this.sigBytes = words.length * 4;
            }
          },
          toString: function(encoder) {
            return (encoder || Hex).stringify(this);
          },
          concat: function(wordArray) {
            var thisWords = this.words;
            var thatWords = wordArray.words;
            var thisSigBytes = this.sigBytes;
            var thatSigBytes = wordArray.sigBytes;
            this.clamp();
            if (thisSigBytes % 4) {
              for (var i = 0; i < thatSigBytes; i++) {
                var thatByte = thatWords[i >>> 2] >>> 24 - i % 4 * 8 & 255;
                thisWords[thisSigBytes + i >>> 2] |= thatByte << 24 - (thisSigBytes + i) % 4 * 8;
              }
            } else {
              for (var i = 0; i < thatSigBytes; i += 4) {
                thisWords[thisSigBytes + i >>> 2] = thatWords[i >>> 2];
              }
            }
            this.sigBytes += thatSigBytes;
            return this;
          },
          clamp: function() {
            var words = this.words;
            var sigBytes = this.sigBytes;
            words[sigBytes >>> 2] &= 4294967295 << 32 - sigBytes % 4 * 8;
            words.length = Math2.ceil(sigBytes / 4);
          },
          clone: function() {
            var clone = Base.clone.call(this);
            clone.words = this.words.slice(0);
            return clone;
          },
          random: function(nBytes) {
            var words = [];
            var r = function(m_w) {
              var m_w = m_w;
              var m_z = 987654321;
              var mask = 4294967295;
              return function() {
                m_z = 36969 * (m_z & 65535) + (m_z >> 16) & mask;
                m_w = 18e3 * (m_w & 65535) + (m_w >> 16) & mask;
                var result = (m_z << 16) + m_w & mask;
                result /= 4294967296;
                result += 0.5;
                return result * (Math2.random() > 0.5 ? 1 : -1);
              };
            };
            for (var i = 0, rcache; i < nBytes; i += 4) {
              var _r = r((rcache || Math2.random()) * 4294967296);
              rcache = _r() * 987654071;
              words.push(_r() * 4294967296 | 0);
            }
            return new WordArray.init(words, nBytes);
          }
        });
        var C_enc = C.enc = {};
        var Hex = C_enc.Hex = {
          stringify: function(wordArray) {
            var words = wordArray.words;
            var sigBytes = wordArray.sigBytes;
            var hexChars = [];
            for (var i = 0; i < sigBytes; i++) {
              var bite = words[i >>> 2] >>> 24 - i % 4 * 8 & 255;
              hexChars.push((bite >>> 4).toString(16));
              hexChars.push((bite & 15).toString(16));
            }
            return hexChars.join("");
          },
          parse: function(hexStr) {
            var hexStrLength = hexStr.length;
            var words = [];
            for (var i = 0; i < hexStrLength; i += 2) {
              words[i >>> 3] |= parseInt(hexStr.substr(i, 2), 16) << 24 - i % 8 * 4;
            }
            return new WordArray.init(words, hexStrLength / 2);
          }
        };
        var Latin1 = C_enc.Latin1 = {
          stringify: function(wordArray) {
            var words = wordArray.words;
            var sigBytes = wordArray.sigBytes;
            var latin1Chars = [];
            for (var i = 0; i < sigBytes; i++) {
              var bite = words[i >>> 2] >>> 24 - i % 4 * 8 & 255;
              latin1Chars.push(String.fromCharCode(bite));
            }
            return latin1Chars.join("");
          },
          parse: function(latin1Str) {
            var latin1StrLength = latin1Str.length;
            var words = [];
            for (var i = 0; i < latin1StrLength; i++) {
              words[i >>> 2] |= (latin1Str.charCodeAt(i) & 255) << 24 - i % 4 * 8;
            }
            return new WordArray.init(words, latin1StrLength);
          }
        };
        var Utf8 = C_enc.Utf8 = {
          stringify: function(wordArray) {
            try {
              return decodeURIComponent(escape(Latin1.stringify(wordArray)));
            } catch (e) {
              throw new Error("Malformed UTF-8 data");
            }
          },
          parse: function(utf8Str) {
            return Latin1.parse(unescape(encodeURIComponent(utf8Str)));
          }
        };
        var BufferedBlockAlgorithm = C_lib.BufferedBlockAlgorithm = Base.extend({
          reset: function() {
            this._data = new WordArray.init();
            this._nDataBytes = 0;
          },
          _append: function(data) {
            if (typeof data == "string") {
              data = Utf8.parse(data);
            }
            this._data.concat(data);
            this._nDataBytes += data.sigBytes;
          },
          _process: function(doFlush) {
            var data = this._data;
            var dataWords = data.words;
            var dataSigBytes = data.sigBytes;
            var blockSize = this.blockSize;
            var blockSizeBytes = blockSize * 4;
            var nBlocksReady = dataSigBytes / blockSizeBytes;
            if (doFlush) {
              nBlocksReady = Math2.ceil(nBlocksReady);
            } else {
              nBlocksReady = Math2.max((nBlocksReady | 0) - this._minBufferSize, 0);
            }
            var nWordsReady = nBlocksReady * blockSize;
            var nBytesReady = Math2.min(nWordsReady * 4, dataSigBytes);
            if (nWordsReady) {
              for (var offset = 0; offset < nWordsReady; offset += blockSize) {
                this._doProcessBlock(dataWords, offset);
              }
              var processedWords = dataWords.splice(0, nWordsReady);
              data.sigBytes -= nBytesReady;
            }
            return new WordArray.init(processedWords, nBytesReady);
          },
          clone: function() {
            var clone = Base.clone.call(this);
            clone._data = this._data.clone();
            return clone;
          },
          _minBufferSize: 0
        });
        var Hasher = C_lib.Hasher = BufferedBlockAlgorithm.extend({
          cfg: Base.extend(),
          init: function(cfg) {
            this.cfg = this.cfg.extend(cfg);
            this.reset();
          },
          reset: function() {
            BufferedBlockAlgorithm.reset.call(this);
            this._doReset();
          },
          update: function(messageUpdate) {
            this._append(messageUpdate);
            this._process();
            return this;
          },
          finalize: function(messageUpdate) {
            if (messageUpdate) {
              this._append(messageUpdate);
            }
            var hash = this._doFinalize();
            return hash;
          },
          blockSize: 512 / 32,
          _createHelper: function(hasher) {
            return function(message, cfg) {
              return new hasher.init(cfg).finalize(message);
            };
          },
          _createHmacHelper: function(hasher) {
            return function(message, key) {
              return new C_algo.HMAC.init(hasher, key).finalize(message);
            };
          }
        });
        var C_algo = C.algo = {};
        return C;
      }(Math);
      return CryptoJS;
    });
  }
});

// node_modules/crypto-js/sha256.js
var require_sha256 = __commonJS({
  "node_modules/crypto-js/sha256.js"(exports, module) {
    (function(root, factory) {
      if (typeof exports === "object") {
        module.exports = exports = factory(require_core());
      } else if (typeof define === "function" && define.amd) {
        define(["./core"], factory);
      } else {
        factory(root.CryptoJS);
      }
    })(exports, function(CryptoJS) {
      (function(Math2) {
        var C = CryptoJS;
        var C_lib = C.lib;
        var WordArray = C_lib.WordArray;
        var Hasher = C_lib.Hasher;
        var C_algo = C.algo;
        var H = [];
        var K = [];
        (function() {
          function isPrime(n2) {
            var sqrtN = Math2.sqrt(n2);
            for (var factor = 2; factor <= sqrtN; factor++) {
              if (!(n2 % factor)) {
                return false;
              }
            }
            return true;
          }
          function getFractionalBits(n2) {
            return (n2 - (n2 | 0)) * 4294967296 | 0;
          }
          var n = 2;
          var nPrime = 0;
          while (nPrime < 64) {
            if (isPrime(n)) {
              if (nPrime < 8) {
                H[nPrime] = getFractionalBits(Math2.pow(n, 1 / 2));
              }
              K[nPrime] = getFractionalBits(Math2.pow(n, 1 / 3));
              nPrime++;
            }
            n++;
          }
        })();
        var W = [];
        var SHA256 = C_algo.SHA256 = Hasher.extend({
          _doReset: function() {
            this._hash = new WordArray.init(H.slice(0));
          },
          _doProcessBlock: function(M, offset) {
            var H2 = this._hash.words;
            var a = H2[0];
            var b = H2[1];
            var c = H2[2];
            var d = H2[3];
            var e = H2[4];
            var f3 = H2[5];
            var g = H2[6];
            var h = H2[7];
            for (var i = 0; i < 64; i++) {
              if (i < 16) {
                W[i] = M[offset + i] | 0;
              } else {
                var gamma0x = W[i - 15];
                var gamma0 = (gamma0x << 25 | gamma0x >>> 7) ^ (gamma0x << 14 | gamma0x >>> 18) ^ gamma0x >>> 3;
                var gamma1x = W[i - 2];
                var gamma1 = (gamma1x << 15 | gamma1x >>> 17) ^ (gamma1x << 13 | gamma1x >>> 19) ^ gamma1x >>> 10;
                W[i] = gamma0 + W[i - 7] + gamma1 + W[i - 16];
              }
              var ch = e & f3 ^ ~e & g;
              var maj = a & b ^ a & c ^ b & c;
              var sigma0 = (a << 30 | a >>> 2) ^ (a << 19 | a >>> 13) ^ (a << 10 | a >>> 22);
              var sigma1 = (e << 26 | e >>> 6) ^ (e << 21 | e >>> 11) ^ (e << 7 | e >>> 25);
              var t1 = h + sigma1 + ch + K[i] + W[i];
              var t2 = sigma0 + maj;
              h = g;
              g = f3;
              f3 = e;
              e = d + t1 | 0;
              d = c;
              c = b;
              b = a;
              a = t1 + t2 | 0;
            }
            H2[0] = H2[0] + a | 0;
            H2[1] = H2[1] + b | 0;
            H2[2] = H2[2] + c | 0;
            H2[3] = H2[3] + d | 0;
            H2[4] = H2[4] + e | 0;
            H2[5] = H2[5] + f3 | 0;
            H2[6] = H2[6] + g | 0;
            H2[7] = H2[7] + h | 0;
          },
          _doFinalize: function() {
            var data = this._data;
            var dataWords = data.words;
            var nBitsTotal = this._nDataBytes * 8;
            var nBitsLeft = data.sigBytes * 8;
            dataWords[nBitsLeft >>> 5] |= 128 << 24 - nBitsLeft % 32;
            dataWords[(nBitsLeft + 64 >>> 9 << 4) + 14] = Math2.floor(nBitsTotal / 4294967296);
            dataWords[(nBitsLeft + 64 >>> 9 << 4) + 15] = nBitsTotal;
            data.sigBytes = dataWords.length * 4;
            this._process();
            return this._hash;
          },
          clone: function() {
            var clone = Hasher.clone.call(this);
            clone._hash = this._hash.clone();
            return clone;
          }
        });
        C.SHA256 = Hasher._createHelper(SHA256);
        C.HmacSHA256 = Hasher._createHmacHelper(SHA256);
      })(Math);
      return CryptoJS.SHA256;
    });
  }
});

// node_modules/treeify/treeify.js
var require_treeify = __commonJS({
  "node_modules/treeify/treeify.js"(exports, module) {
    (function(root, factory) {
      if (typeof exports === "object") {
        module.exports = factory();
      } else if (typeof define === "function" && define.amd) {
        define(factory);
      } else {
        root.treeify = factory();
      }
    })(exports, function() {
      function makePrefix(key, last) {
        var str = last ? "\u2514" : "\u251C";
        if (key) {
          str += "\u2500 ";
        } else {
          str += "\u2500\u2500\u2510";
        }
        return str;
      }
      function filterKeys(obj, hideFunctions) {
        var keys = [];
        for (var branch in obj) {
          if (!obj.hasOwnProperty(branch)) {
            continue;
          }
          if (hideFunctions && typeof obj[branch] === "function") {
            continue;
          }
          keys.push(branch);
        }
        return keys;
      }
      function growBranch(key, root, last, lastStates, showValues, hideFunctions, callback) {
        var line = "", index = 0, lastKey, circular, lastStatesCopy = lastStates.slice(0);
        if (lastStatesCopy.push([root, last]) && lastStates.length > 0) {
          lastStates.forEach(function(lastState, idx) {
            if (idx > 0) {
              line += (lastState[1] ? " " : "\u2502") + "  ";
            }
            if (!circular && lastState[0] === root) {
              circular = true;
            }
          });
          line += makePrefix(key, last) + key;
          showValues && (typeof root !== "object" || root instanceof Date) && (line += ": " + root);
          circular && (line += " (circular ref.)");
          callback(line);
        }
        if (!circular && typeof root === "object") {
          var keys = filterKeys(root, hideFunctions);
          keys.forEach(function(branch) {
            lastKey = ++index === keys.length;
            growBranch(branch, root[branch], lastKey, lastStatesCopy, showValues, hideFunctions, callback);
          });
        }
      }
      ;
      var Treeify = {};
      Treeify.asLines = function(obj, showValues, hideFunctions, lineCallback) {
        var hideFunctionsArg = typeof hideFunctions !== "function" ? hideFunctions : false;
        growBranch(".", obj, false, [], showValues, hideFunctionsArg, lineCallback || hideFunctions);
      };
      Treeify.asTree = function(obj, showValues, hideFunctions) {
        var tree = "";
        growBranch(".", obj, false, [], showValues, hideFunctions, function(line) {
          tree += line + "\n";
        });
        return tree;
      };
      return Treeify;
    });
  }
});

// node_modules/crypto-js/x64-core.js
var require_x64_core = __commonJS({
  "node_modules/crypto-js/x64-core.js"(exports, module) {
    (function(root, factory) {
      if (typeof exports === "object") {
        module.exports = exports = factory(require_core());
      } else if (typeof define === "function" && define.amd) {
        define(["./core"], factory);
      } else {
        factory(root.CryptoJS);
      }
    })(exports, function(CryptoJS) {
      (function(undefined2) {
        var C = CryptoJS;
        var C_lib = C.lib;
        var Base = C_lib.Base;
        var X32WordArray = C_lib.WordArray;
        var C_x64 = C.x64 = {};
        var X64Word = C_x64.Word = Base.extend({
          init: function(high, low) {
            this.high = high;
            this.low = low;
          }
        });
        var X64WordArray = C_x64.WordArray = Base.extend({
          init: function(words, sigBytes) {
            words = this.words = words || [];
            if (sigBytes != undefined2) {
              this.sigBytes = sigBytes;
            } else {
              this.sigBytes = words.length * 8;
            }
          },
          toX32: function() {
            var x64Words = this.words;
            var x64WordsLength = x64Words.length;
            var x32Words = [];
            for (var i = 0; i < x64WordsLength; i++) {
              var x64Word = x64Words[i];
              x32Words.push(x64Word.high);
              x32Words.push(x64Word.low);
            }
            return X32WordArray.create(x32Words, this.sigBytes);
          },
          clone: function() {
            var clone = Base.clone.call(this);
            var words = clone.words = this.words.slice(0);
            var wordsLength = words.length;
            for (var i = 0; i < wordsLength; i++) {
              words[i] = words[i].clone();
            }
            return clone;
          }
        });
      })();
      return CryptoJS;
    });
  }
});

// node_modules/crypto-js/lib-typedarrays.js
var require_lib_typedarrays = __commonJS({
  "node_modules/crypto-js/lib-typedarrays.js"(exports, module) {
    (function(root, factory) {
      if (typeof exports === "object") {
        module.exports = exports = factory(require_core());
      } else if (typeof define === "function" && define.amd) {
        define(["./core"], factory);
      } else {
        factory(root.CryptoJS);
      }
    })(exports, function(CryptoJS) {
      (function() {
        if (typeof ArrayBuffer != "function") {
          return;
        }
        var C = CryptoJS;
        var C_lib = C.lib;
        var WordArray = C_lib.WordArray;
        var superInit = WordArray.init;
        var subInit = WordArray.init = function(typedArray) {
          if (typedArray instanceof ArrayBuffer) {
            typedArray = new Uint8Array(typedArray);
          }
          if (typedArray instanceof Int8Array || typeof Uint8ClampedArray !== "undefined" && typedArray instanceof Uint8ClampedArray || typedArray instanceof Int16Array || typedArray instanceof Uint16Array || typedArray instanceof Int32Array || typedArray instanceof Uint32Array || typedArray instanceof Float32Array || typedArray instanceof Float64Array) {
            typedArray = new Uint8Array(typedArray.buffer, typedArray.byteOffset, typedArray.byteLength);
          }
          if (typedArray instanceof Uint8Array) {
            var typedArrayByteLength = typedArray.byteLength;
            var words = [];
            for (var i = 0; i < typedArrayByteLength; i++) {
              words[i >>> 2] |= typedArray[i] << 24 - i % 4 * 8;
            }
            superInit.call(this, words, typedArrayByteLength);
          } else {
            superInit.apply(this, arguments);
          }
        };
        subInit.prototype = WordArray;
      })();
      return CryptoJS.lib.WordArray;
    });
  }
});

// node_modules/crypto-js/enc-utf16.js
var require_enc_utf16 = __commonJS({
  "node_modules/crypto-js/enc-utf16.js"(exports, module) {
    (function(root, factory) {
      if (typeof exports === "object") {
        module.exports = exports = factory(require_core());
      } else if (typeof define === "function" && define.amd) {
        define(["./core"], factory);
      } else {
        factory(root.CryptoJS);
      }
    })(exports, function(CryptoJS) {
      (function() {
        var C = CryptoJS;
        var C_lib = C.lib;
        var WordArray = C_lib.WordArray;
        var C_enc = C.enc;
        var Utf16BE = C_enc.Utf16 = C_enc.Utf16BE = {
          stringify: function(wordArray) {
            var words = wordArray.words;
            var sigBytes = wordArray.sigBytes;
            var utf16Chars = [];
            for (var i = 0; i < sigBytes; i += 2) {
              var codePoint = words[i >>> 2] >>> 16 - i % 4 * 8 & 65535;
              utf16Chars.push(String.fromCharCode(codePoint));
            }
            return utf16Chars.join("");
          },
          parse: function(utf16Str) {
            var utf16StrLength = utf16Str.length;
            var words = [];
            for (var i = 0; i < utf16StrLength; i++) {
              words[i >>> 1] |= utf16Str.charCodeAt(i) << 16 - i % 2 * 16;
            }
            return WordArray.create(words, utf16StrLength * 2);
          }
        };
        C_enc.Utf16LE = {
          stringify: function(wordArray) {
            var words = wordArray.words;
            var sigBytes = wordArray.sigBytes;
            var utf16Chars = [];
            for (var i = 0; i < sigBytes; i += 2) {
              var codePoint = swapEndian(words[i >>> 2] >>> 16 - i % 4 * 8 & 65535);
              utf16Chars.push(String.fromCharCode(codePoint));
            }
            return utf16Chars.join("");
          },
          parse: function(utf16Str) {
            var utf16StrLength = utf16Str.length;
            var words = [];
            for (var i = 0; i < utf16StrLength; i++) {
              words[i >>> 1] |= swapEndian(utf16Str.charCodeAt(i) << 16 - i % 2 * 16);
            }
            return WordArray.create(words, utf16StrLength * 2);
          }
        };
        function swapEndian(word) {
          return word << 8 & 4278255360 | word >>> 8 & 16711935;
        }
      })();
      return CryptoJS.enc.Utf16;
    });
  }
});

// node_modules/crypto-js/enc-base64.js
var require_enc_base64 = __commonJS({
  "node_modules/crypto-js/enc-base64.js"(exports, module) {
    (function(root, factory) {
      if (typeof exports === "object") {
        module.exports = exports = factory(require_core());
      } else if (typeof define === "function" && define.amd) {
        define(["./core"], factory);
      } else {
        factory(root.CryptoJS);
      }
    })(exports, function(CryptoJS) {
      (function() {
        var C = CryptoJS;
        var C_lib = C.lib;
        var WordArray = C_lib.WordArray;
        var C_enc = C.enc;
        var Base64 = C_enc.Base64 = {
          stringify: function(wordArray) {
            var words = wordArray.words;
            var sigBytes = wordArray.sigBytes;
            var map = this._map;
            wordArray.clamp();
            var base64Chars = [];
            for (var i = 0; i < sigBytes; i += 3) {
              var byte1 = words[i >>> 2] >>> 24 - i % 4 * 8 & 255;
              var byte2 = words[i + 1 >>> 2] >>> 24 - (i + 1) % 4 * 8 & 255;
              var byte3 = words[i + 2 >>> 2] >>> 24 - (i + 2) % 4 * 8 & 255;
              var triplet = byte1 << 16 | byte2 << 8 | byte3;
              for (var j = 0; j < 4 && i + j * 0.75 < sigBytes; j++) {
                base64Chars.push(map.charAt(triplet >>> 6 * (3 - j) & 63));
              }
            }
            var paddingChar = map.charAt(64);
            if (paddingChar) {
              while (base64Chars.length % 4) {
                base64Chars.push(paddingChar);
              }
            }
            return base64Chars.join("");
          },
          parse: function(base64Str) {
            var base64StrLength = base64Str.length;
            var map = this._map;
            var reverseMap = this._reverseMap;
            if (!reverseMap) {
              reverseMap = this._reverseMap = [];
              for (var j = 0; j < map.length; j++) {
                reverseMap[map.charCodeAt(j)] = j;
              }
            }
            var paddingChar = map.charAt(64);
            if (paddingChar) {
              var paddingIndex = base64Str.indexOf(paddingChar);
              if (paddingIndex !== -1) {
                base64StrLength = paddingIndex;
              }
            }
            return parseLoop(base64Str, base64StrLength, reverseMap);
          },
          _map: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/="
        };
        function parseLoop(base64Str, base64StrLength, reverseMap) {
          var words = [];
          var nBytes = 0;
          for (var i = 0; i < base64StrLength; i++) {
            if (i % 4) {
              var bits1 = reverseMap[base64Str.charCodeAt(i - 1)] << i % 4 * 2;
              var bits2 = reverseMap[base64Str.charCodeAt(i)] >>> 6 - i % 4 * 2;
              words[nBytes >>> 2] |= (bits1 | bits2) << 24 - nBytes % 4 * 8;
              nBytes++;
            }
          }
          return WordArray.create(words, nBytes);
        }
      })();
      return CryptoJS.enc.Base64;
    });
  }
});

// node_modules/crypto-js/md5.js
var require_md5 = __commonJS({
  "node_modules/crypto-js/md5.js"(exports, module) {
    (function(root, factory) {
      if (typeof exports === "object") {
        module.exports = exports = factory(require_core());
      } else if (typeof define === "function" && define.amd) {
        define(["./core"], factory);
      } else {
        factory(root.CryptoJS);
      }
    })(exports, function(CryptoJS) {
      (function(Math2) {
        var C = CryptoJS;
        var C_lib = C.lib;
        var WordArray = C_lib.WordArray;
        var Hasher = C_lib.Hasher;
        var C_algo = C.algo;
        var T = [];
        (function() {
          for (var i = 0; i < 64; i++) {
            T[i] = Math2.abs(Math2.sin(i + 1)) * 4294967296 | 0;
          }
        })();
        var MD5 = C_algo.MD5 = Hasher.extend({
          _doReset: function() {
            this._hash = new WordArray.init([
              1732584193,
              4023233417,
              2562383102,
              271733878
            ]);
          },
          _doProcessBlock: function(M, offset) {
            for (var i = 0; i < 16; i++) {
              var offset_i = offset + i;
              var M_offset_i = M[offset_i];
              M[offset_i] = (M_offset_i << 8 | M_offset_i >>> 24) & 16711935 | (M_offset_i << 24 | M_offset_i >>> 8) & 4278255360;
            }
            var H = this._hash.words;
            var M_offset_0 = M[offset + 0];
            var M_offset_1 = M[offset + 1];
            var M_offset_2 = M[offset + 2];
            var M_offset_3 = M[offset + 3];
            var M_offset_4 = M[offset + 4];
            var M_offset_5 = M[offset + 5];
            var M_offset_6 = M[offset + 6];
            var M_offset_7 = M[offset + 7];
            var M_offset_8 = M[offset + 8];
            var M_offset_9 = M[offset + 9];
            var M_offset_10 = M[offset + 10];
            var M_offset_11 = M[offset + 11];
            var M_offset_12 = M[offset + 12];
            var M_offset_13 = M[offset + 13];
            var M_offset_14 = M[offset + 14];
            var M_offset_15 = M[offset + 15];
            var a = H[0];
            var b = H[1];
            var c = H[2];
            var d = H[3];
            a = FF(a, b, c, d, M_offset_0, 7, T[0]);
            d = FF(d, a, b, c, M_offset_1, 12, T[1]);
            c = FF(c, d, a, b, M_offset_2, 17, T[2]);
            b = FF(b, c, d, a, M_offset_3, 22, T[3]);
            a = FF(a, b, c, d, M_offset_4, 7, T[4]);
            d = FF(d, a, b, c, M_offset_5, 12, T[5]);
            c = FF(c, d, a, b, M_offset_6, 17, T[6]);
            b = FF(b, c, d, a, M_offset_7, 22, T[7]);
            a = FF(a, b, c, d, M_offset_8, 7, T[8]);
            d = FF(d, a, b, c, M_offset_9, 12, T[9]);
            c = FF(c, d, a, b, M_offset_10, 17, T[10]);
            b = FF(b, c, d, a, M_offset_11, 22, T[11]);
            a = FF(a, b, c, d, M_offset_12, 7, T[12]);
            d = FF(d, a, b, c, M_offset_13, 12, T[13]);
            c = FF(c, d, a, b, M_offset_14, 17, T[14]);
            b = FF(b, c, d, a, M_offset_15, 22, T[15]);
            a = GG(a, b, c, d, M_offset_1, 5, T[16]);
            d = GG(d, a, b, c, M_offset_6, 9, T[17]);
            c = GG(c, d, a, b, M_offset_11, 14, T[18]);
            b = GG(b, c, d, a, M_offset_0, 20, T[19]);
            a = GG(a, b, c, d, M_offset_5, 5, T[20]);
            d = GG(d, a, b, c, M_offset_10, 9, T[21]);
            c = GG(c, d, a, b, M_offset_15, 14, T[22]);
            b = GG(b, c, d, a, M_offset_4, 20, T[23]);
            a = GG(a, b, c, d, M_offset_9, 5, T[24]);
            d = GG(d, a, b, c, M_offset_14, 9, T[25]);
            c = GG(c, d, a, b, M_offset_3, 14, T[26]);
            b = GG(b, c, d, a, M_offset_8, 20, T[27]);
            a = GG(a, b, c, d, M_offset_13, 5, T[28]);
            d = GG(d, a, b, c, M_offset_2, 9, T[29]);
            c = GG(c, d, a, b, M_offset_7, 14, T[30]);
            b = GG(b, c, d, a, M_offset_12, 20, T[31]);
            a = HH(a, b, c, d, M_offset_5, 4, T[32]);
            d = HH(d, a, b, c, M_offset_8, 11, T[33]);
            c = HH(c, d, a, b, M_offset_11, 16, T[34]);
            b = HH(b, c, d, a, M_offset_14, 23, T[35]);
            a = HH(a, b, c, d, M_offset_1, 4, T[36]);
            d = HH(d, a, b, c, M_offset_4, 11, T[37]);
            c = HH(c, d, a, b, M_offset_7, 16, T[38]);
            b = HH(b, c, d, a, M_offset_10, 23, T[39]);
            a = HH(a, b, c, d, M_offset_13, 4, T[40]);
            d = HH(d, a, b, c, M_offset_0, 11, T[41]);
            c = HH(c, d, a, b, M_offset_3, 16, T[42]);
            b = HH(b, c, d, a, M_offset_6, 23, T[43]);
            a = HH(a, b, c, d, M_offset_9, 4, T[44]);
            d = HH(d, a, b, c, M_offset_12, 11, T[45]);
            c = HH(c, d, a, b, M_offset_15, 16, T[46]);
            b = HH(b, c, d, a, M_offset_2, 23, T[47]);
            a = II(a, b, c, d, M_offset_0, 6, T[48]);
            d = II(d, a, b, c, M_offset_7, 10, T[49]);
            c = II(c, d, a, b, M_offset_14, 15, T[50]);
            b = II(b, c, d, a, M_offset_5, 21, T[51]);
            a = II(a, b, c, d, M_offset_12, 6, T[52]);
            d = II(d, a, b, c, M_offset_3, 10, T[53]);
            c = II(c, d, a, b, M_offset_10, 15, T[54]);
            b = II(b, c, d, a, M_offset_1, 21, T[55]);
            a = II(a, b, c, d, M_offset_8, 6, T[56]);
            d = II(d, a, b, c, M_offset_15, 10, T[57]);
            c = II(c, d, a, b, M_offset_6, 15, T[58]);
            b = II(b, c, d, a, M_offset_13, 21, T[59]);
            a = II(a, b, c, d, M_offset_4, 6, T[60]);
            d = II(d, a, b, c, M_offset_11, 10, T[61]);
            c = II(c, d, a, b, M_offset_2, 15, T[62]);
            b = II(b, c, d, a, M_offset_9, 21, T[63]);
            H[0] = H[0] + a | 0;
            H[1] = H[1] + b | 0;
            H[2] = H[2] + c | 0;
            H[3] = H[3] + d | 0;
          },
          _doFinalize: function() {
            var data = this._data;
            var dataWords = data.words;
            var nBitsTotal = this._nDataBytes * 8;
            var nBitsLeft = data.sigBytes * 8;
            dataWords[nBitsLeft >>> 5] |= 128 << 24 - nBitsLeft % 32;
            var nBitsTotalH = Math2.floor(nBitsTotal / 4294967296);
            var nBitsTotalL = nBitsTotal;
            dataWords[(nBitsLeft + 64 >>> 9 << 4) + 15] = (nBitsTotalH << 8 | nBitsTotalH >>> 24) & 16711935 | (nBitsTotalH << 24 | nBitsTotalH >>> 8) & 4278255360;
            dataWords[(nBitsLeft + 64 >>> 9 << 4) + 14] = (nBitsTotalL << 8 | nBitsTotalL >>> 24) & 16711935 | (nBitsTotalL << 24 | nBitsTotalL >>> 8) & 4278255360;
            data.sigBytes = (dataWords.length + 1) * 4;
            this._process();
            var hash = this._hash;
            var H = hash.words;
            for (var i = 0; i < 4; i++) {
              var H_i = H[i];
              H[i] = (H_i << 8 | H_i >>> 24) & 16711935 | (H_i << 24 | H_i >>> 8) & 4278255360;
            }
            return hash;
          },
          clone: function() {
            var clone = Hasher.clone.call(this);
            clone._hash = this._hash.clone();
            return clone;
          }
        });
        function FF(a, b, c, d, x, s, t) {
          var n = a + (b & c | ~b & d) + x + t;
          return (n << s | n >>> 32 - s) + b;
        }
        function GG(a, b, c, d, x, s, t) {
          var n = a + (b & d | c & ~d) + x + t;
          return (n << s | n >>> 32 - s) + b;
        }
        function HH(a, b, c, d, x, s, t) {
          var n = a + (b ^ c ^ d) + x + t;
          return (n << s | n >>> 32 - s) + b;
        }
        function II(a, b, c, d, x, s, t) {
          var n = a + (c ^ (b | ~d)) + x + t;
          return (n << s | n >>> 32 - s) + b;
        }
        C.MD5 = Hasher._createHelper(MD5);
        C.HmacMD5 = Hasher._createHmacHelper(MD5);
      })(Math);
      return CryptoJS.MD5;
    });
  }
});

// node_modules/crypto-js/sha1.js
var require_sha1 = __commonJS({
  "node_modules/crypto-js/sha1.js"(exports, module) {
    (function(root, factory) {
      if (typeof exports === "object") {
        module.exports = exports = factory(require_core());
      } else if (typeof define === "function" && define.amd) {
        define(["./core"], factory);
      } else {
        factory(root.CryptoJS);
      }
    })(exports, function(CryptoJS) {
      (function() {
        var C = CryptoJS;
        var C_lib = C.lib;
        var WordArray = C_lib.WordArray;
        var Hasher = C_lib.Hasher;
        var C_algo = C.algo;
        var W = [];
        var SHA1 = C_algo.SHA1 = Hasher.extend({
          _doReset: function() {
            this._hash = new WordArray.init([
              1732584193,
              4023233417,
              2562383102,
              271733878,
              3285377520
            ]);
          },
          _doProcessBlock: function(M, offset) {
            var H = this._hash.words;
            var a = H[0];
            var b = H[1];
            var c = H[2];
            var d = H[3];
            var e = H[4];
            for (var i = 0; i < 80; i++) {
              if (i < 16) {
                W[i] = M[offset + i] | 0;
              } else {
                var n = W[i - 3] ^ W[i - 8] ^ W[i - 14] ^ W[i - 16];
                W[i] = n << 1 | n >>> 31;
              }
              var t = (a << 5 | a >>> 27) + e + W[i];
              if (i < 20) {
                t += (b & c | ~b & d) + 1518500249;
              } else if (i < 40) {
                t += (b ^ c ^ d) + 1859775393;
              } else if (i < 60) {
                t += (b & c | b & d | c & d) - 1894007588;
              } else {
                t += (b ^ c ^ d) - 899497514;
              }
              e = d;
              d = c;
              c = b << 30 | b >>> 2;
              b = a;
              a = t;
            }
            H[0] = H[0] + a | 0;
            H[1] = H[1] + b | 0;
            H[2] = H[2] + c | 0;
            H[3] = H[3] + d | 0;
            H[4] = H[4] + e | 0;
          },
          _doFinalize: function() {
            var data = this._data;
            var dataWords = data.words;
            var nBitsTotal = this._nDataBytes * 8;
            var nBitsLeft = data.sigBytes * 8;
            dataWords[nBitsLeft >>> 5] |= 128 << 24 - nBitsLeft % 32;
            dataWords[(nBitsLeft + 64 >>> 9 << 4) + 14] = Math.floor(nBitsTotal / 4294967296);
            dataWords[(nBitsLeft + 64 >>> 9 << 4) + 15] = nBitsTotal;
            data.sigBytes = dataWords.length * 4;
            this._process();
            return this._hash;
          },
          clone: function() {
            var clone = Hasher.clone.call(this);
            clone._hash = this._hash.clone();
            return clone;
          }
        });
        C.SHA1 = Hasher._createHelper(SHA1);
        C.HmacSHA1 = Hasher._createHmacHelper(SHA1);
      })();
      return CryptoJS.SHA1;
    });
  }
});

// node_modules/crypto-js/sha224.js
var require_sha224 = __commonJS({
  "node_modules/crypto-js/sha224.js"(exports, module) {
    (function(root, factory, undef) {
      if (typeof exports === "object") {
        module.exports = exports = factory(require_core(), require_sha256());
      } else if (typeof define === "function" && define.amd) {
        define(["./core", "./sha256"], factory);
      } else {
        factory(root.CryptoJS);
      }
    })(exports, function(CryptoJS) {
      (function() {
        var C = CryptoJS;
        var C_lib = C.lib;
        var WordArray = C_lib.WordArray;
        var C_algo = C.algo;
        var SHA256 = C_algo.SHA256;
        var SHA224 = C_algo.SHA224 = SHA256.extend({
          _doReset: function() {
            this._hash = new WordArray.init([
              3238371032,
              914150663,
              812702999,
              4144912697,
              4290775857,
              1750603025,
              1694076839,
              3204075428
            ]);
          },
          _doFinalize: function() {
            var hash = SHA256._doFinalize.call(this);
            hash.sigBytes -= 4;
            return hash;
          }
        });
        C.SHA224 = SHA256._createHelper(SHA224);
        C.HmacSHA224 = SHA256._createHmacHelper(SHA224);
      })();
      return CryptoJS.SHA224;
    });
  }
});

// node_modules/crypto-js/sha512.js
var require_sha512 = __commonJS({
  "node_modules/crypto-js/sha512.js"(exports, module) {
    (function(root, factory, undef) {
      if (typeof exports === "object") {
        module.exports = exports = factory(require_core(), require_x64_core());
      } else if (typeof define === "function" && define.amd) {
        define(["./core", "./x64-core"], factory);
      } else {
        factory(root.CryptoJS);
      }
    })(exports, function(CryptoJS) {
      (function() {
        var C = CryptoJS;
        var C_lib = C.lib;
        var Hasher = C_lib.Hasher;
        var C_x64 = C.x64;
        var X64Word = C_x64.Word;
        var X64WordArray = C_x64.WordArray;
        var C_algo = C.algo;
        function X64Word_create() {
          return X64Word.create.apply(X64Word, arguments);
        }
        var K = [
          X64Word_create(1116352408, 3609767458),
          X64Word_create(1899447441, 602891725),
          X64Word_create(3049323471, 3964484399),
          X64Word_create(3921009573, 2173295548),
          X64Word_create(961987163, 4081628472),
          X64Word_create(1508970993, 3053834265),
          X64Word_create(2453635748, 2937671579),
          X64Word_create(2870763221, 3664609560),
          X64Word_create(3624381080, 2734883394),
          X64Word_create(310598401, 1164996542),
          X64Word_create(607225278, 1323610764),
          X64Word_create(1426881987, 3590304994),
          X64Word_create(1925078388, 4068182383),
          X64Word_create(2162078206, 991336113),
          X64Word_create(2614888103, 633803317),
          X64Word_create(3248222580, 3479774868),
          X64Word_create(3835390401, 2666613458),
          X64Word_create(4022224774, 944711139),
          X64Word_create(264347078, 2341262773),
          X64Word_create(604807628, 2007800933),
          X64Word_create(770255983, 1495990901),
          X64Word_create(1249150122, 1856431235),
          X64Word_create(1555081692, 3175218132),
          X64Word_create(1996064986, 2198950837),
          X64Word_create(2554220882, 3999719339),
          X64Word_create(2821834349, 766784016),
          X64Word_create(2952996808, 2566594879),
          X64Word_create(3210313671, 3203337956),
          X64Word_create(3336571891, 1034457026),
          X64Word_create(3584528711, 2466948901),
          X64Word_create(113926993, 3758326383),
          X64Word_create(338241895, 168717936),
          X64Word_create(666307205, 1188179964),
          X64Word_create(773529912, 1546045734),
          X64Word_create(1294757372, 1522805485),
          X64Word_create(1396182291, 2643833823),
          X64Word_create(1695183700, 2343527390),
          X64Word_create(1986661051, 1014477480),
          X64Word_create(2177026350, 1206759142),
          X64Word_create(2456956037, 344077627),
          X64Word_create(2730485921, 1290863460),
          X64Word_create(2820302411, 3158454273),
          X64Word_create(3259730800, 3505952657),
          X64Word_create(3345764771, 106217008),
          X64Word_create(3516065817, 3606008344),
          X64Word_create(3600352804, 1432725776),
          X64Word_create(4094571909, 1467031594),
          X64Word_create(275423344, 851169720),
          X64Word_create(430227734, 3100823752),
          X64Word_create(506948616, 1363258195),
          X64Word_create(659060556, 3750685593),
          X64Word_create(883997877, 3785050280),
          X64Word_create(958139571, 3318307427),
          X64Word_create(1322822218, 3812723403),
          X64Word_create(1537002063, 2003034995),
          X64Word_create(1747873779, 3602036899),
          X64Word_create(1955562222, 1575990012),
          X64Word_create(2024104815, 1125592928),
          X64Word_create(2227730452, 2716904306),
          X64Word_create(2361852424, 442776044),
          X64Word_create(2428436474, 593698344),
          X64Word_create(2756734187, 3733110249),
          X64Word_create(3204031479, 2999351573),
          X64Word_create(3329325298, 3815920427),
          X64Word_create(3391569614, 3928383900),
          X64Word_create(3515267271, 566280711),
          X64Word_create(3940187606, 3454069534),
          X64Word_create(4118630271, 4000239992),
          X64Word_create(116418474, 1914138554),
          X64Word_create(174292421, 2731055270),
          X64Word_create(289380356, 3203993006),
          X64Word_create(460393269, 320620315),
          X64Word_create(685471733, 587496836),
          X64Word_create(852142971, 1086792851),
          X64Word_create(1017036298, 365543100),
          X64Word_create(1126000580, 2618297676),
          X64Word_create(1288033470, 3409855158),
          X64Word_create(1501505948, 4234509866),
          X64Word_create(1607167915, 987167468),
          X64Word_create(1816402316, 1246189591)
        ];
        var W = [];
        (function() {
          for (var i = 0; i < 80; i++) {
            W[i] = X64Word_create();
          }
        })();
        var SHA512 = C_algo.SHA512 = Hasher.extend({
          _doReset: function() {
            this._hash = new X64WordArray.init([
              new X64Word.init(1779033703, 4089235720),
              new X64Word.init(3144134277, 2227873595),
              new X64Word.init(1013904242, 4271175723),
              new X64Word.init(2773480762, 1595750129),
              new X64Word.init(1359893119, 2917565137),
              new X64Word.init(2600822924, 725511199),
              new X64Word.init(528734635, 4215389547),
              new X64Word.init(1541459225, 327033209)
            ]);
          },
          _doProcessBlock: function(M, offset) {
            var H = this._hash.words;
            var H0 = H[0];
            var H1 = H[1];
            var H2 = H[2];
            var H3 = H[3];
            var H4 = H[4];
            var H5 = H[5];
            var H6 = H[6];
            var H7 = H[7];
            var H0h = H0.high;
            var H0l = H0.low;
            var H1h = H1.high;
            var H1l = H1.low;
            var H2h = H2.high;
            var H2l = H2.low;
            var H3h = H3.high;
            var H3l = H3.low;
            var H4h = H4.high;
            var H4l = H4.low;
            var H5h = H5.high;
            var H5l = H5.low;
            var H6h = H6.high;
            var H6l = H6.low;
            var H7h = H7.high;
            var H7l = H7.low;
            var ah = H0h;
            var al = H0l;
            var bh = H1h;
            var bl = H1l;
            var ch = H2h;
            var cl = H2l;
            var dh = H3h;
            var dl = H3l;
            var eh = H4h;
            var el = H4l;
            var fh = H5h;
            var fl = H5l;
            var gh = H6h;
            var gl = H6l;
            var hh = H7h;
            var hl = H7l;
            for (var i = 0; i < 80; i++) {
              var Wi = W[i];
              if (i < 16) {
                var Wih = Wi.high = M[offset + i * 2] | 0;
                var Wil = Wi.low = M[offset + i * 2 + 1] | 0;
              } else {
                var gamma0x = W[i - 15];
                var gamma0xh = gamma0x.high;
                var gamma0xl = gamma0x.low;
                var gamma0h = (gamma0xh >>> 1 | gamma0xl << 31) ^ (gamma0xh >>> 8 | gamma0xl << 24) ^ gamma0xh >>> 7;
                var gamma0l = (gamma0xl >>> 1 | gamma0xh << 31) ^ (gamma0xl >>> 8 | gamma0xh << 24) ^ (gamma0xl >>> 7 | gamma0xh << 25);
                var gamma1x = W[i - 2];
                var gamma1xh = gamma1x.high;
                var gamma1xl = gamma1x.low;
                var gamma1h = (gamma1xh >>> 19 | gamma1xl << 13) ^ (gamma1xh << 3 | gamma1xl >>> 29) ^ gamma1xh >>> 6;
                var gamma1l = (gamma1xl >>> 19 | gamma1xh << 13) ^ (gamma1xl << 3 | gamma1xh >>> 29) ^ (gamma1xl >>> 6 | gamma1xh << 26);
                var Wi7 = W[i - 7];
                var Wi7h = Wi7.high;
                var Wi7l = Wi7.low;
                var Wi16 = W[i - 16];
                var Wi16h = Wi16.high;
                var Wi16l = Wi16.low;
                var Wil = gamma0l + Wi7l;
                var Wih = gamma0h + Wi7h + (Wil >>> 0 < gamma0l >>> 0 ? 1 : 0);
                var Wil = Wil + gamma1l;
                var Wih = Wih + gamma1h + (Wil >>> 0 < gamma1l >>> 0 ? 1 : 0);
                var Wil = Wil + Wi16l;
                var Wih = Wih + Wi16h + (Wil >>> 0 < Wi16l >>> 0 ? 1 : 0);
                Wi.high = Wih;
                Wi.low = Wil;
              }
              var chh = eh & fh ^ ~eh & gh;
              var chl = el & fl ^ ~el & gl;
              var majh = ah & bh ^ ah & ch ^ bh & ch;
              var majl = al & bl ^ al & cl ^ bl & cl;
              var sigma0h = (ah >>> 28 | al << 4) ^ (ah << 30 | al >>> 2) ^ (ah << 25 | al >>> 7);
              var sigma0l = (al >>> 28 | ah << 4) ^ (al << 30 | ah >>> 2) ^ (al << 25 | ah >>> 7);
              var sigma1h = (eh >>> 14 | el << 18) ^ (eh >>> 18 | el << 14) ^ (eh << 23 | el >>> 9);
              var sigma1l = (el >>> 14 | eh << 18) ^ (el >>> 18 | eh << 14) ^ (el << 23 | eh >>> 9);
              var Ki = K[i];
              var Kih = Ki.high;
              var Kil = Ki.low;
              var t1l = hl + sigma1l;
              var t1h = hh + sigma1h + (t1l >>> 0 < hl >>> 0 ? 1 : 0);
              var t1l = t1l + chl;
              var t1h = t1h + chh + (t1l >>> 0 < chl >>> 0 ? 1 : 0);
              var t1l = t1l + Kil;
              var t1h = t1h + Kih + (t1l >>> 0 < Kil >>> 0 ? 1 : 0);
              var t1l = t1l + Wil;
              var t1h = t1h + Wih + (t1l >>> 0 < Wil >>> 0 ? 1 : 0);
              var t2l = sigma0l + majl;
              var t2h = sigma0h + majh + (t2l >>> 0 < sigma0l >>> 0 ? 1 : 0);
              hh = gh;
              hl = gl;
              gh = fh;
              gl = fl;
              fh = eh;
              fl = el;
              el = dl + t1l | 0;
              eh = dh + t1h + (el >>> 0 < dl >>> 0 ? 1 : 0) | 0;
              dh = ch;
              dl = cl;
              ch = bh;
              cl = bl;
              bh = ah;
              bl = al;
              al = t1l + t2l | 0;
              ah = t1h + t2h + (al >>> 0 < t1l >>> 0 ? 1 : 0) | 0;
            }
            H0l = H0.low = H0l + al;
            H0.high = H0h + ah + (H0l >>> 0 < al >>> 0 ? 1 : 0);
            H1l = H1.low = H1l + bl;
            H1.high = H1h + bh + (H1l >>> 0 < bl >>> 0 ? 1 : 0);
            H2l = H2.low = H2l + cl;
            H2.high = H2h + ch + (H2l >>> 0 < cl >>> 0 ? 1 : 0);
            H3l = H3.low = H3l + dl;
            H3.high = H3h + dh + (H3l >>> 0 < dl >>> 0 ? 1 : 0);
            H4l = H4.low = H4l + el;
            H4.high = H4h + eh + (H4l >>> 0 < el >>> 0 ? 1 : 0);
            H5l = H5.low = H5l + fl;
            H5.high = H5h + fh + (H5l >>> 0 < fl >>> 0 ? 1 : 0);
            H6l = H6.low = H6l + gl;
            H6.high = H6h + gh + (H6l >>> 0 < gl >>> 0 ? 1 : 0);
            H7l = H7.low = H7l + hl;
            H7.high = H7h + hh + (H7l >>> 0 < hl >>> 0 ? 1 : 0);
          },
          _doFinalize: function() {
            var data = this._data;
            var dataWords = data.words;
            var nBitsTotal = this._nDataBytes * 8;
            var nBitsLeft = data.sigBytes * 8;
            dataWords[nBitsLeft >>> 5] |= 128 << 24 - nBitsLeft % 32;
            dataWords[(nBitsLeft + 128 >>> 10 << 5) + 30] = Math.floor(nBitsTotal / 4294967296);
            dataWords[(nBitsLeft + 128 >>> 10 << 5) + 31] = nBitsTotal;
            data.sigBytes = dataWords.length * 4;
            this._process();
            var hash = this._hash.toX32();
            return hash;
          },
          clone: function() {
            var clone = Hasher.clone.call(this);
            clone._hash = this._hash.clone();
            return clone;
          },
          blockSize: 1024 / 32
        });
        C.SHA512 = Hasher._createHelper(SHA512);
        C.HmacSHA512 = Hasher._createHmacHelper(SHA512);
      })();
      return CryptoJS.SHA512;
    });
  }
});

// node_modules/crypto-js/sha384.js
var require_sha384 = __commonJS({
  "node_modules/crypto-js/sha384.js"(exports, module) {
    (function(root, factory, undef) {
      if (typeof exports === "object") {
        module.exports = exports = factory(require_core(), require_x64_core(), require_sha512());
      } else if (typeof define === "function" && define.amd) {
        define(["./core", "./x64-core", "./sha512"], factory);
      } else {
        factory(root.CryptoJS);
      }
    })(exports, function(CryptoJS) {
      (function() {
        var C = CryptoJS;
        var C_x64 = C.x64;
        var X64Word = C_x64.Word;
        var X64WordArray = C_x64.WordArray;
        var C_algo = C.algo;
        var SHA512 = C_algo.SHA512;
        var SHA384 = C_algo.SHA384 = SHA512.extend({
          _doReset: function() {
            this._hash = new X64WordArray.init([
              new X64Word.init(3418070365, 3238371032),
              new X64Word.init(1654270250, 914150663),
              new X64Word.init(2438529370, 812702999),
              new X64Word.init(355462360, 4144912697),
              new X64Word.init(1731405415, 4290775857),
              new X64Word.init(2394180231, 1750603025),
              new X64Word.init(3675008525, 1694076839),
              new X64Word.init(1203062813, 3204075428)
            ]);
          },
          _doFinalize: function() {
            var hash = SHA512._doFinalize.call(this);
            hash.sigBytes -= 16;
            return hash;
          }
        });
        C.SHA384 = SHA512._createHelper(SHA384);
        C.HmacSHA384 = SHA512._createHmacHelper(SHA384);
      })();
      return CryptoJS.SHA384;
    });
  }
});

// node_modules/crypto-js/sha3.js
var require_sha3 = __commonJS({
  "node_modules/crypto-js/sha3.js"(exports, module) {
    (function(root, factory, undef) {
      if (typeof exports === "object") {
        module.exports = exports = factory(require_core(), require_x64_core());
      } else if (typeof define === "function" && define.amd) {
        define(["./core", "./x64-core"], factory);
      } else {
        factory(root.CryptoJS);
      }
    })(exports, function(CryptoJS) {
      (function(Math2) {
        var C = CryptoJS;
        var C_lib = C.lib;
        var WordArray = C_lib.WordArray;
        var Hasher = C_lib.Hasher;
        var C_x64 = C.x64;
        var X64Word = C_x64.Word;
        var C_algo = C.algo;
        var RHO_OFFSETS = [];
        var PI_INDEXES = [];
        var ROUND_CONSTANTS = [];
        (function() {
          var x = 1, y = 0;
          for (var t = 0; t < 24; t++) {
            RHO_OFFSETS[x + 5 * y] = (t + 1) * (t + 2) / 2 % 64;
            var newX = y % 5;
            var newY = (2 * x + 3 * y) % 5;
            x = newX;
            y = newY;
          }
          for (var x = 0; x < 5; x++) {
            for (var y = 0; y < 5; y++) {
              PI_INDEXES[x + 5 * y] = y + (2 * x + 3 * y) % 5 * 5;
            }
          }
          var LFSR = 1;
          for (var i = 0; i < 24; i++) {
            var roundConstantMsw = 0;
            var roundConstantLsw = 0;
            for (var j = 0; j < 7; j++) {
              if (LFSR & 1) {
                var bitPosition = (1 << j) - 1;
                if (bitPosition < 32) {
                  roundConstantLsw ^= 1 << bitPosition;
                } else {
                  roundConstantMsw ^= 1 << bitPosition - 32;
                }
              }
              if (LFSR & 128) {
                LFSR = LFSR << 1 ^ 113;
              } else {
                LFSR <<= 1;
              }
            }
            ROUND_CONSTANTS[i] = X64Word.create(roundConstantMsw, roundConstantLsw);
          }
        })();
        var T = [];
        (function() {
          for (var i = 0; i < 25; i++) {
            T[i] = X64Word.create();
          }
        })();
        var SHA3 = C_algo.SHA3 = Hasher.extend({
          cfg: Hasher.cfg.extend({
            outputLength: 512
          }),
          _doReset: function() {
            var state = this._state = [];
            for (var i = 0; i < 25; i++) {
              state[i] = new X64Word.init();
            }
            this.blockSize = (1600 - 2 * this.cfg.outputLength) / 32;
          },
          _doProcessBlock: function(M, offset) {
            var state = this._state;
            var nBlockSizeLanes = this.blockSize / 2;
            for (var i = 0; i < nBlockSizeLanes; i++) {
              var M2i = M[offset + 2 * i];
              var M2i1 = M[offset + 2 * i + 1];
              M2i = (M2i << 8 | M2i >>> 24) & 16711935 | (M2i << 24 | M2i >>> 8) & 4278255360;
              M2i1 = (M2i1 << 8 | M2i1 >>> 24) & 16711935 | (M2i1 << 24 | M2i1 >>> 8) & 4278255360;
              var lane = state[i];
              lane.high ^= M2i1;
              lane.low ^= M2i;
            }
            for (var round = 0; round < 24; round++) {
              for (var x = 0; x < 5; x++) {
                var tMsw = 0, tLsw = 0;
                for (var y = 0; y < 5; y++) {
                  var lane = state[x + 5 * y];
                  tMsw ^= lane.high;
                  tLsw ^= lane.low;
                }
                var Tx = T[x];
                Tx.high = tMsw;
                Tx.low = tLsw;
              }
              for (var x = 0; x < 5; x++) {
                var Tx4 = T[(x + 4) % 5];
                var Tx1 = T[(x + 1) % 5];
                var Tx1Msw = Tx1.high;
                var Tx1Lsw = Tx1.low;
                var tMsw = Tx4.high ^ (Tx1Msw << 1 | Tx1Lsw >>> 31);
                var tLsw = Tx4.low ^ (Tx1Lsw << 1 | Tx1Msw >>> 31);
                for (var y = 0; y < 5; y++) {
                  var lane = state[x + 5 * y];
                  lane.high ^= tMsw;
                  lane.low ^= tLsw;
                }
              }
              for (var laneIndex = 1; laneIndex < 25; laneIndex++) {
                var lane = state[laneIndex];
                var laneMsw = lane.high;
                var laneLsw = lane.low;
                var rhoOffset = RHO_OFFSETS[laneIndex];
                if (rhoOffset < 32) {
                  var tMsw = laneMsw << rhoOffset | laneLsw >>> 32 - rhoOffset;
                  var tLsw = laneLsw << rhoOffset | laneMsw >>> 32 - rhoOffset;
                } else {
                  var tMsw = laneLsw << rhoOffset - 32 | laneMsw >>> 64 - rhoOffset;
                  var tLsw = laneMsw << rhoOffset - 32 | laneLsw >>> 64 - rhoOffset;
                }
                var TPiLane = T[PI_INDEXES[laneIndex]];
                TPiLane.high = tMsw;
                TPiLane.low = tLsw;
              }
              var T0 = T[0];
              var state0 = state[0];
              T0.high = state0.high;
              T0.low = state0.low;
              for (var x = 0; x < 5; x++) {
                for (var y = 0; y < 5; y++) {
                  var laneIndex = x + 5 * y;
                  var lane = state[laneIndex];
                  var TLane = T[laneIndex];
                  var Tx1Lane = T[(x + 1) % 5 + 5 * y];
                  var Tx2Lane = T[(x + 2) % 5 + 5 * y];
                  lane.high = TLane.high ^ ~Tx1Lane.high & Tx2Lane.high;
                  lane.low = TLane.low ^ ~Tx1Lane.low & Tx2Lane.low;
                }
              }
              var lane = state[0];
              var roundConstant = ROUND_CONSTANTS[round];
              lane.high ^= roundConstant.high;
              lane.low ^= roundConstant.low;
              ;
            }
          },
          _doFinalize: function() {
            var data = this._data;
            var dataWords = data.words;
            var nBitsTotal = this._nDataBytes * 8;
            var nBitsLeft = data.sigBytes * 8;
            var blockSizeBits = this.blockSize * 32;
            dataWords[nBitsLeft >>> 5] |= 1 << 24 - nBitsLeft % 32;
            dataWords[(Math2.ceil((nBitsLeft + 1) / blockSizeBits) * blockSizeBits >>> 5) - 1] |= 128;
            data.sigBytes = dataWords.length * 4;
            this._process();
            var state = this._state;
            var outputLengthBytes = this.cfg.outputLength / 8;
            var outputLengthLanes = outputLengthBytes / 8;
            var hashWords = [];
            for (var i = 0; i < outputLengthLanes; i++) {
              var lane = state[i];
              var laneMsw = lane.high;
              var laneLsw = lane.low;
              laneMsw = (laneMsw << 8 | laneMsw >>> 24) & 16711935 | (laneMsw << 24 | laneMsw >>> 8) & 4278255360;
              laneLsw = (laneLsw << 8 | laneLsw >>> 24) & 16711935 | (laneLsw << 24 | laneLsw >>> 8) & 4278255360;
              hashWords.push(laneLsw);
              hashWords.push(laneMsw);
            }
            return new WordArray.init(hashWords, outputLengthBytes);
          },
          clone: function() {
            var clone = Hasher.clone.call(this);
            var state = clone._state = this._state.slice(0);
            for (var i = 0; i < 25; i++) {
              state[i] = state[i].clone();
            }
            return clone;
          }
        });
        C.SHA3 = Hasher._createHelper(SHA3);
        C.HmacSHA3 = Hasher._createHmacHelper(SHA3);
      })(Math);
      return CryptoJS.SHA3;
    });
  }
});

// node_modules/crypto-js/ripemd160.js
var require_ripemd160 = __commonJS({
  "node_modules/crypto-js/ripemd160.js"(exports, module) {
    (function(root, factory) {
      if (typeof exports === "object") {
        module.exports = exports = factory(require_core());
      } else if (typeof define === "function" && define.amd) {
        define(["./core"], factory);
      } else {
        factory(root.CryptoJS);
      }
    })(exports, function(CryptoJS) {
      (function(Math2) {
        var C = CryptoJS;
        var C_lib = C.lib;
        var WordArray = C_lib.WordArray;
        var Hasher = C_lib.Hasher;
        var C_algo = C.algo;
        var _zl = WordArray.create([
          0,
          1,
          2,
          3,
          4,
          5,
          6,
          7,
          8,
          9,
          10,
          11,
          12,
          13,
          14,
          15,
          7,
          4,
          13,
          1,
          10,
          6,
          15,
          3,
          12,
          0,
          9,
          5,
          2,
          14,
          11,
          8,
          3,
          10,
          14,
          4,
          9,
          15,
          8,
          1,
          2,
          7,
          0,
          6,
          13,
          11,
          5,
          12,
          1,
          9,
          11,
          10,
          0,
          8,
          12,
          4,
          13,
          3,
          7,
          15,
          14,
          5,
          6,
          2,
          4,
          0,
          5,
          9,
          7,
          12,
          2,
          10,
          14,
          1,
          3,
          8,
          11,
          6,
          15,
          13
        ]);
        var _zr = WordArray.create([
          5,
          14,
          7,
          0,
          9,
          2,
          11,
          4,
          13,
          6,
          15,
          8,
          1,
          10,
          3,
          12,
          6,
          11,
          3,
          7,
          0,
          13,
          5,
          10,
          14,
          15,
          8,
          12,
          4,
          9,
          1,
          2,
          15,
          5,
          1,
          3,
          7,
          14,
          6,
          9,
          11,
          8,
          12,
          2,
          10,
          0,
          4,
          13,
          8,
          6,
          4,
          1,
          3,
          11,
          15,
          0,
          5,
          12,
          2,
          13,
          9,
          7,
          10,
          14,
          12,
          15,
          10,
          4,
          1,
          5,
          8,
          7,
          6,
          2,
          13,
          14,
          0,
          3,
          9,
          11
        ]);
        var _sl = WordArray.create([
          11,
          14,
          15,
          12,
          5,
          8,
          7,
          9,
          11,
          13,
          14,
          15,
          6,
          7,
          9,
          8,
          7,
          6,
          8,
          13,
          11,
          9,
          7,
          15,
          7,
          12,
          15,
          9,
          11,
          7,
          13,
          12,
          11,
          13,
          6,
          7,
          14,
          9,
          13,
          15,
          14,
          8,
          13,
          6,
          5,
          12,
          7,
          5,
          11,
          12,
          14,
          15,
          14,
          15,
          9,
          8,
          9,
          14,
          5,
          6,
          8,
          6,
          5,
          12,
          9,
          15,
          5,
          11,
          6,
          8,
          13,
          12,
          5,
          12,
          13,
          14,
          11,
          8,
          5,
          6
        ]);
        var _sr = WordArray.create([
          8,
          9,
          9,
          11,
          13,
          15,
          15,
          5,
          7,
          7,
          8,
          11,
          14,
          14,
          12,
          6,
          9,
          13,
          15,
          7,
          12,
          8,
          9,
          11,
          7,
          7,
          12,
          7,
          6,
          15,
          13,
          11,
          9,
          7,
          15,
          11,
          8,
          6,
          6,
          14,
          12,
          13,
          5,
          14,
          13,
          13,
          7,
          5,
          15,
          5,
          8,
          11,
          14,
          14,
          6,
          14,
          6,
          9,
          12,
          9,
          12,
          5,
          15,
          8,
          8,
          5,
          12,
          9,
          12,
          5,
          14,
          6,
          8,
          13,
          6,
          5,
          15,
          13,
          11,
          11
        ]);
        var _hl = WordArray.create([0, 1518500249, 1859775393, 2400959708, 2840853838]);
        var _hr = WordArray.create([1352829926, 1548603684, 1836072691, 2053994217, 0]);
        var RIPEMD160 = C_algo.RIPEMD160 = Hasher.extend({
          _doReset: function() {
            this._hash = WordArray.create([1732584193, 4023233417, 2562383102, 271733878, 3285377520]);
          },
          _doProcessBlock: function(M, offset) {
            for (var i = 0; i < 16; i++) {
              var offset_i = offset + i;
              var M_offset_i = M[offset_i];
              M[offset_i] = (M_offset_i << 8 | M_offset_i >>> 24) & 16711935 | (M_offset_i << 24 | M_offset_i >>> 8) & 4278255360;
            }
            var H = this._hash.words;
            var hl = _hl.words;
            var hr = _hr.words;
            var zl = _zl.words;
            var zr = _zr.words;
            var sl = _sl.words;
            var sr = _sr.words;
            var al, bl, cl, dl, el;
            var ar, br, cr, dr, er;
            ar = al = H[0];
            br = bl = H[1];
            cr = cl = H[2];
            dr = dl = H[3];
            er = el = H[4];
            var t;
            for (var i = 0; i < 80; i += 1) {
              t = al + M[offset + zl[i]] | 0;
              if (i < 16) {
                t += f1(bl, cl, dl) + hl[0];
              } else if (i < 32) {
                t += f22(bl, cl, dl) + hl[1];
              } else if (i < 48) {
                t += f3(bl, cl, dl) + hl[2];
              } else if (i < 64) {
                t += f4(bl, cl, dl) + hl[3];
              } else {
                t += f5(bl, cl, dl) + hl[4];
              }
              t = t | 0;
              t = rotl(t, sl[i]);
              t = t + el | 0;
              al = el;
              el = dl;
              dl = rotl(cl, 10);
              cl = bl;
              bl = t;
              t = ar + M[offset + zr[i]] | 0;
              if (i < 16) {
                t += f5(br, cr, dr) + hr[0];
              } else if (i < 32) {
                t += f4(br, cr, dr) + hr[1];
              } else if (i < 48) {
                t += f3(br, cr, dr) + hr[2];
              } else if (i < 64) {
                t += f22(br, cr, dr) + hr[3];
              } else {
                t += f1(br, cr, dr) + hr[4];
              }
              t = t | 0;
              t = rotl(t, sr[i]);
              t = t + er | 0;
              ar = er;
              er = dr;
              dr = rotl(cr, 10);
              cr = br;
              br = t;
            }
            t = H[1] + cl + dr | 0;
            H[1] = H[2] + dl + er | 0;
            H[2] = H[3] + el + ar | 0;
            H[3] = H[4] + al + br | 0;
            H[4] = H[0] + bl + cr | 0;
            H[0] = t;
          },
          _doFinalize: function() {
            var data = this._data;
            var dataWords = data.words;
            var nBitsTotal = this._nDataBytes * 8;
            var nBitsLeft = data.sigBytes * 8;
            dataWords[nBitsLeft >>> 5] |= 128 << 24 - nBitsLeft % 32;
            dataWords[(nBitsLeft + 64 >>> 9 << 4) + 14] = (nBitsTotal << 8 | nBitsTotal >>> 24) & 16711935 | (nBitsTotal << 24 | nBitsTotal >>> 8) & 4278255360;
            data.sigBytes = (dataWords.length + 1) * 4;
            this._process();
            var hash = this._hash;
            var H = hash.words;
            for (var i = 0; i < 5; i++) {
              var H_i = H[i];
              H[i] = (H_i << 8 | H_i >>> 24) & 16711935 | (H_i << 24 | H_i >>> 8) & 4278255360;
            }
            return hash;
          },
          clone: function() {
            var clone = Hasher.clone.call(this);
            clone._hash = this._hash.clone();
            return clone;
          }
        });
        function f1(x, y, z) {
          return x ^ y ^ z;
        }
        function f22(x, y, z) {
          return x & y | ~x & z;
        }
        function f3(x, y, z) {
          return (x | ~y) ^ z;
        }
        function f4(x, y, z) {
          return x & z | y & ~z;
        }
        function f5(x, y, z) {
          return x ^ (y | ~z);
        }
        function rotl(x, n) {
          return x << n | x >>> 32 - n;
        }
        C.RIPEMD160 = Hasher._createHelper(RIPEMD160);
        C.HmacRIPEMD160 = Hasher._createHmacHelper(RIPEMD160);
      })(Math);
      return CryptoJS.RIPEMD160;
    });
  }
});

// node_modules/crypto-js/hmac.js
var require_hmac = __commonJS({
  "node_modules/crypto-js/hmac.js"(exports, module) {
    (function(root, factory) {
      if (typeof exports === "object") {
        module.exports = exports = factory(require_core());
      } else if (typeof define === "function" && define.amd) {
        define(["./core"], factory);
      } else {
        factory(root.CryptoJS);
      }
    })(exports, function(CryptoJS) {
      (function() {
        var C = CryptoJS;
        var C_lib = C.lib;
        var Base = C_lib.Base;
        var C_enc = C.enc;
        var Utf8 = C_enc.Utf8;
        var C_algo = C.algo;
        var HMAC = C_algo.HMAC = Base.extend({
          init: function(hasher, key) {
            hasher = this._hasher = new hasher.init();
            if (typeof key == "string") {
              key = Utf8.parse(key);
            }
            var hasherBlockSize = hasher.blockSize;
            var hasherBlockSizeBytes = hasherBlockSize * 4;
            if (key.sigBytes > hasherBlockSizeBytes) {
              key = hasher.finalize(key);
            }
            key.clamp();
            var oKey = this._oKey = key.clone();
            var iKey = this._iKey = key.clone();
            var oKeyWords = oKey.words;
            var iKeyWords = iKey.words;
            for (var i = 0; i < hasherBlockSize; i++) {
              oKeyWords[i] ^= 1549556828;
              iKeyWords[i] ^= 909522486;
            }
            oKey.sigBytes = iKey.sigBytes = hasherBlockSizeBytes;
            this.reset();
          },
          reset: function() {
            var hasher = this._hasher;
            hasher.reset();
            hasher.update(this._iKey);
          },
          update: function(messageUpdate) {
            this._hasher.update(messageUpdate);
            return this;
          },
          finalize: function(messageUpdate) {
            var hasher = this._hasher;
            var innerHash = hasher.finalize(messageUpdate);
            hasher.reset();
            var hmac = hasher.finalize(this._oKey.clone().concat(innerHash));
            return hmac;
          }
        });
      })();
    });
  }
});

// node_modules/crypto-js/pbkdf2.js
var require_pbkdf2 = __commonJS({
  "node_modules/crypto-js/pbkdf2.js"(exports, module) {
    (function(root, factory, undef) {
      if (typeof exports === "object") {
        module.exports = exports = factory(require_core(), require_sha1(), require_hmac());
      } else if (typeof define === "function" && define.amd) {
        define(["./core", "./sha1", "./hmac"], factory);
      } else {
        factory(root.CryptoJS);
      }
    })(exports, function(CryptoJS) {
      (function() {
        var C = CryptoJS;
        var C_lib = C.lib;
        var Base = C_lib.Base;
        var WordArray = C_lib.WordArray;
        var C_algo = C.algo;
        var SHA1 = C_algo.SHA1;
        var HMAC = C_algo.HMAC;
        var PBKDF2 = C_algo.PBKDF2 = Base.extend({
          cfg: Base.extend({
            keySize: 128 / 32,
            hasher: SHA1,
            iterations: 1
          }),
          init: function(cfg) {
            this.cfg = this.cfg.extend(cfg);
          },
          compute: function(password, salt) {
            var cfg = this.cfg;
            var hmac = HMAC.create(cfg.hasher, password);
            var derivedKey = WordArray.create();
            var blockIndex = WordArray.create([1]);
            var derivedKeyWords = derivedKey.words;
            var blockIndexWords = blockIndex.words;
            var keySize = cfg.keySize;
            var iterations = cfg.iterations;
            while (derivedKeyWords.length < keySize) {
              var block = hmac.update(salt).finalize(blockIndex);
              hmac.reset();
              var blockWords = block.words;
              var blockWordsLength = blockWords.length;
              var intermediate = block;
              for (var i = 1; i < iterations; i++) {
                intermediate = hmac.finalize(intermediate);
                hmac.reset();
                var intermediateWords = intermediate.words;
                for (var j = 0; j < blockWordsLength; j++) {
                  blockWords[j] ^= intermediateWords[j];
                }
              }
              derivedKey.concat(block);
              blockIndexWords[0]++;
            }
            derivedKey.sigBytes = keySize * 4;
            return derivedKey;
          }
        });
        C.PBKDF2 = function(password, salt, cfg) {
          return PBKDF2.create(cfg).compute(password, salt);
        };
      })();
      return CryptoJS.PBKDF2;
    });
  }
});

// node_modules/crypto-js/evpkdf.js
var require_evpkdf = __commonJS({
  "node_modules/crypto-js/evpkdf.js"(exports, module) {
    (function(root, factory, undef) {
      if (typeof exports === "object") {
        module.exports = exports = factory(require_core(), require_sha1(), require_hmac());
      } else if (typeof define === "function" && define.amd) {
        define(["./core", "./sha1", "./hmac"], factory);
      } else {
        factory(root.CryptoJS);
      }
    })(exports, function(CryptoJS) {
      (function() {
        var C = CryptoJS;
        var C_lib = C.lib;
        var Base = C_lib.Base;
        var WordArray = C_lib.WordArray;
        var C_algo = C.algo;
        var MD5 = C_algo.MD5;
        var EvpKDF = C_algo.EvpKDF = Base.extend({
          cfg: Base.extend({
            keySize: 128 / 32,
            hasher: MD5,
            iterations: 1
          }),
          init: function(cfg) {
            this.cfg = this.cfg.extend(cfg);
          },
          compute: function(password, salt) {
            var cfg = this.cfg;
            var hasher = cfg.hasher.create();
            var derivedKey = WordArray.create();
            var derivedKeyWords = derivedKey.words;
            var keySize = cfg.keySize;
            var iterations = cfg.iterations;
            while (derivedKeyWords.length < keySize) {
              if (block) {
                hasher.update(block);
              }
              var block = hasher.update(password).finalize(salt);
              hasher.reset();
              for (var i = 1; i < iterations; i++) {
                block = hasher.finalize(block);
                hasher.reset();
              }
              derivedKey.concat(block);
            }
            derivedKey.sigBytes = keySize * 4;
            return derivedKey;
          }
        });
        C.EvpKDF = function(password, salt, cfg) {
          return EvpKDF.create(cfg).compute(password, salt);
        };
      })();
      return CryptoJS.EvpKDF;
    });
  }
});

// node_modules/crypto-js/cipher-core.js
var require_cipher_core = __commonJS({
  "node_modules/crypto-js/cipher-core.js"(exports, module) {
    (function(root, factory, undef) {
      if (typeof exports === "object") {
        module.exports = exports = factory(require_core(), require_evpkdf());
      } else if (typeof define === "function" && define.amd) {
        define(["./core", "./evpkdf"], factory);
      } else {
        factory(root.CryptoJS);
      }
    })(exports, function(CryptoJS) {
      CryptoJS.lib.Cipher || function(undefined2) {
        var C = CryptoJS;
        var C_lib = C.lib;
        var Base = C_lib.Base;
        var WordArray = C_lib.WordArray;
        var BufferedBlockAlgorithm = C_lib.BufferedBlockAlgorithm;
        var C_enc = C.enc;
        var Utf8 = C_enc.Utf8;
        var Base64 = C_enc.Base64;
        var C_algo = C.algo;
        var EvpKDF = C_algo.EvpKDF;
        var Cipher = C_lib.Cipher = BufferedBlockAlgorithm.extend({
          cfg: Base.extend(),
          createEncryptor: function(key, cfg) {
            return this.create(this._ENC_XFORM_MODE, key, cfg);
          },
          createDecryptor: function(key, cfg) {
            return this.create(this._DEC_XFORM_MODE, key, cfg);
          },
          init: function(xformMode, key, cfg) {
            this.cfg = this.cfg.extend(cfg);
            this._xformMode = xformMode;
            this._key = key;
            this.reset();
          },
          reset: function() {
            BufferedBlockAlgorithm.reset.call(this);
            this._doReset();
          },
          process: function(dataUpdate) {
            this._append(dataUpdate);
            return this._process();
          },
          finalize: function(dataUpdate) {
            if (dataUpdate) {
              this._append(dataUpdate);
            }
            var finalProcessedData = this._doFinalize();
            return finalProcessedData;
          },
          keySize: 128 / 32,
          ivSize: 128 / 32,
          _ENC_XFORM_MODE: 1,
          _DEC_XFORM_MODE: 2,
          _createHelper: function() {
            function selectCipherStrategy(key) {
              if (typeof key == "string") {
                return PasswordBasedCipher;
              } else {
                return SerializableCipher;
              }
            }
            return function(cipher) {
              return {
                encrypt: function(message, key, cfg) {
                  return selectCipherStrategy(key).encrypt(cipher, message, key, cfg);
                },
                decrypt: function(ciphertext, key, cfg) {
                  return selectCipherStrategy(key).decrypt(cipher, ciphertext, key, cfg);
                }
              };
            };
          }()
        });
        var StreamCipher = C_lib.StreamCipher = Cipher.extend({
          _doFinalize: function() {
            var finalProcessedBlocks = this._process(true);
            return finalProcessedBlocks;
          },
          blockSize: 1
        });
        var C_mode = C.mode = {};
        var BlockCipherMode = C_lib.BlockCipherMode = Base.extend({
          createEncryptor: function(cipher, iv) {
            return this.Encryptor.create(cipher, iv);
          },
          createDecryptor: function(cipher, iv) {
            return this.Decryptor.create(cipher, iv);
          },
          init: function(cipher, iv) {
            this._cipher = cipher;
            this._iv = iv;
          }
        });
        var CBC = C_mode.CBC = function() {
          var CBC2 = BlockCipherMode.extend();
          CBC2.Encryptor = CBC2.extend({
            processBlock: function(words, offset) {
              var cipher = this._cipher;
              var blockSize = cipher.blockSize;
              xorBlock.call(this, words, offset, blockSize);
              cipher.encryptBlock(words, offset);
              this._prevBlock = words.slice(offset, offset + blockSize);
            }
          });
          CBC2.Decryptor = CBC2.extend({
            processBlock: function(words, offset) {
              var cipher = this._cipher;
              var blockSize = cipher.blockSize;
              var thisBlock = words.slice(offset, offset + blockSize);
              cipher.decryptBlock(words, offset);
              xorBlock.call(this, words, offset, blockSize);
              this._prevBlock = thisBlock;
            }
          });
          function xorBlock(words, offset, blockSize) {
            var iv = this._iv;
            if (iv) {
              var block = iv;
              this._iv = undefined2;
            } else {
              var block = this._prevBlock;
            }
            for (var i = 0; i < blockSize; i++) {
              words[offset + i] ^= block[i];
            }
          }
          return CBC2;
        }();
        var C_pad = C.pad = {};
        var Pkcs7 = C_pad.Pkcs7 = {
          pad: function(data, blockSize) {
            var blockSizeBytes = blockSize * 4;
            var nPaddingBytes = blockSizeBytes - data.sigBytes % blockSizeBytes;
            var paddingWord = nPaddingBytes << 24 | nPaddingBytes << 16 | nPaddingBytes << 8 | nPaddingBytes;
            var paddingWords = [];
            for (var i = 0; i < nPaddingBytes; i += 4) {
              paddingWords.push(paddingWord);
            }
            var padding = WordArray.create(paddingWords, nPaddingBytes);
            data.concat(padding);
          },
          unpad: function(data) {
            var nPaddingBytes = data.words[data.sigBytes - 1 >>> 2] & 255;
            data.sigBytes -= nPaddingBytes;
          }
        };
        var BlockCipher = C_lib.BlockCipher = Cipher.extend({
          cfg: Cipher.cfg.extend({
            mode: CBC,
            padding: Pkcs7
          }),
          reset: function() {
            Cipher.reset.call(this);
            var cfg = this.cfg;
            var iv = cfg.iv;
            var mode = cfg.mode;
            if (this._xformMode == this._ENC_XFORM_MODE) {
              var modeCreator = mode.createEncryptor;
            } else {
              var modeCreator = mode.createDecryptor;
              this._minBufferSize = 1;
            }
            if (this._mode && this._mode.__creator == modeCreator) {
              this._mode.init(this, iv && iv.words);
            } else {
              this._mode = modeCreator.call(mode, this, iv && iv.words);
              this._mode.__creator = modeCreator;
            }
          },
          _doProcessBlock: function(words, offset) {
            this._mode.processBlock(words, offset);
          },
          _doFinalize: function() {
            var padding = this.cfg.padding;
            if (this._xformMode == this._ENC_XFORM_MODE) {
              padding.pad(this._data, this.blockSize);
              var finalProcessedBlocks = this._process(true);
            } else {
              var finalProcessedBlocks = this._process(true);
              padding.unpad(finalProcessedBlocks);
            }
            return finalProcessedBlocks;
          },
          blockSize: 128 / 32
        });
        var CipherParams = C_lib.CipherParams = Base.extend({
          init: function(cipherParams) {
            this.mixIn(cipherParams);
          },
          toString: function(formatter) {
            return (formatter || this.formatter).stringify(this);
          }
        });
        var C_format = C.format = {};
        var OpenSSLFormatter = C_format.OpenSSL = {
          stringify: function(cipherParams) {
            var ciphertext = cipherParams.ciphertext;
            var salt = cipherParams.salt;
            if (salt) {
              var wordArray = WordArray.create([1398893684, 1701076831]).concat(salt).concat(ciphertext);
            } else {
              var wordArray = ciphertext;
            }
            return wordArray.toString(Base64);
          },
          parse: function(openSSLStr) {
            var ciphertext = Base64.parse(openSSLStr);
            var ciphertextWords = ciphertext.words;
            if (ciphertextWords[0] == 1398893684 && ciphertextWords[1] == 1701076831) {
              var salt = WordArray.create(ciphertextWords.slice(2, 4));
              ciphertextWords.splice(0, 4);
              ciphertext.sigBytes -= 16;
            }
            return CipherParams.create({ ciphertext, salt });
          }
        };
        var SerializableCipher = C_lib.SerializableCipher = Base.extend({
          cfg: Base.extend({
            format: OpenSSLFormatter
          }),
          encrypt: function(cipher, message, key, cfg) {
            cfg = this.cfg.extend(cfg);
            var encryptor = cipher.createEncryptor(key, cfg);
            var ciphertext = encryptor.finalize(message);
            var cipherCfg = encryptor.cfg;
            return CipherParams.create({
              ciphertext,
              key,
              iv: cipherCfg.iv,
              algorithm: cipher,
              mode: cipherCfg.mode,
              padding: cipherCfg.padding,
              blockSize: cipher.blockSize,
              formatter: cfg.format
            });
          },
          decrypt: function(cipher, ciphertext, key, cfg) {
            cfg = this.cfg.extend(cfg);
            ciphertext = this._parse(ciphertext, cfg.format);
            var plaintext = cipher.createDecryptor(key, cfg).finalize(ciphertext.ciphertext);
            return plaintext;
          },
          _parse: function(ciphertext, format) {
            if (typeof ciphertext == "string") {
              return format.parse(ciphertext, this);
            } else {
              return ciphertext;
            }
          }
        });
        var C_kdf = C.kdf = {};
        var OpenSSLKdf = C_kdf.OpenSSL = {
          execute: function(password, keySize, ivSize, salt) {
            if (!salt) {
              salt = WordArray.random(64 / 8);
            }
            var key = EvpKDF.create({ keySize: keySize + ivSize }).compute(password, salt);
            var iv = WordArray.create(key.words.slice(keySize), ivSize * 4);
            key.sigBytes = keySize * 4;
            return CipherParams.create({ key, iv, salt });
          }
        };
        var PasswordBasedCipher = C_lib.PasswordBasedCipher = SerializableCipher.extend({
          cfg: SerializableCipher.cfg.extend({
            kdf: OpenSSLKdf
          }),
          encrypt: function(cipher, message, password, cfg) {
            cfg = this.cfg.extend(cfg);
            var derivedParams = cfg.kdf.execute(password, cipher.keySize, cipher.ivSize);
            cfg.iv = derivedParams.iv;
            var ciphertext = SerializableCipher.encrypt.call(this, cipher, message, derivedParams.key, cfg);
            ciphertext.mixIn(derivedParams);
            return ciphertext;
          },
          decrypt: function(cipher, ciphertext, password, cfg) {
            cfg = this.cfg.extend(cfg);
            ciphertext = this._parse(ciphertext, cfg.format);
            var derivedParams = cfg.kdf.execute(password, cipher.keySize, cipher.ivSize, ciphertext.salt);
            cfg.iv = derivedParams.iv;
            var plaintext = SerializableCipher.decrypt.call(this, cipher, ciphertext, derivedParams.key, cfg);
            return plaintext;
          }
        });
      }();
    });
  }
});

// node_modules/crypto-js/mode-cfb.js
var require_mode_cfb = __commonJS({
  "node_modules/crypto-js/mode-cfb.js"(exports, module) {
    (function(root, factory, undef) {
      if (typeof exports === "object") {
        module.exports = exports = factory(require_core(), require_cipher_core());
      } else if (typeof define === "function" && define.amd) {
        define(["./core", "./cipher-core"], factory);
      } else {
        factory(root.CryptoJS);
      }
    })(exports, function(CryptoJS) {
      CryptoJS.mode.CFB = function() {
        var CFB = CryptoJS.lib.BlockCipherMode.extend();
        CFB.Encryptor = CFB.extend({
          processBlock: function(words, offset) {
            var cipher = this._cipher;
            var blockSize = cipher.blockSize;
            generateKeystreamAndEncrypt.call(this, words, offset, blockSize, cipher);
            this._prevBlock = words.slice(offset, offset + blockSize);
          }
        });
        CFB.Decryptor = CFB.extend({
          processBlock: function(words, offset) {
            var cipher = this._cipher;
            var blockSize = cipher.blockSize;
            var thisBlock = words.slice(offset, offset + blockSize);
            generateKeystreamAndEncrypt.call(this, words, offset, blockSize, cipher);
            this._prevBlock = thisBlock;
          }
        });
        function generateKeystreamAndEncrypt(words, offset, blockSize, cipher) {
          var iv = this._iv;
          if (iv) {
            var keystream = iv.slice(0);
            this._iv = void 0;
          } else {
            var keystream = this._prevBlock;
          }
          cipher.encryptBlock(keystream, 0);
          for (var i = 0; i < blockSize; i++) {
            words[offset + i] ^= keystream[i];
          }
        }
        return CFB;
      }();
      return CryptoJS.mode.CFB;
    });
  }
});

// node_modules/crypto-js/mode-ctr.js
var require_mode_ctr = __commonJS({
  "node_modules/crypto-js/mode-ctr.js"(exports, module) {
    (function(root, factory, undef) {
      if (typeof exports === "object") {
        module.exports = exports = factory(require_core(), require_cipher_core());
      } else if (typeof define === "function" && define.amd) {
        define(["./core", "./cipher-core"], factory);
      } else {
        factory(root.CryptoJS);
      }
    })(exports, function(CryptoJS) {
      CryptoJS.mode.CTR = function() {
        var CTR = CryptoJS.lib.BlockCipherMode.extend();
        var Encryptor = CTR.Encryptor = CTR.extend({
          processBlock: function(words, offset) {
            var cipher = this._cipher;
            var blockSize = cipher.blockSize;
            var iv = this._iv;
            var counter = this._counter;
            if (iv) {
              counter = this._counter = iv.slice(0);
              this._iv = void 0;
            }
            var keystream = counter.slice(0);
            cipher.encryptBlock(keystream, 0);
            counter[blockSize - 1] = counter[blockSize - 1] + 1 | 0;
            for (var i = 0; i < blockSize; i++) {
              words[offset + i] ^= keystream[i];
            }
          }
        });
        CTR.Decryptor = Encryptor;
        return CTR;
      }();
      return CryptoJS.mode.CTR;
    });
  }
});

// node_modules/crypto-js/mode-ctr-gladman.js
var require_mode_ctr_gladman = __commonJS({
  "node_modules/crypto-js/mode-ctr-gladman.js"(exports, module) {
    (function(root, factory, undef) {
      if (typeof exports === "object") {
        module.exports = exports = factory(require_core(), require_cipher_core());
      } else if (typeof define === "function" && define.amd) {
        define(["./core", "./cipher-core"], factory);
      } else {
        factory(root.CryptoJS);
      }
    })(exports, function(CryptoJS) {
      CryptoJS.mode.CTRGladman = function() {
        var CTRGladman = CryptoJS.lib.BlockCipherMode.extend();
        function incWord(word) {
          if ((word >> 24 & 255) === 255) {
            var b1 = word >> 16 & 255;
            var b2 = word >> 8 & 255;
            var b3 = word & 255;
            if (b1 === 255) {
              b1 = 0;
              if (b2 === 255) {
                b2 = 0;
                if (b3 === 255) {
                  b3 = 0;
                } else {
                  ++b3;
                }
              } else {
                ++b2;
              }
            } else {
              ++b1;
            }
            word = 0;
            word += b1 << 16;
            word += b2 << 8;
            word += b3;
          } else {
            word += 1 << 24;
          }
          return word;
        }
        function incCounter(counter) {
          if ((counter[0] = incWord(counter[0])) === 0) {
            counter[1] = incWord(counter[1]);
          }
          return counter;
        }
        var Encryptor = CTRGladman.Encryptor = CTRGladman.extend({
          processBlock: function(words, offset) {
            var cipher = this._cipher;
            var blockSize = cipher.blockSize;
            var iv = this._iv;
            var counter = this._counter;
            if (iv) {
              counter = this._counter = iv.slice(0);
              this._iv = void 0;
            }
            incCounter(counter);
            var keystream = counter.slice(0);
            cipher.encryptBlock(keystream, 0);
            for (var i = 0; i < blockSize; i++) {
              words[offset + i] ^= keystream[i];
            }
          }
        });
        CTRGladman.Decryptor = Encryptor;
        return CTRGladman;
      }();
      return CryptoJS.mode.CTRGladman;
    });
  }
});

// node_modules/crypto-js/mode-ofb.js
var require_mode_ofb = __commonJS({
  "node_modules/crypto-js/mode-ofb.js"(exports, module) {
    (function(root, factory, undef) {
      if (typeof exports === "object") {
        module.exports = exports = factory(require_core(), require_cipher_core());
      } else if (typeof define === "function" && define.amd) {
        define(["./core", "./cipher-core"], factory);
      } else {
        factory(root.CryptoJS);
      }
    })(exports, function(CryptoJS) {
      CryptoJS.mode.OFB = function() {
        var OFB = CryptoJS.lib.BlockCipherMode.extend();
        var Encryptor = OFB.Encryptor = OFB.extend({
          processBlock: function(words, offset) {
            var cipher = this._cipher;
            var blockSize = cipher.blockSize;
            var iv = this._iv;
            var keystream = this._keystream;
            if (iv) {
              keystream = this._keystream = iv.slice(0);
              this._iv = void 0;
            }
            cipher.encryptBlock(keystream, 0);
            for (var i = 0; i < blockSize; i++) {
              words[offset + i] ^= keystream[i];
            }
          }
        });
        OFB.Decryptor = Encryptor;
        return OFB;
      }();
      return CryptoJS.mode.OFB;
    });
  }
});

// node_modules/crypto-js/mode-ecb.js
var require_mode_ecb = __commonJS({
  "node_modules/crypto-js/mode-ecb.js"(exports, module) {
    (function(root, factory, undef) {
      if (typeof exports === "object") {
        module.exports = exports = factory(require_core(), require_cipher_core());
      } else if (typeof define === "function" && define.amd) {
        define(["./core", "./cipher-core"], factory);
      } else {
        factory(root.CryptoJS);
      }
    })(exports, function(CryptoJS) {
      CryptoJS.mode.ECB = function() {
        var ECB = CryptoJS.lib.BlockCipherMode.extend();
        ECB.Encryptor = ECB.extend({
          processBlock: function(words, offset) {
            this._cipher.encryptBlock(words, offset);
          }
        });
        ECB.Decryptor = ECB.extend({
          processBlock: function(words, offset) {
            this._cipher.decryptBlock(words, offset);
          }
        });
        return ECB;
      }();
      return CryptoJS.mode.ECB;
    });
  }
});

// node_modules/crypto-js/pad-ansix923.js
var require_pad_ansix923 = __commonJS({
  "node_modules/crypto-js/pad-ansix923.js"(exports, module) {
    (function(root, factory, undef) {
      if (typeof exports === "object") {
        module.exports = exports = factory(require_core(), require_cipher_core());
      } else if (typeof define === "function" && define.amd) {
        define(["./core", "./cipher-core"], factory);
      } else {
        factory(root.CryptoJS);
      }
    })(exports, function(CryptoJS) {
      CryptoJS.pad.AnsiX923 = {
        pad: function(data, blockSize) {
          var dataSigBytes = data.sigBytes;
          var blockSizeBytes = blockSize * 4;
          var nPaddingBytes = blockSizeBytes - dataSigBytes % blockSizeBytes;
          var lastBytePos = dataSigBytes + nPaddingBytes - 1;
          data.clamp();
          data.words[lastBytePos >>> 2] |= nPaddingBytes << 24 - lastBytePos % 4 * 8;
          data.sigBytes += nPaddingBytes;
        },
        unpad: function(data) {
          var nPaddingBytes = data.words[data.sigBytes - 1 >>> 2] & 255;
          data.sigBytes -= nPaddingBytes;
        }
      };
      return CryptoJS.pad.Ansix923;
    });
  }
});

// node_modules/crypto-js/pad-iso10126.js
var require_pad_iso10126 = __commonJS({
  "node_modules/crypto-js/pad-iso10126.js"(exports, module) {
    (function(root, factory, undef) {
      if (typeof exports === "object") {
        module.exports = exports = factory(require_core(), require_cipher_core());
      } else if (typeof define === "function" && define.amd) {
        define(["./core", "./cipher-core"], factory);
      } else {
        factory(root.CryptoJS);
      }
    })(exports, function(CryptoJS) {
      CryptoJS.pad.Iso10126 = {
        pad: function(data, blockSize) {
          var blockSizeBytes = blockSize * 4;
          var nPaddingBytes = blockSizeBytes - data.sigBytes % blockSizeBytes;
          data.concat(CryptoJS.lib.WordArray.random(nPaddingBytes - 1)).concat(CryptoJS.lib.WordArray.create([nPaddingBytes << 24], 1));
        },
        unpad: function(data) {
          var nPaddingBytes = data.words[data.sigBytes - 1 >>> 2] & 255;
          data.sigBytes -= nPaddingBytes;
        }
      };
      return CryptoJS.pad.Iso10126;
    });
  }
});

// node_modules/crypto-js/pad-iso97971.js
var require_pad_iso97971 = __commonJS({
  "node_modules/crypto-js/pad-iso97971.js"(exports, module) {
    (function(root, factory, undef) {
      if (typeof exports === "object") {
        module.exports = exports = factory(require_core(), require_cipher_core());
      } else if (typeof define === "function" && define.amd) {
        define(["./core", "./cipher-core"], factory);
      } else {
        factory(root.CryptoJS);
      }
    })(exports, function(CryptoJS) {
      CryptoJS.pad.Iso97971 = {
        pad: function(data, blockSize) {
          data.concat(CryptoJS.lib.WordArray.create([2147483648], 1));
          CryptoJS.pad.ZeroPadding.pad(data, blockSize);
        },
        unpad: function(data) {
          CryptoJS.pad.ZeroPadding.unpad(data);
          data.sigBytes--;
        }
      };
      return CryptoJS.pad.Iso97971;
    });
  }
});

// node_modules/crypto-js/pad-zeropadding.js
var require_pad_zeropadding = __commonJS({
  "node_modules/crypto-js/pad-zeropadding.js"(exports, module) {
    (function(root, factory, undef) {
      if (typeof exports === "object") {
        module.exports = exports = factory(require_core(), require_cipher_core());
      } else if (typeof define === "function" && define.amd) {
        define(["./core", "./cipher-core"], factory);
      } else {
        factory(root.CryptoJS);
      }
    })(exports, function(CryptoJS) {
      CryptoJS.pad.ZeroPadding = {
        pad: function(data, blockSize) {
          var blockSizeBytes = blockSize * 4;
          data.clamp();
          data.sigBytes += blockSizeBytes - (data.sigBytes % blockSizeBytes || blockSizeBytes);
        },
        unpad: function(data) {
          var dataWords = data.words;
          var i = data.sigBytes - 1;
          while (!(dataWords[i >>> 2] >>> 24 - i % 4 * 8 & 255)) {
            i--;
          }
          data.sigBytes = i + 1;
        }
      };
      return CryptoJS.pad.ZeroPadding;
    });
  }
});

// node_modules/crypto-js/pad-nopadding.js
var require_pad_nopadding = __commonJS({
  "node_modules/crypto-js/pad-nopadding.js"(exports, module) {
    (function(root, factory, undef) {
      if (typeof exports === "object") {
        module.exports = exports = factory(require_core(), require_cipher_core());
      } else if (typeof define === "function" && define.amd) {
        define(["./core", "./cipher-core"], factory);
      } else {
        factory(root.CryptoJS);
      }
    })(exports, function(CryptoJS) {
      CryptoJS.pad.NoPadding = {
        pad: function() {
        },
        unpad: function() {
        }
      };
      return CryptoJS.pad.NoPadding;
    });
  }
});

// node_modules/crypto-js/format-hex.js
var require_format_hex = __commonJS({
  "node_modules/crypto-js/format-hex.js"(exports, module) {
    (function(root, factory, undef) {
      if (typeof exports === "object") {
        module.exports = exports = factory(require_core(), require_cipher_core());
      } else if (typeof define === "function" && define.amd) {
        define(["./core", "./cipher-core"], factory);
      } else {
        factory(root.CryptoJS);
      }
    })(exports, function(CryptoJS) {
      (function(undefined2) {
        var C = CryptoJS;
        var C_lib = C.lib;
        var CipherParams = C_lib.CipherParams;
        var C_enc = C.enc;
        var Hex = C_enc.Hex;
        var C_format = C.format;
        var HexFormatter = C_format.Hex = {
          stringify: function(cipherParams) {
            return cipherParams.ciphertext.toString(Hex);
          },
          parse: function(input) {
            var ciphertext = Hex.parse(input);
            return CipherParams.create({ ciphertext });
          }
        };
      })();
      return CryptoJS.format.Hex;
    });
  }
});

// node_modules/crypto-js/aes.js
var require_aes = __commonJS({
  "node_modules/crypto-js/aes.js"(exports, module) {
    (function(root, factory, undef) {
      if (typeof exports === "object") {
        module.exports = exports = factory(require_core(), require_enc_base64(), require_md5(), require_evpkdf(), require_cipher_core());
      } else if (typeof define === "function" && define.amd) {
        define(["./core", "./enc-base64", "./md5", "./evpkdf", "./cipher-core"], factory);
      } else {
        factory(root.CryptoJS);
      }
    })(exports, function(CryptoJS) {
      (function() {
        var C = CryptoJS;
        var C_lib = C.lib;
        var BlockCipher = C_lib.BlockCipher;
        var C_algo = C.algo;
        var SBOX = [];
        var INV_SBOX = [];
        var SUB_MIX_0 = [];
        var SUB_MIX_1 = [];
        var SUB_MIX_2 = [];
        var SUB_MIX_3 = [];
        var INV_SUB_MIX_0 = [];
        var INV_SUB_MIX_1 = [];
        var INV_SUB_MIX_2 = [];
        var INV_SUB_MIX_3 = [];
        (function() {
          var d = [];
          for (var i = 0; i < 256; i++) {
            if (i < 128) {
              d[i] = i << 1;
            } else {
              d[i] = i << 1 ^ 283;
            }
          }
          var x = 0;
          var xi = 0;
          for (var i = 0; i < 256; i++) {
            var sx = xi ^ xi << 1 ^ xi << 2 ^ xi << 3 ^ xi << 4;
            sx = sx >>> 8 ^ sx & 255 ^ 99;
            SBOX[x] = sx;
            INV_SBOX[sx] = x;
            var x2 = d[x];
            var x4 = d[x2];
            var x8 = d[x4];
            var t = d[sx] * 257 ^ sx * 16843008;
            SUB_MIX_0[x] = t << 24 | t >>> 8;
            SUB_MIX_1[x] = t << 16 | t >>> 16;
            SUB_MIX_2[x] = t << 8 | t >>> 24;
            SUB_MIX_3[x] = t;
            var t = x8 * 16843009 ^ x4 * 65537 ^ x2 * 257 ^ x * 16843008;
            INV_SUB_MIX_0[sx] = t << 24 | t >>> 8;
            INV_SUB_MIX_1[sx] = t << 16 | t >>> 16;
            INV_SUB_MIX_2[sx] = t << 8 | t >>> 24;
            INV_SUB_MIX_3[sx] = t;
            if (!x) {
              x = xi = 1;
            } else {
              x = x2 ^ d[d[d[x8 ^ x2]]];
              xi ^= d[d[xi]];
            }
          }
        })();
        var RCON = [0, 1, 2, 4, 8, 16, 32, 64, 128, 27, 54];
        var AES = C_algo.AES = BlockCipher.extend({
          _doReset: function() {
            if (this._nRounds && this._keyPriorReset === this._key) {
              return;
            }
            var key = this._keyPriorReset = this._key;
            var keyWords = key.words;
            var keySize = key.sigBytes / 4;
            var nRounds = this._nRounds = keySize + 6;
            var ksRows = (nRounds + 1) * 4;
            var keySchedule = this._keySchedule = [];
            for (var ksRow = 0; ksRow < ksRows; ksRow++) {
              if (ksRow < keySize) {
                keySchedule[ksRow] = keyWords[ksRow];
              } else {
                var t = keySchedule[ksRow - 1];
                if (!(ksRow % keySize)) {
                  t = t << 8 | t >>> 24;
                  t = SBOX[t >>> 24] << 24 | SBOX[t >>> 16 & 255] << 16 | SBOX[t >>> 8 & 255] << 8 | SBOX[t & 255];
                  t ^= RCON[ksRow / keySize | 0] << 24;
                } else if (keySize > 6 && ksRow % keySize == 4) {
                  t = SBOX[t >>> 24] << 24 | SBOX[t >>> 16 & 255] << 16 | SBOX[t >>> 8 & 255] << 8 | SBOX[t & 255];
                }
                keySchedule[ksRow] = keySchedule[ksRow - keySize] ^ t;
              }
            }
            var invKeySchedule = this._invKeySchedule = [];
            for (var invKsRow = 0; invKsRow < ksRows; invKsRow++) {
              var ksRow = ksRows - invKsRow;
              if (invKsRow % 4) {
                var t = keySchedule[ksRow];
              } else {
                var t = keySchedule[ksRow - 4];
              }
              if (invKsRow < 4 || ksRow <= 4) {
                invKeySchedule[invKsRow] = t;
              } else {
                invKeySchedule[invKsRow] = INV_SUB_MIX_0[SBOX[t >>> 24]] ^ INV_SUB_MIX_1[SBOX[t >>> 16 & 255]] ^ INV_SUB_MIX_2[SBOX[t >>> 8 & 255]] ^ INV_SUB_MIX_3[SBOX[t & 255]];
              }
            }
          },
          encryptBlock: function(M, offset) {
            this._doCryptBlock(M, offset, this._keySchedule, SUB_MIX_0, SUB_MIX_1, SUB_MIX_2, SUB_MIX_3, SBOX);
          },
          decryptBlock: function(M, offset) {
            var t = M[offset + 1];
            M[offset + 1] = M[offset + 3];
            M[offset + 3] = t;
            this._doCryptBlock(M, offset, this._invKeySchedule, INV_SUB_MIX_0, INV_SUB_MIX_1, INV_SUB_MIX_2, INV_SUB_MIX_3, INV_SBOX);
            var t = M[offset + 1];
            M[offset + 1] = M[offset + 3];
            M[offset + 3] = t;
          },
          _doCryptBlock: function(M, offset, keySchedule, SUB_MIX_02, SUB_MIX_12, SUB_MIX_22, SUB_MIX_32, SBOX2) {
            var nRounds = this._nRounds;
            var s0 = M[offset] ^ keySchedule[0];
            var s1 = M[offset + 1] ^ keySchedule[1];
            var s2 = M[offset + 2] ^ keySchedule[2];
            var s3 = M[offset + 3] ^ keySchedule[3];
            var ksRow = 4;
            for (var round = 1; round < nRounds; round++) {
              var t0 = SUB_MIX_02[s0 >>> 24] ^ SUB_MIX_12[s1 >>> 16 & 255] ^ SUB_MIX_22[s2 >>> 8 & 255] ^ SUB_MIX_32[s3 & 255] ^ keySchedule[ksRow++];
              var t1 = SUB_MIX_02[s1 >>> 24] ^ SUB_MIX_12[s2 >>> 16 & 255] ^ SUB_MIX_22[s3 >>> 8 & 255] ^ SUB_MIX_32[s0 & 255] ^ keySchedule[ksRow++];
              var t2 = SUB_MIX_02[s2 >>> 24] ^ SUB_MIX_12[s3 >>> 16 & 255] ^ SUB_MIX_22[s0 >>> 8 & 255] ^ SUB_MIX_32[s1 & 255] ^ keySchedule[ksRow++];
              var t3 = SUB_MIX_02[s3 >>> 24] ^ SUB_MIX_12[s0 >>> 16 & 255] ^ SUB_MIX_22[s1 >>> 8 & 255] ^ SUB_MIX_32[s2 & 255] ^ keySchedule[ksRow++];
              s0 = t0;
              s1 = t1;
              s2 = t2;
              s3 = t3;
            }
            var t0 = (SBOX2[s0 >>> 24] << 24 | SBOX2[s1 >>> 16 & 255] << 16 | SBOX2[s2 >>> 8 & 255] << 8 | SBOX2[s3 & 255]) ^ keySchedule[ksRow++];
            var t1 = (SBOX2[s1 >>> 24] << 24 | SBOX2[s2 >>> 16 & 255] << 16 | SBOX2[s3 >>> 8 & 255] << 8 | SBOX2[s0 & 255]) ^ keySchedule[ksRow++];
            var t2 = (SBOX2[s2 >>> 24] << 24 | SBOX2[s3 >>> 16 & 255] << 16 | SBOX2[s0 >>> 8 & 255] << 8 | SBOX2[s1 & 255]) ^ keySchedule[ksRow++];
            var t3 = (SBOX2[s3 >>> 24] << 24 | SBOX2[s0 >>> 16 & 255] << 16 | SBOX2[s1 >>> 8 & 255] << 8 | SBOX2[s2 & 255]) ^ keySchedule[ksRow++];
            M[offset] = t0;
            M[offset + 1] = t1;
            M[offset + 2] = t2;
            M[offset + 3] = t3;
          },
          keySize: 256 / 32
        });
        C.AES = BlockCipher._createHelper(AES);
      })();
      return CryptoJS.AES;
    });
  }
});

// node_modules/crypto-js/tripledes.js
var require_tripledes = __commonJS({
  "node_modules/crypto-js/tripledes.js"(exports, module) {
    (function(root, factory, undef) {
      if (typeof exports === "object") {
        module.exports = exports = factory(require_core(), require_enc_base64(), require_md5(), require_evpkdf(), require_cipher_core());
      } else if (typeof define === "function" && define.amd) {
        define(["./core", "./enc-base64", "./md5", "./evpkdf", "./cipher-core"], factory);
      } else {
        factory(root.CryptoJS);
      }
    })(exports, function(CryptoJS) {
      (function() {
        var C = CryptoJS;
        var C_lib = C.lib;
        var WordArray = C_lib.WordArray;
        var BlockCipher = C_lib.BlockCipher;
        var C_algo = C.algo;
        var PC1 = [
          57,
          49,
          41,
          33,
          25,
          17,
          9,
          1,
          58,
          50,
          42,
          34,
          26,
          18,
          10,
          2,
          59,
          51,
          43,
          35,
          27,
          19,
          11,
          3,
          60,
          52,
          44,
          36,
          63,
          55,
          47,
          39,
          31,
          23,
          15,
          7,
          62,
          54,
          46,
          38,
          30,
          22,
          14,
          6,
          61,
          53,
          45,
          37,
          29,
          21,
          13,
          5,
          28,
          20,
          12,
          4
        ];
        var PC2 = [
          14,
          17,
          11,
          24,
          1,
          5,
          3,
          28,
          15,
          6,
          21,
          10,
          23,
          19,
          12,
          4,
          26,
          8,
          16,
          7,
          27,
          20,
          13,
          2,
          41,
          52,
          31,
          37,
          47,
          55,
          30,
          40,
          51,
          45,
          33,
          48,
          44,
          49,
          39,
          56,
          34,
          53,
          46,
          42,
          50,
          36,
          29,
          32
        ];
        var BIT_SHIFTS = [1, 2, 4, 6, 8, 10, 12, 14, 15, 17, 19, 21, 23, 25, 27, 28];
        var SBOX_P = [
          {
            0: 8421888,
            268435456: 32768,
            536870912: 8421378,
            805306368: 2,
            1073741824: 512,
            1342177280: 8421890,
            1610612736: 8389122,
            1879048192: 8388608,
            2147483648: 514,
            2415919104: 8389120,
            2684354560: 33280,
            2952790016: 8421376,
            3221225472: 32770,
            3489660928: 8388610,
            3758096384: 0,
            4026531840: 33282,
            134217728: 0,
            402653184: 8421890,
            671088640: 33282,
            939524096: 32768,
            1207959552: 8421888,
            1476395008: 512,
            1744830464: 8421378,
            2013265920: 2,
            2281701376: 8389120,
            2550136832: 33280,
            2818572288: 8421376,
            3087007744: 8389122,
            3355443200: 8388610,
            3623878656: 32770,
            3892314112: 514,
            4160749568: 8388608,
            1: 32768,
            268435457: 2,
            536870913: 8421888,
            805306369: 8388608,
            1073741825: 8421378,
            1342177281: 33280,
            1610612737: 512,
            1879048193: 8389122,
            2147483649: 8421890,
            2415919105: 8421376,
            2684354561: 8388610,
            2952790017: 33282,
            3221225473: 514,
            3489660929: 8389120,
            3758096385: 32770,
            4026531841: 0,
            134217729: 8421890,
            402653185: 8421376,
            671088641: 8388608,
            939524097: 512,
            1207959553: 32768,
            1476395009: 8388610,
            1744830465: 2,
            2013265921: 33282,
            2281701377: 32770,
            2550136833: 8389122,
            2818572289: 514,
            3087007745: 8421888,
            3355443201: 8389120,
            3623878657: 0,
            3892314113: 33280,
            4160749569: 8421378
          },
          {
            0: 1074282512,
            16777216: 16384,
            33554432: 524288,
            50331648: 1074266128,
            67108864: 1073741840,
            83886080: 1074282496,
            100663296: 1073758208,
            117440512: 16,
            134217728: 540672,
            150994944: 1073758224,
            167772160: 1073741824,
            184549376: 540688,
            201326592: 524304,
            218103808: 0,
            234881024: 16400,
            251658240: 1074266112,
            8388608: 1073758208,
            25165824: 540688,
            41943040: 16,
            58720256: 1073758224,
            75497472: 1074282512,
            92274688: 1073741824,
            109051904: 524288,
            125829120: 1074266128,
            142606336: 524304,
            159383552: 0,
            176160768: 16384,
            192937984: 1074266112,
            209715200: 1073741840,
            226492416: 540672,
            243269632: 1074282496,
            260046848: 16400,
            268435456: 0,
            285212672: 1074266128,
            301989888: 1073758224,
            318767104: 1074282496,
            335544320: 1074266112,
            352321536: 16,
            369098752: 540688,
            385875968: 16384,
            402653184: 16400,
            419430400: 524288,
            436207616: 524304,
            452984832: 1073741840,
            469762048: 540672,
            486539264: 1073758208,
            503316480: 1073741824,
            520093696: 1074282512,
            276824064: 540688,
            293601280: 524288,
            310378496: 1074266112,
            327155712: 16384,
            343932928: 1073758208,
            360710144: 1074282512,
            377487360: 16,
            394264576: 1073741824,
            411041792: 1074282496,
            427819008: 1073741840,
            444596224: 1073758224,
            461373440: 524304,
            478150656: 0,
            494927872: 16400,
            511705088: 1074266128,
            528482304: 540672
          },
          {
            0: 260,
            1048576: 0,
            2097152: 67109120,
            3145728: 65796,
            4194304: 65540,
            5242880: 67108868,
            6291456: 67174660,
            7340032: 67174400,
            8388608: 67108864,
            9437184: 67174656,
            10485760: 65792,
            11534336: 67174404,
            12582912: 67109124,
            13631488: 65536,
            14680064: 4,
            15728640: 256,
            524288: 67174656,
            1572864: 67174404,
            2621440: 0,
            3670016: 67109120,
            4718592: 67108868,
            5767168: 65536,
            6815744: 65540,
            7864320: 260,
            8912896: 4,
            9961472: 256,
            11010048: 67174400,
            12058624: 65796,
            13107200: 65792,
            14155776: 67109124,
            15204352: 67174660,
            16252928: 67108864,
            16777216: 67174656,
            17825792: 65540,
            18874368: 65536,
            19922944: 67109120,
            20971520: 256,
            22020096: 67174660,
            23068672: 67108868,
            24117248: 0,
            25165824: 67109124,
            26214400: 67108864,
            27262976: 4,
            28311552: 65792,
            29360128: 67174400,
            30408704: 260,
            31457280: 65796,
            32505856: 67174404,
            17301504: 67108864,
            18350080: 260,
            19398656: 67174656,
            20447232: 0,
            21495808: 65540,
            22544384: 67109120,
            23592960: 256,
            24641536: 67174404,
            25690112: 65536,
            26738688: 67174660,
            27787264: 65796,
            28835840: 67108868,
            29884416: 67109124,
            30932992: 67174400,
            31981568: 4,
            33030144: 65792
          },
          {
            0: 2151682048,
            65536: 2147487808,
            131072: 4198464,
            196608: 2151677952,
            262144: 0,
            327680: 4198400,
            393216: 2147483712,
            458752: 4194368,
            524288: 2147483648,
            589824: 4194304,
            655360: 64,
            720896: 2147487744,
            786432: 2151678016,
            851968: 4160,
            917504: 4096,
            983040: 2151682112,
            32768: 2147487808,
            98304: 64,
            163840: 2151678016,
            229376: 2147487744,
            294912: 4198400,
            360448: 2151682112,
            425984: 0,
            491520: 2151677952,
            557056: 4096,
            622592: 2151682048,
            688128: 4194304,
            753664: 4160,
            819200: 2147483648,
            884736: 4194368,
            950272: 4198464,
            1015808: 2147483712,
            1048576: 4194368,
            1114112: 4198400,
            1179648: 2147483712,
            1245184: 0,
            1310720: 4160,
            1376256: 2151678016,
            1441792: 2151682048,
            1507328: 2147487808,
            1572864: 2151682112,
            1638400: 2147483648,
            1703936: 2151677952,
            1769472: 4198464,
            1835008: 2147487744,
            1900544: 4194304,
            1966080: 64,
            2031616: 4096,
            1081344: 2151677952,
            1146880: 2151682112,
            1212416: 0,
            1277952: 4198400,
            1343488: 4194368,
            1409024: 2147483648,
            1474560: 2147487808,
            1540096: 64,
            1605632: 2147483712,
            1671168: 4096,
            1736704: 2147487744,
            1802240: 2151678016,
            1867776: 4160,
            1933312: 2151682048,
            1998848: 4194304,
            2064384: 4198464
          },
          {
            0: 128,
            4096: 17039360,
            8192: 262144,
            12288: 536870912,
            16384: 537133184,
            20480: 16777344,
            24576: 553648256,
            28672: 262272,
            32768: 16777216,
            36864: 537133056,
            40960: 536871040,
            45056: 553910400,
            49152: 553910272,
            53248: 0,
            57344: 17039488,
            61440: 553648128,
            2048: 17039488,
            6144: 553648256,
            10240: 128,
            14336: 17039360,
            18432: 262144,
            22528: 537133184,
            26624: 553910272,
            30720: 536870912,
            34816: 537133056,
            38912: 0,
            43008: 553910400,
            47104: 16777344,
            51200: 536871040,
            55296: 553648128,
            59392: 16777216,
            63488: 262272,
            65536: 262144,
            69632: 128,
            73728: 536870912,
            77824: 553648256,
            81920: 16777344,
            86016: 553910272,
            90112: 537133184,
            94208: 16777216,
            98304: 553910400,
            102400: 553648128,
            106496: 17039360,
            110592: 537133056,
            114688: 262272,
            118784: 536871040,
            122880: 0,
            126976: 17039488,
            67584: 553648256,
            71680: 16777216,
            75776: 17039360,
            79872: 537133184,
            83968: 536870912,
            88064: 17039488,
            92160: 128,
            96256: 553910272,
            100352: 262272,
            104448: 553910400,
            108544: 0,
            112640: 553648128,
            116736: 16777344,
            120832: 262144,
            124928: 537133056,
            129024: 536871040
          },
          {
            0: 268435464,
            256: 8192,
            512: 270532608,
            768: 270540808,
            1024: 268443648,
            1280: 2097152,
            1536: 2097160,
            1792: 268435456,
            2048: 0,
            2304: 268443656,
            2560: 2105344,
            2816: 8,
            3072: 270532616,
            3328: 2105352,
            3584: 8200,
            3840: 270540800,
            128: 270532608,
            384: 270540808,
            640: 8,
            896: 2097152,
            1152: 2105352,
            1408: 268435464,
            1664: 268443648,
            1920: 8200,
            2176: 2097160,
            2432: 8192,
            2688: 268443656,
            2944: 270532616,
            3200: 0,
            3456: 270540800,
            3712: 2105344,
            3968: 268435456,
            4096: 268443648,
            4352: 270532616,
            4608: 270540808,
            4864: 8200,
            5120: 2097152,
            5376: 268435456,
            5632: 268435464,
            5888: 2105344,
            6144: 2105352,
            6400: 0,
            6656: 8,
            6912: 270532608,
            7168: 8192,
            7424: 268443656,
            7680: 270540800,
            7936: 2097160,
            4224: 8,
            4480: 2105344,
            4736: 2097152,
            4992: 268435464,
            5248: 268443648,
            5504: 8200,
            5760: 270540808,
            6016: 270532608,
            6272: 270540800,
            6528: 270532616,
            6784: 8192,
            7040: 2105352,
            7296: 2097160,
            7552: 0,
            7808: 268435456,
            8064: 268443656
          },
          {
            0: 1048576,
            16: 33555457,
            32: 1024,
            48: 1049601,
            64: 34604033,
            80: 0,
            96: 1,
            112: 34603009,
            128: 33555456,
            144: 1048577,
            160: 33554433,
            176: 34604032,
            192: 34603008,
            208: 1025,
            224: 1049600,
            240: 33554432,
            8: 34603009,
            24: 0,
            40: 33555457,
            56: 34604032,
            72: 1048576,
            88: 33554433,
            104: 33554432,
            120: 1025,
            136: 1049601,
            152: 33555456,
            168: 34603008,
            184: 1048577,
            200: 1024,
            216: 34604033,
            232: 1,
            248: 1049600,
            256: 33554432,
            272: 1048576,
            288: 33555457,
            304: 34603009,
            320: 1048577,
            336: 33555456,
            352: 34604032,
            368: 1049601,
            384: 1025,
            400: 34604033,
            416: 1049600,
            432: 1,
            448: 0,
            464: 34603008,
            480: 33554433,
            496: 1024,
            264: 1049600,
            280: 33555457,
            296: 34603009,
            312: 1,
            328: 33554432,
            344: 1048576,
            360: 1025,
            376: 34604032,
            392: 33554433,
            408: 34603008,
            424: 0,
            440: 34604033,
            456: 1049601,
            472: 1024,
            488: 33555456,
            504: 1048577
          },
          {
            0: 134219808,
            1: 131072,
            2: 134217728,
            3: 32,
            4: 131104,
            5: 134350880,
            6: 134350848,
            7: 2048,
            8: 134348800,
            9: 134219776,
            10: 133120,
            11: 134348832,
            12: 2080,
            13: 0,
            14: 134217760,
            15: 133152,
            2147483648: 2048,
            2147483649: 134350880,
            2147483650: 134219808,
            2147483651: 134217728,
            2147483652: 134348800,
            2147483653: 133120,
            2147483654: 133152,
            2147483655: 32,
            2147483656: 134217760,
            2147483657: 2080,
            2147483658: 131104,
            2147483659: 134350848,
            2147483660: 0,
            2147483661: 134348832,
            2147483662: 134219776,
            2147483663: 131072,
            16: 133152,
            17: 134350848,
            18: 32,
            19: 2048,
            20: 134219776,
            21: 134217760,
            22: 134348832,
            23: 131072,
            24: 0,
            25: 131104,
            26: 134348800,
            27: 134219808,
            28: 134350880,
            29: 133120,
            30: 2080,
            31: 134217728,
            2147483664: 131072,
            2147483665: 2048,
            2147483666: 134348832,
            2147483667: 133152,
            2147483668: 32,
            2147483669: 134348800,
            2147483670: 134217728,
            2147483671: 134219808,
            2147483672: 134350880,
            2147483673: 134217760,
            2147483674: 134219776,
            2147483675: 0,
            2147483676: 133120,
            2147483677: 2080,
            2147483678: 131104,
            2147483679: 134350848
          }
        ];
        var SBOX_MASK = [
          4160749569,
          528482304,
          33030144,
          2064384,
          129024,
          8064,
          504,
          2147483679
        ];
        var DES = C_algo.DES = BlockCipher.extend({
          _doReset: function() {
            var key = this._key;
            var keyWords = key.words;
            var keyBits = [];
            for (var i = 0; i < 56; i++) {
              var keyBitPos = PC1[i] - 1;
              keyBits[i] = keyWords[keyBitPos >>> 5] >>> 31 - keyBitPos % 32 & 1;
            }
            var subKeys = this._subKeys = [];
            for (var nSubKey = 0; nSubKey < 16; nSubKey++) {
              var subKey = subKeys[nSubKey] = [];
              var bitShift = BIT_SHIFTS[nSubKey];
              for (var i = 0; i < 24; i++) {
                subKey[i / 6 | 0] |= keyBits[(PC2[i] - 1 + bitShift) % 28] << 31 - i % 6;
                subKey[4 + (i / 6 | 0)] |= keyBits[28 + (PC2[i + 24] - 1 + bitShift) % 28] << 31 - i % 6;
              }
              subKey[0] = subKey[0] << 1 | subKey[0] >>> 31;
              for (var i = 1; i < 7; i++) {
                subKey[i] = subKey[i] >>> (i - 1) * 4 + 3;
              }
              subKey[7] = subKey[7] << 5 | subKey[7] >>> 27;
            }
            var invSubKeys = this._invSubKeys = [];
            for (var i = 0; i < 16; i++) {
              invSubKeys[i] = subKeys[15 - i];
            }
          },
          encryptBlock: function(M, offset) {
            this._doCryptBlock(M, offset, this._subKeys);
          },
          decryptBlock: function(M, offset) {
            this._doCryptBlock(M, offset, this._invSubKeys);
          },
          _doCryptBlock: function(M, offset, subKeys) {
            this._lBlock = M[offset];
            this._rBlock = M[offset + 1];
            exchangeLR.call(this, 4, 252645135);
            exchangeLR.call(this, 16, 65535);
            exchangeRL.call(this, 2, 858993459);
            exchangeRL.call(this, 8, 16711935);
            exchangeLR.call(this, 1, 1431655765);
            for (var round = 0; round < 16; round++) {
              var subKey = subKeys[round];
              var lBlock = this._lBlock;
              var rBlock = this._rBlock;
              var f3 = 0;
              for (var i = 0; i < 8; i++) {
                f3 |= SBOX_P[i][((rBlock ^ subKey[i]) & SBOX_MASK[i]) >>> 0];
              }
              this._lBlock = rBlock;
              this._rBlock = lBlock ^ f3;
            }
            var t = this._lBlock;
            this._lBlock = this._rBlock;
            this._rBlock = t;
            exchangeLR.call(this, 1, 1431655765);
            exchangeRL.call(this, 8, 16711935);
            exchangeRL.call(this, 2, 858993459);
            exchangeLR.call(this, 16, 65535);
            exchangeLR.call(this, 4, 252645135);
            M[offset] = this._lBlock;
            M[offset + 1] = this._rBlock;
          },
          keySize: 64 / 32,
          ivSize: 64 / 32,
          blockSize: 64 / 32
        });
        function exchangeLR(offset, mask) {
          var t = (this._lBlock >>> offset ^ this._rBlock) & mask;
          this._rBlock ^= t;
          this._lBlock ^= t << offset;
        }
        function exchangeRL(offset, mask) {
          var t = (this._rBlock >>> offset ^ this._lBlock) & mask;
          this._lBlock ^= t;
          this._rBlock ^= t << offset;
        }
        C.DES = BlockCipher._createHelper(DES);
        var TripleDES = C_algo.TripleDES = BlockCipher.extend({
          _doReset: function() {
            var key = this._key;
            var keyWords = key.words;
            this._des1 = DES.createEncryptor(WordArray.create(keyWords.slice(0, 2)));
            this._des2 = DES.createEncryptor(WordArray.create(keyWords.slice(2, 4)));
            this._des3 = DES.createEncryptor(WordArray.create(keyWords.slice(4, 6)));
          },
          encryptBlock: function(M, offset) {
            this._des1.encryptBlock(M, offset);
            this._des2.decryptBlock(M, offset);
            this._des3.encryptBlock(M, offset);
          },
          decryptBlock: function(M, offset) {
            this._des3.decryptBlock(M, offset);
            this._des2.encryptBlock(M, offset);
            this._des1.decryptBlock(M, offset);
          },
          keySize: 192 / 32,
          ivSize: 64 / 32,
          blockSize: 64 / 32
        });
        C.TripleDES = BlockCipher._createHelper(TripleDES);
      })();
      return CryptoJS.TripleDES;
    });
  }
});

// node_modules/crypto-js/rc4.js
var require_rc4 = __commonJS({
  "node_modules/crypto-js/rc4.js"(exports, module) {
    (function(root, factory, undef) {
      if (typeof exports === "object") {
        module.exports = exports = factory(require_core(), require_enc_base64(), require_md5(), require_evpkdf(), require_cipher_core());
      } else if (typeof define === "function" && define.amd) {
        define(["./core", "./enc-base64", "./md5", "./evpkdf", "./cipher-core"], factory);
      } else {
        factory(root.CryptoJS);
      }
    })(exports, function(CryptoJS) {
      (function() {
        var C = CryptoJS;
        var C_lib = C.lib;
        var StreamCipher = C_lib.StreamCipher;
        var C_algo = C.algo;
        var RC4 = C_algo.RC4 = StreamCipher.extend({
          _doReset: function() {
            var key = this._key;
            var keyWords = key.words;
            var keySigBytes = key.sigBytes;
            var S = this._S = [];
            for (var i = 0; i < 256; i++) {
              S[i] = i;
            }
            for (var i = 0, j = 0; i < 256; i++) {
              var keyByteIndex = i % keySigBytes;
              var keyByte = keyWords[keyByteIndex >>> 2] >>> 24 - keyByteIndex % 4 * 8 & 255;
              j = (j + S[i] + keyByte) % 256;
              var t = S[i];
              S[i] = S[j];
              S[j] = t;
            }
            this._i = this._j = 0;
          },
          _doProcessBlock: function(M, offset) {
            M[offset] ^= generateKeystreamWord.call(this);
          },
          keySize: 256 / 32,
          ivSize: 0
        });
        function generateKeystreamWord() {
          var S = this._S;
          var i = this._i;
          var j = this._j;
          var keystreamWord = 0;
          for (var n = 0; n < 4; n++) {
            i = (i + 1) % 256;
            j = (j + S[i]) % 256;
            var t = S[i];
            S[i] = S[j];
            S[j] = t;
            keystreamWord |= S[(S[i] + S[j]) % 256] << 24 - n * 8;
          }
          this._i = i;
          this._j = j;
          return keystreamWord;
        }
        C.RC4 = StreamCipher._createHelper(RC4);
        var RC4Drop = C_algo.RC4Drop = RC4.extend({
          cfg: RC4.cfg.extend({
            drop: 192
          }),
          _doReset: function() {
            RC4._doReset.call(this);
            for (var i = this.cfg.drop; i > 0; i--) {
              generateKeystreamWord.call(this);
            }
          }
        });
        C.RC4Drop = StreamCipher._createHelper(RC4Drop);
      })();
      return CryptoJS.RC4;
    });
  }
});

// node_modules/crypto-js/rabbit.js
var require_rabbit = __commonJS({
  "node_modules/crypto-js/rabbit.js"(exports, module) {
    (function(root, factory, undef) {
      if (typeof exports === "object") {
        module.exports = exports = factory(require_core(), require_enc_base64(), require_md5(), require_evpkdf(), require_cipher_core());
      } else if (typeof define === "function" && define.amd) {
        define(["./core", "./enc-base64", "./md5", "./evpkdf", "./cipher-core"], factory);
      } else {
        factory(root.CryptoJS);
      }
    })(exports, function(CryptoJS) {
      (function() {
        var C = CryptoJS;
        var C_lib = C.lib;
        var StreamCipher = C_lib.StreamCipher;
        var C_algo = C.algo;
        var S = [];
        var C_ = [];
        var G = [];
        var Rabbit = C_algo.Rabbit = StreamCipher.extend({
          _doReset: function() {
            var K = this._key.words;
            var iv = this.cfg.iv;
            for (var i = 0; i < 4; i++) {
              K[i] = (K[i] << 8 | K[i] >>> 24) & 16711935 | (K[i] << 24 | K[i] >>> 8) & 4278255360;
            }
            var X = this._X = [
              K[0],
              K[3] << 16 | K[2] >>> 16,
              K[1],
              K[0] << 16 | K[3] >>> 16,
              K[2],
              K[1] << 16 | K[0] >>> 16,
              K[3],
              K[2] << 16 | K[1] >>> 16
            ];
            var C2 = this._C = [
              K[2] << 16 | K[2] >>> 16,
              K[0] & 4294901760 | K[1] & 65535,
              K[3] << 16 | K[3] >>> 16,
              K[1] & 4294901760 | K[2] & 65535,
              K[0] << 16 | K[0] >>> 16,
              K[2] & 4294901760 | K[3] & 65535,
              K[1] << 16 | K[1] >>> 16,
              K[3] & 4294901760 | K[0] & 65535
            ];
            this._b = 0;
            for (var i = 0; i < 4; i++) {
              nextState.call(this);
            }
            for (var i = 0; i < 8; i++) {
              C2[i] ^= X[i + 4 & 7];
            }
            if (iv) {
              var IV = iv.words;
              var IV_0 = IV[0];
              var IV_1 = IV[1];
              var i0 = (IV_0 << 8 | IV_0 >>> 24) & 16711935 | (IV_0 << 24 | IV_0 >>> 8) & 4278255360;
              var i2 = (IV_1 << 8 | IV_1 >>> 24) & 16711935 | (IV_1 << 24 | IV_1 >>> 8) & 4278255360;
              var i1 = i0 >>> 16 | i2 & 4294901760;
              var i3 = i2 << 16 | i0 & 65535;
              C2[0] ^= i0;
              C2[1] ^= i1;
              C2[2] ^= i2;
              C2[3] ^= i3;
              C2[4] ^= i0;
              C2[5] ^= i1;
              C2[6] ^= i2;
              C2[7] ^= i3;
              for (var i = 0; i < 4; i++) {
                nextState.call(this);
              }
            }
          },
          _doProcessBlock: function(M, offset) {
            var X = this._X;
            nextState.call(this);
            S[0] = X[0] ^ X[5] >>> 16 ^ X[3] << 16;
            S[1] = X[2] ^ X[7] >>> 16 ^ X[5] << 16;
            S[2] = X[4] ^ X[1] >>> 16 ^ X[7] << 16;
            S[3] = X[6] ^ X[3] >>> 16 ^ X[1] << 16;
            for (var i = 0; i < 4; i++) {
              S[i] = (S[i] << 8 | S[i] >>> 24) & 16711935 | (S[i] << 24 | S[i] >>> 8) & 4278255360;
              M[offset + i] ^= S[i];
            }
          },
          blockSize: 128 / 32,
          ivSize: 64 / 32
        });
        function nextState() {
          var X = this._X;
          var C2 = this._C;
          for (var i = 0; i < 8; i++) {
            C_[i] = C2[i];
          }
          C2[0] = C2[0] + 1295307597 + this._b | 0;
          C2[1] = C2[1] + 3545052371 + (C2[0] >>> 0 < C_[0] >>> 0 ? 1 : 0) | 0;
          C2[2] = C2[2] + 886263092 + (C2[1] >>> 0 < C_[1] >>> 0 ? 1 : 0) | 0;
          C2[3] = C2[3] + 1295307597 + (C2[2] >>> 0 < C_[2] >>> 0 ? 1 : 0) | 0;
          C2[4] = C2[4] + 3545052371 + (C2[3] >>> 0 < C_[3] >>> 0 ? 1 : 0) | 0;
          C2[5] = C2[5] + 886263092 + (C2[4] >>> 0 < C_[4] >>> 0 ? 1 : 0) | 0;
          C2[6] = C2[6] + 1295307597 + (C2[5] >>> 0 < C_[5] >>> 0 ? 1 : 0) | 0;
          C2[7] = C2[7] + 3545052371 + (C2[6] >>> 0 < C_[6] >>> 0 ? 1 : 0) | 0;
          this._b = C2[7] >>> 0 < C_[7] >>> 0 ? 1 : 0;
          for (var i = 0; i < 8; i++) {
            var gx = X[i] + C2[i];
            var ga = gx & 65535;
            var gb = gx >>> 16;
            var gh = ((ga * ga >>> 17) + ga * gb >>> 15) + gb * gb;
            var gl = ((gx & 4294901760) * gx | 0) + ((gx & 65535) * gx | 0);
            G[i] = gh ^ gl;
          }
          X[0] = G[0] + (G[7] << 16 | G[7] >>> 16) + (G[6] << 16 | G[6] >>> 16) | 0;
          X[1] = G[1] + (G[0] << 8 | G[0] >>> 24) + G[7] | 0;
          X[2] = G[2] + (G[1] << 16 | G[1] >>> 16) + (G[0] << 16 | G[0] >>> 16) | 0;
          X[3] = G[3] + (G[2] << 8 | G[2] >>> 24) + G[1] | 0;
          X[4] = G[4] + (G[3] << 16 | G[3] >>> 16) + (G[2] << 16 | G[2] >>> 16) | 0;
          X[5] = G[5] + (G[4] << 8 | G[4] >>> 24) + G[3] | 0;
          X[6] = G[6] + (G[5] << 16 | G[5] >>> 16) + (G[4] << 16 | G[4] >>> 16) | 0;
          X[7] = G[7] + (G[6] << 8 | G[6] >>> 24) + G[5] | 0;
        }
        C.Rabbit = StreamCipher._createHelper(Rabbit);
      })();
      return CryptoJS.Rabbit;
    });
  }
});

// node_modules/crypto-js/rabbit-legacy.js
var require_rabbit_legacy = __commonJS({
  "node_modules/crypto-js/rabbit-legacy.js"(exports, module) {
    (function(root, factory, undef) {
      if (typeof exports === "object") {
        module.exports = exports = factory(require_core(), require_enc_base64(), require_md5(), require_evpkdf(), require_cipher_core());
      } else if (typeof define === "function" && define.amd) {
        define(["./core", "./enc-base64", "./md5", "./evpkdf", "./cipher-core"], factory);
      } else {
        factory(root.CryptoJS);
      }
    })(exports, function(CryptoJS) {
      (function() {
        var C = CryptoJS;
        var C_lib = C.lib;
        var StreamCipher = C_lib.StreamCipher;
        var C_algo = C.algo;
        var S = [];
        var C_ = [];
        var G = [];
        var RabbitLegacy = C_algo.RabbitLegacy = StreamCipher.extend({
          _doReset: function() {
            var K = this._key.words;
            var iv = this.cfg.iv;
            var X = this._X = [
              K[0],
              K[3] << 16 | K[2] >>> 16,
              K[1],
              K[0] << 16 | K[3] >>> 16,
              K[2],
              K[1] << 16 | K[0] >>> 16,
              K[3],
              K[2] << 16 | K[1] >>> 16
            ];
            var C2 = this._C = [
              K[2] << 16 | K[2] >>> 16,
              K[0] & 4294901760 | K[1] & 65535,
              K[3] << 16 | K[3] >>> 16,
              K[1] & 4294901760 | K[2] & 65535,
              K[0] << 16 | K[0] >>> 16,
              K[2] & 4294901760 | K[3] & 65535,
              K[1] << 16 | K[1] >>> 16,
              K[3] & 4294901760 | K[0] & 65535
            ];
            this._b = 0;
            for (var i = 0; i < 4; i++) {
              nextState.call(this);
            }
            for (var i = 0; i < 8; i++) {
              C2[i] ^= X[i + 4 & 7];
            }
            if (iv) {
              var IV = iv.words;
              var IV_0 = IV[0];
              var IV_1 = IV[1];
              var i0 = (IV_0 << 8 | IV_0 >>> 24) & 16711935 | (IV_0 << 24 | IV_0 >>> 8) & 4278255360;
              var i2 = (IV_1 << 8 | IV_1 >>> 24) & 16711935 | (IV_1 << 24 | IV_1 >>> 8) & 4278255360;
              var i1 = i0 >>> 16 | i2 & 4294901760;
              var i3 = i2 << 16 | i0 & 65535;
              C2[0] ^= i0;
              C2[1] ^= i1;
              C2[2] ^= i2;
              C2[3] ^= i3;
              C2[4] ^= i0;
              C2[5] ^= i1;
              C2[6] ^= i2;
              C2[7] ^= i3;
              for (var i = 0; i < 4; i++) {
                nextState.call(this);
              }
            }
          },
          _doProcessBlock: function(M, offset) {
            var X = this._X;
            nextState.call(this);
            S[0] = X[0] ^ X[5] >>> 16 ^ X[3] << 16;
            S[1] = X[2] ^ X[7] >>> 16 ^ X[5] << 16;
            S[2] = X[4] ^ X[1] >>> 16 ^ X[7] << 16;
            S[3] = X[6] ^ X[3] >>> 16 ^ X[1] << 16;
            for (var i = 0; i < 4; i++) {
              S[i] = (S[i] << 8 | S[i] >>> 24) & 16711935 | (S[i] << 24 | S[i] >>> 8) & 4278255360;
              M[offset + i] ^= S[i];
            }
          },
          blockSize: 128 / 32,
          ivSize: 64 / 32
        });
        function nextState() {
          var X = this._X;
          var C2 = this._C;
          for (var i = 0; i < 8; i++) {
            C_[i] = C2[i];
          }
          C2[0] = C2[0] + 1295307597 + this._b | 0;
          C2[1] = C2[1] + 3545052371 + (C2[0] >>> 0 < C_[0] >>> 0 ? 1 : 0) | 0;
          C2[2] = C2[2] + 886263092 + (C2[1] >>> 0 < C_[1] >>> 0 ? 1 : 0) | 0;
          C2[3] = C2[3] + 1295307597 + (C2[2] >>> 0 < C_[2] >>> 0 ? 1 : 0) | 0;
          C2[4] = C2[4] + 3545052371 + (C2[3] >>> 0 < C_[3] >>> 0 ? 1 : 0) | 0;
          C2[5] = C2[5] + 886263092 + (C2[4] >>> 0 < C_[4] >>> 0 ? 1 : 0) | 0;
          C2[6] = C2[6] + 1295307597 + (C2[5] >>> 0 < C_[5] >>> 0 ? 1 : 0) | 0;
          C2[7] = C2[7] + 3545052371 + (C2[6] >>> 0 < C_[6] >>> 0 ? 1 : 0) | 0;
          this._b = C2[7] >>> 0 < C_[7] >>> 0 ? 1 : 0;
          for (var i = 0; i < 8; i++) {
            var gx = X[i] + C2[i];
            var ga = gx & 65535;
            var gb = gx >>> 16;
            var gh = ((ga * ga >>> 17) + ga * gb >>> 15) + gb * gb;
            var gl = ((gx & 4294901760) * gx | 0) + ((gx & 65535) * gx | 0);
            G[i] = gh ^ gl;
          }
          X[0] = G[0] + (G[7] << 16 | G[7] >>> 16) + (G[6] << 16 | G[6] >>> 16) | 0;
          X[1] = G[1] + (G[0] << 8 | G[0] >>> 24) + G[7] | 0;
          X[2] = G[2] + (G[1] << 16 | G[1] >>> 16) + (G[0] << 16 | G[0] >>> 16) | 0;
          X[3] = G[3] + (G[2] << 8 | G[2] >>> 24) + G[1] | 0;
          X[4] = G[4] + (G[3] << 16 | G[3] >>> 16) + (G[2] << 16 | G[2] >>> 16) | 0;
          X[5] = G[5] + (G[4] << 8 | G[4] >>> 24) + G[3] | 0;
          X[6] = G[6] + (G[5] << 16 | G[5] >>> 16) + (G[4] << 16 | G[4] >>> 16) | 0;
          X[7] = G[7] + (G[6] << 8 | G[6] >>> 24) + G[5] | 0;
        }
        C.RabbitLegacy = StreamCipher._createHelper(RabbitLegacy);
      })();
      return CryptoJS.RabbitLegacy;
    });
  }
});

// node_modules/crypto-js/index.js
var require_crypto_js = __commonJS({
  "node_modules/crypto-js/index.js"(exports, module) {
    (function(root, factory, undef) {
      if (typeof exports === "object") {
        module.exports = exports = factory(require_core(), require_x64_core(), require_lib_typedarrays(), require_enc_utf16(), require_enc_base64(), require_md5(), require_sha1(), require_sha256(), require_sha224(), require_sha512(), require_sha384(), require_sha3(), require_ripemd160(), require_hmac(), require_pbkdf2(), require_evpkdf(), require_cipher_core(), require_mode_cfb(), require_mode_ctr(), require_mode_ctr_gladman(), require_mode_ofb(), require_mode_ecb(), require_pad_ansix923(), require_pad_iso10126(), require_pad_iso97971(), require_pad_zeropadding(), require_pad_nopadding(), require_format_hex(), require_aes(), require_tripledes(), require_rc4(), require_rabbit(), require_rabbit_legacy());
      } else if (typeof define === "function" && define.amd) {
        define(["./core", "./x64-core", "./lib-typedarrays", "./enc-utf16", "./enc-base64", "./md5", "./sha1", "./sha256", "./sha224", "./sha512", "./sha384", "./sha3", "./ripemd160", "./hmac", "./pbkdf2", "./evpkdf", "./cipher-core", "./mode-cfb", "./mode-ctr", "./mode-ctr-gladman", "./mode-ofb", "./mode-ecb", "./pad-ansix923", "./pad-iso10126", "./pad-iso97971", "./pad-zeropadding", "./pad-nopadding", "./format-hex", "./aes", "./tripledes", "./rc4", "./rabbit", "./rabbit-legacy"], factory);
      } else {
        root.CryptoJS = factory(root.CryptoJS);
      }
    })(exports, function(CryptoJS) {
      return CryptoJS;
    });
  }
});

// node_modules/merkletreejs/dist/Base.js
var require_Base = __commonJS({
  "node_modules/merkletreejs/dist/Base.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod2) {
      return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Base = void 0;
    var buffer_1 = require_buffer();
    var crypto_js_1 = __importDefault(require_crypto_js());
    var Base = class {
      print() {
        Base.print(this);
      }
      _bufferIndexOf(array, element) {
        for (let i = 0; i < array.length; i++) {
          if (element.equals(array[i])) {
            return i;
          }
        }
        return -1;
      }
      static bufferify(value) {
        if (!buffer_1.Buffer.isBuffer(value)) {
          if (typeof value === "object" && value.words) {
            return buffer_1.Buffer.from(value.toString(crypto_js_1.default.enc.Hex), "hex");
          } else if (Base.isHexString(value)) {
            return buffer_1.Buffer.from(value.replace(/^0x/, ""), "hex");
          } else if (typeof value === "string") {
            return buffer_1.Buffer.from(value);
          } else if (typeof value === "number") {
            let s = value.toString();
            if (s.length % 2) {
              s = `0${s}`;
            }
            return buffer_1.Buffer.from(s, "hex");
          } else if (ArrayBuffer.isView(value)) {
            return buffer_1.Buffer.from(value.buffer, value.byteOffset, value.byteLength);
          }
        }
        return value;
      }
      static isHexString(v) {
        return typeof v === "string" && /^(0x)?[0-9A-Fa-f]*$/.test(v);
      }
      static print(tree) {
        console.log(tree.toString());
      }
      bufferToHex(value, withPrefix = true) {
        return Base.bufferToHex(value, withPrefix);
      }
      static bufferToHex(value, withPrefix = true) {
        return `${withPrefix ? "0x" : ""}${(value || buffer_1.Buffer.alloc(0)).toString("hex")}`;
      }
      bufferify(value) {
        return Base.bufferify(value);
      }
      bufferifyFn(f3) {
        return (value) => {
          const v = f3(value);
          if (buffer_1.Buffer.isBuffer(v)) {
            return v;
          }
          if (this._isHexString(v)) {
            return buffer_1.Buffer.from(v.replace("0x", ""), "hex");
          }
          if (typeof v === "string") {
            return buffer_1.Buffer.from(v);
          }
          if (ArrayBuffer.isView(v)) {
            return buffer_1.Buffer.from(v.buffer, v.byteOffset, v.byteLength);
          }
          return buffer_1.Buffer.from(f3(crypto_js_1.default.enc.Hex.parse(value.toString("hex"))).toString(crypto_js_1.default.enc.Hex), "hex");
        };
      }
      _isHexString(value) {
        return Base.isHexString(value);
      }
      _log2(n) {
        return n === 1 ? 0 : 1 + this._log2(n / 2 | 0);
      }
      _zip(a, b) {
        return a.map((e, i) => [e, b[i]]);
      }
    };
    exports.Base = Base;
    exports.default = Base;
  }
});

// node_modules/merkletreejs/dist/MerkleTree.js
var require_MerkleTree = __commonJS({
  "node_modules/merkletreejs/dist/MerkleTree.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod2) {
      return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.MerkleTree = void 0;
    var buffer_1 = require_buffer();
    var buffer_reverse_1 = __importDefault(require_buffer_reverse());
    var sha256_1 = __importDefault(require_sha256());
    var treeify_1 = __importDefault(require_treeify());
    var Base_1 = __importDefault(require_Base());
    var MerkleTree2 = class extends Base_1.default {
      constructor(leaves, hashFn = sha256_1.default, options = {}) {
        super();
        this.duplicateOdd = false;
        this.hashLeaves = false;
        this.isBitcoinTree = false;
        this.leaves = [];
        this.layers = [];
        this.sortLeaves = false;
        this.sortPairs = false;
        this.sort = false;
        this.fillDefaultHash = null;
        this.isBitcoinTree = !!options.isBitcoinTree;
        this.hashLeaves = !!options.hashLeaves;
        this.sortLeaves = !!options.sortLeaves;
        this.sortPairs = !!options.sortPairs;
        if (options.fillDefaultHash) {
          if (typeof options.fillDefaultHash === "function") {
            this.fillDefaultHash = options.fillDefaultHash;
          } else if (buffer_1.Buffer.isBuffer(options.fillDefaultHash) || typeof options.fillDefaultHash === "string") {
            this.fillDefaultHash = (idx, hashFn2) => options.fillDefaultHash;
          } else {
            throw new Error('method "fillDefaultHash" must be a function, Buffer, or string');
          }
        }
        this.sort = !!options.sort;
        if (this.sort) {
          this.sortLeaves = true;
          this.sortPairs = true;
        }
        this.duplicateOdd = !!options.duplicateOdd;
        this.hashFn = this.bufferifyFn(hashFn);
        this.processLeaves(leaves);
      }
      processLeaves(leaves) {
        if (this.hashLeaves) {
          leaves = leaves.map(this.hashFn);
        }
        this.leaves = leaves.map(this.bufferify);
        if (this.sortLeaves) {
          this.leaves = this.leaves.sort(buffer_1.Buffer.compare);
        }
        if (this.fillDefaultHash) {
          for (let i = 0; i < Math.pow(2, Math.ceil(Math.log2(this.leaves.length))); i++) {
            if (i >= this.leaves.length) {
              this.leaves.push(this.bufferify(this.fillDefaultHash(i, this.hashFn)));
            }
          }
        }
        this.layers = [this.leaves];
        this._createHashes(this.leaves);
      }
      _createHashes(nodes) {
        while (nodes.length > 1) {
          const layerIndex = this.layers.length;
          this.layers.push([]);
          for (let i = 0; i < nodes.length; i += 2) {
            if (i + 1 === nodes.length) {
              if (nodes.length % 2 === 1) {
                let data2 = nodes[nodes.length - 1];
                let hash2 = data2;
                if (this.isBitcoinTree) {
                  data2 = buffer_1.Buffer.concat([buffer_reverse_1.default(data2), buffer_reverse_1.default(data2)]);
                  hash2 = this.hashFn(data2);
                  hash2 = buffer_reverse_1.default(this.hashFn(hash2));
                  this.layers[layerIndex].push(hash2);
                  continue;
                } else {
                  if (this.duplicateOdd) {
                  } else {
                    this.layers[layerIndex].push(nodes[i]);
                    continue;
                  }
                }
              }
            }
            const left = nodes[i];
            const right = i + 1 === nodes.length ? left : nodes[i + 1];
            let data = null;
            let combined = null;
            if (this.isBitcoinTree) {
              combined = [buffer_reverse_1.default(left), buffer_reverse_1.default(right)];
            } else {
              combined = [left, right];
            }
            if (this.sortPairs) {
              combined.sort(buffer_1.Buffer.compare);
            }
            data = buffer_1.Buffer.concat(combined);
            let hash = this.hashFn(data);
            if (this.isBitcoinTree) {
              hash = buffer_reverse_1.default(this.hashFn(hash));
            }
            this.layers[layerIndex].push(hash);
          }
          nodes = this.layers[layerIndex];
        }
      }
      addLeaf(leaf, shouldHash = false) {
        if (shouldHash) {
          leaf = this.hashFn(leaf);
        }
        this.processLeaves(this.leaves.concat(leaf));
      }
      addLeaves(leaves, shouldHash = false) {
        if (shouldHash) {
          leaves = leaves.map(this.hashFn);
        }
        this.processLeaves(this.leaves.concat(leaves));
      }
      getLeaves(values) {
        if (Array.isArray(values)) {
          if (this.hashLeaves) {
            values = values.map(this.hashFn);
            if (this.sortLeaves) {
              values = values.sort(buffer_1.Buffer.compare);
            }
          }
          return this.leaves.filter((leaf) => this._bufferIndexOf(values, leaf) !== -1);
        }
        return this.leaves;
      }
      getLeaf(index) {
        if (index < 0 || index > this.leaves.length - 1) {
          return buffer_1.Buffer.from([]);
        }
        return this.leaves[index];
      }
      getLeafIndex(target) {
        target = this.bufferify(target);
        const leaves = this.getLeaves();
        for (let i = 0; i < leaves.length; i++) {
          const leaf = leaves[i];
          if (leaf.equals(target)) {
            return i;
          }
        }
        return -1;
      }
      getLeafCount() {
        return this.leaves.length;
      }
      getHexLeaves() {
        return this.leaves.map((leaf) => this.bufferToHex(leaf));
      }
      static marshalLeaves(leaves) {
        return JSON.stringify(leaves.map((leaf) => MerkleTree2.bufferToHex(leaf)), null, 2);
      }
      static unmarshalLeaves(jsonStr) {
        let parsed = null;
        if (typeof jsonStr === "string") {
          parsed = JSON.parse(jsonStr);
        } else if (jsonStr instanceof Object) {
          parsed = jsonStr;
        } else {
          throw new Error("Expected type of string or object");
        }
        if (!parsed) {
          return [];
        }
        if (!Array.isArray(parsed)) {
          throw new Error("Expected JSON string to be array");
        }
        return parsed.map(MerkleTree2.bufferify);
      }
      getLayers() {
        return this.layers;
      }
      getHexLayers() {
        return this.layers.reduce((acc, item) => {
          if (Array.isArray(item)) {
            acc.push(item.map((layer) => this.bufferToHex(layer)));
          } else {
            acc.push(item);
          }
          return acc;
        }, []);
      }
      getLayersFlat() {
        const layers = this.layers.reduce((acc, item) => {
          if (Array.isArray(item)) {
            acc.unshift(...item);
          } else {
            acc.unshift(item);
          }
          return acc;
        }, []);
        layers.unshift(buffer_1.Buffer.from([0]));
        return layers;
      }
      getHexLayersFlat() {
        return this.getLayersFlat().map((layer) => this.bufferToHex(layer));
      }
      getLayerCount() {
        return this.getLayers().length;
      }
      getRoot() {
        if (this.layers.length === 0) {
          return buffer_1.Buffer.from([]);
        }
        return this.layers[this.layers.length - 1][0] || buffer_1.Buffer.from([]);
      }
      getHexRoot() {
        return this.bufferToHex(this.getRoot());
      }
      getProof(leaf, index) {
        if (typeof leaf === "undefined") {
          throw new Error("leaf is required");
        }
        leaf = this.bufferify(leaf);
        const proof = [];
        if (!Number.isInteger(index)) {
          index = -1;
          for (let i = 0; i < this.leaves.length; i++) {
            if (buffer_1.Buffer.compare(leaf, this.leaves[i]) === 0) {
              index = i;
            }
          }
        }
        if (index <= -1) {
          return [];
        }
        for (let i = 0; i < this.layers.length; i++) {
          const layer = this.layers[i];
          const isRightNode = index % 2;
          const pairIndex = isRightNode ? index - 1 : this.isBitcoinTree && index === layer.length - 1 && i < this.layers.length - 1 ? index : index + 1;
          if (pairIndex < layer.length) {
            proof.push({
              position: isRightNode ? "left" : "right",
              data: layer[pairIndex]
            });
          }
          index = index / 2 | 0;
        }
        return proof;
      }
      getHexProof(leaf, index) {
        return this.getProof(leaf, index).map((item) => this.bufferToHex(item.data));
      }
      getPositionalHexProof(leaf, index) {
        return this.getProof(leaf, index).map((item) => {
          return [
            item.position === "left" ? 0 : 1,
            this.bufferToHex(item.data)
          ];
        });
      }
      static marshalProof(proof) {
        const json = proof.map((item) => {
          if (typeof item === "string") {
            return item;
          }
          if (buffer_1.Buffer.isBuffer(item)) {
            return MerkleTree2.bufferToHex(item);
          }
          return {
            position: item.position,
            data: MerkleTree2.bufferToHex(item.data)
          };
        });
        return JSON.stringify(json, null, 2);
      }
      static unmarshalProof(jsonStr) {
        let parsed = null;
        if (typeof jsonStr === "string") {
          parsed = JSON.parse(jsonStr);
        } else if (jsonStr instanceof Object) {
          parsed = jsonStr;
        } else {
          throw new Error("Expected type of string or object");
        }
        if (!parsed) {
          return [];
        }
        if (!Array.isArray(parsed)) {
          throw new Error("Expected JSON string to be array");
        }
        return parsed.map((item) => {
          if (typeof item === "string") {
            return MerkleTree2.bufferify(item);
          } else if (item instanceof Object) {
            return {
              position: item.position,
              data: MerkleTree2.bufferify(item.data)
            };
          } else {
            throw new Error("Expected item to be of type string or object");
          }
        });
      }
      getProofIndices(treeIndices, depth) {
        const leafCount = Math.pow(2, depth);
        let maximalIndices = /* @__PURE__ */ new Set();
        for (const index of treeIndices) {
          let x = leafCount + index;
          while (x > 1) {
            maximalIndices.add(x ^ 1);
            x = x / 2 | 0;
          }
        }
        const a = treeIndices.map((index) => leafCount + index);
        const b = Array.from(maximalIndices).sort((a2, b2) => a2 - b2).reverse();
        maximalIndices = a.concat(b);
        const redundantIndices = /* @__PURE__ */ new Set();
        const proof = [];
        for (let index of maximalIndices) {
          if (!redundantIndices.has(index)) {
            proof.push(index);
            while (index > 1) {
              redundantIndices.add(index);
              if (!redundantIndices.has(index ^ 1))
                break;
              index = index / 2 | 0;
            }
          }
        }
        return proof.filter((index) => {
          return !treeIndices.includes(index - leafCount);
        });
      }
      getProofIndicesForUnevenTree(sortedLeafIndices, leavesCount) {
        const depth = Math.ceil(Math.log2(leavesCount));
        const unevenLayers = [];
        for (let index = 0; index < depth; index++) {
          const unevenLayer = leavesCount % 2 !== 0;
          if (unevenLayer) {
            unevenLayers.push({ index, leavesCount });
          }
          leavesCount = Math.ceil(leavesCount / 2);
        }
        const proofIndices = [];
        let layerNodes = sortedLeafIndices;
        for (let layerIndex = 0; layerIndex < depth; layerIndex++) {
          const siblingIndices = layerNodes.map((index) => {
            if (index % 2 === 0) {
              return index + 1;
            }
            return index - 1;
          });
          let proofNodeIndices = siblingIndices.filter((index) => !layerNodes.includes(index));
          const unevenLayer = unevenLayers.find(({ index }) => index === layerIndex);
          if (unevenLayer && layerNodes.includes(unevenLayer.leavesCount - 1)) {
            proofNodeIndices = proofNodeIndices.slice(0, -1);
          }
          proofIndices.push(proofNodeIndices);
          layerNodes = [...new Set(layerNodes.map((index) => {
            if (index % 2 === 0) {
              return index / 2;
            }
            if (index % 2 === 0) {
              return (index + 1) / 2;
            }
            return (index - 1) / 2;
          }))];
        }
        return proofIndices;
      }
      getMultiProof(tree, indices) {
        if (!indices) {
          indices = tree;
          tree = this.getLayersFlat();
        }
        const isUneven = this.isUnevenTree();
        if (isUneven) {
          if (indices.every(Number.isInteger)) {
            return this.getMultiProofForUnevenTree(indices);
          }
        }
        if (!indices.every(Number.isInteger)) {
          let els = indices;
          if (this.sortPairs) {
            els = els.sort(buffer_1.Buffer.compare);
          }
          let ids = els.map((el) => this._bufferIndexOf(this.leaves, el)).sort((a, b) => a === b ? 0 : a > b ? 1 : -1);
          if (!ids.every((idx) => idx !== -1)) {
            throw new Error("Element does not exist in Merkle tree");
          }
          const hashes = [];
          const proof = [];
          let nextIds = [];
          for (let i = 0; i < this.layers.length; i++) {
            const layer = this.layers[i];
            for (let j = 0; j < ids.length; j++) {
              const idx = ids[j];
              const pairElement = this._getPairNode(layer, idx);
              hashes.push(layer[idx]);
              if (pairElement) {
                proof.push(pairElement);
              }
              nextIds.push(idx / 2 | 0);
            }
            ids = nextIds.filter((value, i2, self2) => self2.indexOf(value) === i2);
            nextIds = [];
          }
          return proof.filter((value) => !hashes.includes(value));
        }
        return this.getProofIndices(indices, this._log2(tree.length / 2 | 0)).map((index) => tree[index]);
      }
      getMultiProofForUnevenTree(tree, indices) {
        if (!indices) {
          indices = tree;
          tree = this.getLayers();
        }
        let proofHashes = [];
        let currentLayerIndices = indices;
        for (const treeLayer of tree) {
          const siblings = [];
          for (const index of currentLayerIndices) {
            if (index % 2 === 0) {
              const idx2 = index + 1;
              if (!currentLayerIndices.includes(idx2)) {
                if (treeLayer[idx2]) {
                  siblings.push(treeLayer[idx2]);
                  continue;
                }
              }
            }
            const idx = index - 1;
            if (!currentLayerIndices.includes(idx)) {
              if (treeLayer[idx]) {
                siblings.push(treeLayer[idx]);
                continue;
              }
            }
          }
          proofHashes = proofHashes.concat(siblings);
          const uniqueIndices = /* @__PURE__ */ new Set();
          for (const index of currentLayerIndices) {
            if (index % 2 === 0) {
              uniqueIndices.add(index / 2);
              continue;
            }
            if (index % 2 === 0) {
              uniqueIndices.add((index + 1) / 2);
              continue;
            }
            uniqueIndices.add((index - 1) / 2);
          }
          currentLayerIndices = Array.from(uniqueIndices);
        }
        return proofHashes;
      }
      getHexMultiProof(tree, indices) {
        return this.getMultiProof(tree, indices).map((x) => this.bufferToHex(x));
      }
      getProofFlags(leaves, proofs) {
        if (!Array.isArray(leaves) || leaves.length <= 0) {
          throw new Error("Invalid Inputs!");
        }
        let ids;
        if (leaves.every(Number.isInteger)) {
          ids = leaves.sort((a, b) => a === b ? 0 : a > b ? 1 : -1);
        } else {
          ids = leaves.map((el) => this._bufferIndexOf(this.leaves, el)).sort((a, b) => a === b ? 0 : a > b ? 1 : -1);
        }
        if (!ids.every((idx) => idx !== -1)) {
          throw new Error("Element does not exist in Merkle tree");
        }
        const _proofs = proofs.map((item) => this.bufferify(item));
        const tested = [];
        const flags = [];
        for (let index = 0; index < this.layers.length; index++) {
          const layer = this.layers[index];
          ids = ids.reduce((ids2, idx) => {
            const skipped = tested.includes(layer[idx]);
            if (!skipped) {
              const pairElement = this._getPairNode(layer, idx);
              const proofUsed = _proofs.includes(layer[idx]) || _proofs.includes(pairElement);
              pairElement && flags.push(!proofUsed);
              tested.push(layer[idx]);
              tested.push(pairElement);
            }
            ids2.push(idx / 2 | 0);
            return ids2;
          }, []);
        }
        return flags;
      }
      verify(proof, targetNode, root) {
        let hash = this.bufferify(targetNode);
        root = this.bufferify(root);
        if (!Array.isArray(proof) || !targetNode || !root) {
          return false;
        }
        for (let i = 0; i < proof.length; i++) {
          const node = proof[i];
          let data = null;
          let isLeftNode = null;
          if (typeof node === "string") {
            data = this.bufferify(node);
            isLeftNode = true;
          } else if (Array.isArray(node)) {
            isLeftNode = node[0] === 0;
            data = this.bufferify(node[1]);
          } else if (buffer_1.Buffer.isBuffer(node)) {
            data = node;
            isLeftNode = true;
          } else if (node instanceof Object) {
            data = this.bufferify(node.data);
            isLeftNode = node.position === "left";
          } else {
            throw new Error("Expected node to be of type string or object");
          }
          const buffers = [];
          if (this.isBitcoinTree) {
            buffers.push(buffer_reverse_1.default(hash));
            buffers[isLeftNode ? "unshift" : "push"](buffer_reverse_1.default(data));
            hash = this.hashFn(buffer_1.Buffer.concat(buffers));
            hash = buffer_reverse_1.default(this.hashFn(hash));
          } else {
            if (this.sortPairs) {
              if (buffer_1.Buffer.compare(hash, data) === -1) {
                buffers.push(hash, data);
                hash = this.hashFn(buffer_1.Buffer.concat(buffers));
              } else {
                buffers.push(data, hash);
                hash = this.hashFn(buffer_1.Buffer.concat(buffers));
              }
            } else {
              buffers.push(hash);
              buffers[isLeftNode ? "unshift" : "push"](data);
              hash = this.hashFn(buffer_1.Buffer.concat(buffers));
            }
          }
        }
        return buffer_1.Buffer.compare(hash, root) === 0;
      }
      verifyMultiProof(root, proofIndices, proofLeaves, leavesCount, proof) {
        const isUneven = this.isUnevenTree();
        if (isUneven) {
          return this.verifyMultiProofForUnevenTree(root, proofIndices, proofLeaves, leavesCount, proof);
        }
        const depth = Math.ceil(Math.log2(leavesCount));
        root = this.bufferify(root);
        proofLeaves = proofLeaves.map((leaf) => this.bufferify(leaf));
        proof = proof.map((leaf) => this.bufferify(leaf));
        const tree = {};
        for (const [index, leaf] of this._zip(proofIndices, proofLeaves)) {
          tree[Math.pow(2, depth) + index] = leaf;
        }
        for (const [index, proofitem] of this._zip(this.getProofIndices(proofIndices, depth), proof)) {
          tree[index] = proofitem;
        }
        let indexqueue = Object.keys(tree).map((value) => +value).sort((a, b) => a - b);
        indexqueue = indexqueue.slice(0, indexqueue.length - 1);
        let i = 0;
        while (i < indexqueue.length) {
          const index = indexqueue[i];
          if (index >= 2 && {}.hasOwnProperty.call(tree, index ^ 1)) {
            let pair = [tree[index - index % 2], tree[index - index % 2 + 1]];
            if (this.sortPairs) {
              pair = pair.sort(buffer_1.Buffer.compare);
            }
            const hash = pair[1] ? this.hashFn(buffer_1.Buffer.concat(pair)) : pair[0];
            tree[index / 2 | 0] = hash;
            indexqueue.push(index / 2 | 0);
          }
          i += 1;
        }
        return !proofIndices.length || {}.hasOwnProperty.call(tree, 1) && tree[1].equals(root);
      }
      verifyMultiProofWithFlags(root, leaves, proofs, proofFlag) {
        root = this.bufferify(root);
        leaves = leaves.map(this.bufferify);
        proofs = proofs.map(this.bufferify);
        const leavesLen = leaves.length;
        const totalHashes = proofFlag.length;
        const hashes = [];
        let leafPos = 0;
        let hashPos = 0;
        let proofPos = 0;
        for (let i = 0; i < totalHashes; i++) {
          const bufA = proofFlag[i] ? leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++] : proofs[proofPos++];
          const bufB = leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++];
          const buffers = [bufA, bufB].sort(buffer_1.Buffer.compare);
          hashes[i] = this.hashFn(buffer_1.Buffer.concat(buffers));
        }
        return buffer_1.Buffer.compare(hashes[totalHashes - 1], root) === 0;
      }
      verifyMultiProofForUnevenTree(root, indices, leaves, leavesCount, proof) {
        root = this.bufferify(root);
        leaves = leaves.map((leaf) => this.bufferify(leaf));
        proof = proof.map((leaf) => this.bufferify(leaf));
        const computedRoot = this.calculateRootForUnevenTree(indices, leaves, leavesCount, proof);
        return root.equals(computedRoot);
      }
      getDepth() {
        return this.getLayers().length - 1;
      }
      getLayersAsObject() {
        const layers = this.getLayers().map((layer) => layer.map((value) => this.bufferToHex(value, false)));
        const objs = [];
        for (let i = 0; i < layers.length; i++) {
          const arr = [];
          for (let j = 0; j < layers[i].length; j++) {
            const obj = { [layers[i][j]]: null };
            if (objs.length) {
              obj[layers[i][j]] = {};
              const a = objs.shift();
              const akey = Object.keys(a)[0];
              obj[layers[i][j]][akey] = a[akey];
              if (objs.length) {
                const b = objs.shift();
                const bkey = Object.keys(b)[0];
                obj[layers[i][j]][bkey] = b[bkey];
              }
            }
            arr.push(obj);
          }
          objs.push(...arr);
        }
        return objs[0];
      }
      static verify(proof, targetNode, root, hashFn = sha256_1.default, options = {}) {
        const tree = new MerkleTree2([], hashFn, options);
        return tree.verify(proof, targetNode, root);
      }
      static getMultiProof(tree, indices) {
        const t = new MerkleTree2([]);
        return t.getMultiProof(tree, indices);
      }
      resetTree() {
        this.leaves = [];
        this.layers = [];
      }
      _getPairNode(layer, idx) {
        const pairIdx = idx % 2 === 0 ? idx + 1 : idx - 1;
        if (pairIdx < layer.length) {
          return layer[pairIdx];
        } else {
          return null;
        }
      }
      _toTreeString() {
        const obj = this.getLayersAsObject();
        return treeify_1.default.asTree(obj, true);
      }
      toString() {
        return this._toTreeString();
      }
      isUnevenTree(treeLayers) {
        const depth = (treeLayers === null || treeLayers === void 0 ? void 0 : treeLayers.length) || this.getDepth();
        return !this.isPowOf2(depth);
      }
      isPowOf2(v) {
        return v && !(v & v - 1);
      }
      calculateRootForUnevenTree(leafIndices, leafHashes, totalLeavesCount, proofHashes) {
        const leafTuples = this._zip(leafIndices, leafHashes).sort(([indexA], [indexB]) => indexA - indexB);
        const leafTupleIndices = leafTuples.map(([index]) => index);
        const proofIndices = this.getProofIndicesForUnevenTree(leafTupleIndices, totalLeavesCount);
        let nextSliceStart = 0;
        const proofTuplesByLayers = [];
        for (let i = 0; i < proofIndices.length; i++) {
          const indices = proofIndices[i];
          const sliceStart = nextSliceStart;
          nextSliceStart += indices.length;
          proofTuplesByLayers[i] = this._zip(indices, proofHashes.slice(sliceStart, nextSliceStart));
        }
        const tree = [leafTuples];
        for (let layerIndex = 0; layerIndex < proofTuplesByLayers.length; layerIndex++) {
          const currentLayer = proofTuplesByLayers[layerIndex].concat(tree[layerIndex]).sort(([indexA], [indexB]) => indexA - indexB).map(([, hash]) => hash);
          const s = tree[layerIndex].map(([layerIndex2]) => layerIndex2);
          const parentIndices = [...new Set(s.map((index) => {
            if (index % 2 === 0) {
              return index / 2;
            }
            if (index % 2 === 0) {
              return (index + 1) / 2;
            }
            return (index - 1) / 2;
          }))];
          const parentLayer = [];
          for (let i = 0; i < parentIndices.length; i++) {
            const parentNodeTreeIndex = parentIndices[i];
            const bufA = currentLayer[i * 2];
            const bufB = currentLayer[i * 2 + 1];
            const hash = bufB ? this.hashFn(buffer_1.Buffer.concat([bufA, bufB])) : bufA;
            parentLayer.push([parentNodeTreeIndex, hash]);
          }
          tree.push(parentLayer);
        }
        return tree[tree.length - 1][0][1];
      }
    };
    exports.MerkleTree = MerkleTree2;
    if (typeof window !== "undefined") {
      ;
      window.MerkleTree = MerkleTree2;
    }
    exports.default = MerkleTree2;
  }
});

// node_modules/merkletreejs/dist/MerkleMountainRange.js
var require_MerkleMountainRange = __commonJS({
  "node_modules/merkletreejs/dist/MerkleMountainRange.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod2) {
      return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.MerkleMountainRange = void 0;
    var buffer_1 = require_buffer();
    var sha256_1 = __importDefault(require_sha256());
    var Base_1 = __importDefault(require_Base());
    var MerkleMountainRange = class extends Base_1.default {
      constructor(hashFn = sha256_1.default, leaves = [], hashLeafFn, peakBaggingFn, hashBranchFn) {
        super();
        this.root = buffer_1.Buffer.alloc(0);
        this.size = 0;
        this.width = 0;
        this.hashes = {};
        this.data = {};
        leaves = leaves.map(this.bufferify);
        this.hashFn = this.bufferifyFn(hashFn);
        this.hashLeafFn = hashLeafFn;
        this.peakBaggingFn = peakBaggingFn;
        this.hashBranchFn = hashBranchFn;
        for (const leaf of leaves) {
          this.append(leaf);
        }
      }
      append(data) {
        data = this.bufferify(data);
        const dataHash = this.hashFn(data);
        const dataHashHex = this.bufferToHex(dataHash);
        if (!this.data[dataHashHex] || this.bufferToHex(this.hashFn(this.data[dataHashHex])) !== dataHashHex) {
          this.data[dataHashHex] = data;
        }
        const leaf = this.hashLeaf(this.size + 1, dataHash);
        this.hashes[this.size + 1] = leaf;
        this.width += 1;
        const peakIndexes = this.getPeakIndexes(this.width);
        this.size = this.getSize(this.width);
        const peaks = [];
        for (let i = 0; i < peakIndexes.length; i++) {
          peaks[i] = this._getOrCreateNode(peakIndexes[i]);
        }
        this.root = this.peakBagging(this.width, peaks);
      }
      hashLeaf(index, dataHash) {
        dataHash = this.bufferify(dataHash);
        if (this.hashLeafFn) {
          return this.bufferify(this.hashLeafFn(index, dataHash));
        }
        return this.hashFn(buffer_1.Buffer.concat([this.bufferify(index), dataHash]));
      }
      hashBranch(index, left, right) {
        if (this.hashBranchFn) {
          return this.bufferify(this.hashBranchFn(index, left, right));
        }
        return this.hashFn(buffer_1.Buffer.concat([this.bufferify(index), this.bufferify(left), this.bufferify(right)]));
      }
      getPeaks() {
        const peakIndexes = this.getPeakIndexes(this.width);
        const peaks = [];
        for (let i = 0; i < peakIndexes.length; i++) {
          peaks[i] = this.hashes[peakIndexes[i]];
        }
        return peaks;
      }
      getLeafIndex(width) {
        if (width % 2 === 1) {
          return this.getSize(width);
        }
        return this.getSize(width - 1) + 1;
      }
      getPeakIndexes(width) {
        const numPeaks = this.numOfPeaks(width);
        const peakIndexes = [];
        let count = 0;
        let size = 0;
        for (let i = 255; i > 0; i--) {
          if ((width & 1 << i - 1) !== 0) {
            size = size + (1 << i) - 1;
            peakIndexes[count++] = size;
            if (peakIndexes.length >= numPeaks) {
              break;
            }
          }
        }
        if (count !== peakIndexes.length) {
          throw new Error("invalid bit calculation");
        }
        return peakIndexes;
      }
      numOfPeaks(width) {
        let bits = width;
        let num = 0;
        while (bits > 0) {
          if (bits % 2 === 1) {
            num++;
          }
          bits = bits >> 1;
        }
        return num;
      }
      peakBagging(width, peaks) {
        const size = this.getSize(width);
        if (this.numOfPeaks(width) !== peaks.length) {
          throw new Error("received invalid number of peaks");
        }
        if (width === 0 && !peaks.length) {
          return buffer_1.Buffer.alloc(0);
        }
        if (this.peakBaggingFn) {
          return this.bufferify(this.peakBaggingFn(size, peaks));
        }
        return this.hashFn(buffer_1.Buffer.concat([this.bufferify(size), ...peaks.map(this.bufferify)]));
      }
      getSize(width) {
        return (width << 1) - this.numOfPeaks(width);
      }
      getRoot() {
        return this.root;
      }
      getHexRoot() {
        return this.bufferToHex(this.getRoot());
      }
      getNode(index) {
        return this.hashes[index];
      }
      mountainHeight(size) {
        let height = 1;
        while (1 << height <= size + height) {
          height++;
        }
        return height - 1;
      }
      heightAt(index) {
        let reducedIndex = index;
        let peakIndex = 0;
        let height = 0;
        while (reducedIndex > peakIndex) {
          reducedIndex -= (1 << height) - 1;
          height = this.mountainHeight(reducedIndex);
          peakIndex = (1 << height) - 1;
        }
        return height - (peakIndex - reducedIndex);
      }
      isLeaf(index) {
        return this.heightAt(index) === 1;
      }
      getChildren(index) {
        const left = index - (1 << this.heightAt(index) - 1);
        const right = index - 1;
        if (left === right) {
          throw new Error("not a parent");
        }
        return [left, right];
      }
      getMerkleProof(index) {
        if (index > this.size) {
          throw new Error("out of range");
        }
        if (!this.isLeaf(index)) {
          throw new Error("not a leaf");
        }
        const root = this.root;
        const width = this.width;
        const peaks = this.getPeakIndexes(this.width);
        const peakBagging = [];
        let cursor = 0;
        for (let i = 0; i < peaks.length; i++) {
          peakBagging[i] = this.hashes[peaks[i]];
          if (peaks[i] >= index && cursor === 0) {
            cursor = peaks[i];
          }
        }
        let left = 0;
        let right = 0;
        let height = this.heightAt(cursor);
        const siblings = [];
        while (cursor !== index) {
          height--;
          [left, right] = this.getChildren(cursor);
          cursor = index <= left ? left : right;
          siblings[height - 1] = this.hashes[index <= left ? right : left];
        }
        return {
          root,
          width,
          peakBagging,
          siblings
        };
      }
      verify(root, width, index, value, peaks, siblings) {
        value = this.bufferify(value);
        const size = this.getSize(width);
        if (size < index) {
          throw new Error("index is out of range");
        }
        if (!root.equals(this.peakBagging(width, peaks))) {
          throw new Error("invalid root hash from the peaks");
        }
        let cursor = 0;
        let targetPeak;
        const peakIndexes = this.getPeakIndexes(width);
        for (let i = 0; i < peakIndexes.length; i++) {
          if (peakIndexes[i] >= index) {
            targetPeak = peaks[i];
            cursor = peakIndexes[i];
            break;
          }
        }
        if (!targetPeak) {
          throw new Error("target not found");
        }
        let height = siblings.length + 1;
        const path = new Array(height);
        let left = 0;
        let right = 0;
        while (height > 0) {
          path[--height] = cursor;
          if (cursor === index) {
            break;
          } else {
            [left, right] = this.getChildren(cursor);
            cursor = index > left ? right : left;
            continue;
          }
        }
        let node;
        while (height < path.length) {
          cursor = path[height];
          if (height === 0) {
            node = this.hashLeaf(cursor, this.hashFn(value));
          } else if (cursor - 1 === path[height - 1]) {
            node = this.hashBranch(cursor, siblings[height - 1], node);
          } else {
            node = this.hashBranch(cursor, node, siblings[height - 1]);
          }
          height++;
        }
        if (!node.equals(targetPeak)) {
          throw new Error("hashed peak is invalid");
        }
        return true;
      }
      peaksToPeakMap(width, peaks) {
        const peakMap = {};
        let bitIndex = 0;
        let peakRef = 0;
        let count = peaks.length;
        for (let height = 1; height <= 32; height++) {
          bitIndex = 32 - height;
          peakRef = 1 << height - 1;
          if ((width & peakRef) !== 0) {
            peakMap[bitIndex] = peaks[--count];
          } else {
            peakMap[bitIndex] = 0;
          }
        }
        if (count !== 0) {
          throw new Error("invalid number of peaks");
        }
        return peakMap;
      }
      peakMapToPeaks(width, peakMap) {
        const arrLength = this.numOfPeaks(width);
        const peaks = new Array(arrLength);
        let count = 0;
        for (let i = 0; i < 32; i++) {
          if (peakMap[i] !== 0) {
            peaks[count++] = peakMap[i];
          }
        }
        if (count !== arrLength) {
          throw new Error("invalid number of peaks");
        }
        return peaks;
      }
      peakUpdate(width, prevPeakMap, itemHash) {
        const nextPeakMap = {};
        const newWidth = width + 1;
        let cursorIndex = this.getLeafIndex(newWidth);
        let cursorNode = this.hashLeaf(cursorIndex, itemHash);
        let bitIndex = 0;
        let peakRef = 0;
        let prevPeakExist = false;
        let nextPeakExist = false;
        let obtained = false;
        for (let height = 1; height <= 32; height++) {
          bitIndex = 32 - height;
          if (obtained) {
            nextPeakMap[bitIndex] = prevPeakMap[bitIndex];
          } else {
            peakRef = 1 << height - 1;
            prevPeakExist = (width & peakRef) !== 0;
            nextPeakExist = (newWidth & peakRef) !== 0;
            cursorIndex++;
            if (prevPeakExist) {
              cursorNode = this.hashBranch(cursorIndex, prevPeakMap[bitIndex], cursorNode);
            }
            if (nextPeakExist) {
              if (prevPeakExist) {
                nextPeakMap[bitIndex] = prevPeakMap[bitIndex];
              } else {
                nextPeakMap[bitIndex] = cursorNode;
              }
              obtained = true;
            } else {
              nextPeakMap[bitIndex] = 0;
            }
          }
        }
        return nextPeakMap;
      }
      rollUp(root, width, peaks, itemHashes) {
        if (!root.equals(this.peakBagging(width, peaks))) {
          throw new Error("invalid root hash from the peaks");
        }
        let tmpWidth = width;
        let tmpPeakMap = this.peaksToPeakMap(width, peaks);
        for (let i = 0; i < itemHashes.length; i++) {
          tmpPeakMap = this.peakUpdate(tmpWidth, tmpPeakMap, itemHashes[i]);
          tmpWidth++;
        }
        return this.peakBagging(tmpWidth, this.peakMapToPeaks(tmpWidth, tmpPeakMap));
      }
      _getOrCreateNode(index) {
        if (index > this.size) {
          throw new Error("out of range");
        }
        if (!this.hashes[index]) {
          const [leftIndex, rightIndex] = this.getChildren(index);
          const leftHash = this._getOrCreateNode(leftIndex);
          const rightHash = this._getOrCreateNode(rightIndex);
          this.hashes[index] = this.hashBranch(index, leftHash, rightHash);
        }
        return this.hashes[index];
      }
    };
    exports.MerkleMountainRange = MerkleMountainRange;
    exports.default = MerkleMountainRange;
  }
});

// node_modules/merkletreejs/dist/index.js
var require_dist = __commonJS({
  "node_modules/merkletreejs/dist/index.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod2) {
      return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.MerkleTree = void 0;
    var MerkleTree_1 = __importDefault(require_MerkleTree());
    exports.MerkleTree = MerkleTree_1.default;
    var MerkleMountainRange_1 = require_MerkleMountainRange();
    Object.defineProperty(exports, "MerkleMountainRange", { enumerable: true, get: function() {
      return MerkleMountainRange_1.MerkleMountainRange;
    } });
    exports.default = MerkleTree_1.default;
  }
});

// node_modules/fast-deep-equal/index.js
var require_fast_deep_equal = __commonJS({
  "node_modules/fast-deep-equal/index.js"(exports, module) {
    "use strict";
    module.exports = function equal(a, b) {
      if (a === b)
        return true;
      if (a && b && typeof a == "object" && typeof b == "object") {
        if (a.constructor !== b.constructor)
          return false;
        var length, i, keys;
        if (Array.isArray(a)) {
          length = a.length;
          if (length != b.length)
            return false;
          for (i = length; i-- !== 0; )
            if (!equal(a[i], b[i]))
              return false;
          return true;
        }
        if (a.constructor === RegExp)
          return a.source === b.source && a.flags === b.flags;
        if (a.valueOf !== Object.prototype.valueOf)
          return a.valueOf() === b.valueOf();
        if (a.toString !== Object.prototype.toString)
          return a.toString() === b.toString();
        keys = Object.keys(a);
        length = keys.length;
        if (length !== Object.keys(b).length)
          return false;
        for (i = length; i-- !== 0; )
          if (!Object.prototype.hasOwnProperty.call(b, keys[i]))
            return false;
        for (i = length; i-- !== 0; ) {
          var key = keys[i];
          if (!equal(a[key], b[key]))
            return false;
        }
        return true;
      }
      return a !== a && b !== b;
    };
  }
});

// node_modules/form-data/lib/browser.js
var require_browser = __commonJS({
  "node_modules/form-data/lib/browser.js"(exports, module) {
    module.exports = typeof self == "object" ? self.FormData : window.FormData;
  }
});

// node_modules/zod/lib/index.mjs
var util;
(function(util2) {
  util2.assertEqual = (val) => val;
  function assertIs(_arg) {
  }
  util2.assertIs = assertIs;
  function assertNever(_x) {
    throw new Error();
  }
  util2.assertNever = assertNever;
  util2.arrayToEnum = (items) => {
    const obj = {};
    for (const item of items) {
      obj[item] = item;
    }
    return obj;
  };
  util2.getValidEnumValues = (obj) => {
    const validKeys = util2.objectKeys(obj).filter((k) => typeof obj[obj[k]] !== "number");
    const filtered = {};
    for (const k of validKeys) {
      filtered[k] = obj[k];
    }
    return util2.objectValues(filtered);
  };
  util2.objectValues = (obj) => {
    return util2.objectKeys(obj).map(function(e) {
      return obj[e];
    });
  };
  util2.objectKeys = typeof Object.keys === "function" ? (obj) => Object.keys(obj) : (object) => {
    const keys = [];
    for (const key in object) {
      if (Object.prototype.hasOwnProperty.call(object, key)) {
        keys.push(key);
      }
    }
    return keys;
  };
  util2.find = (arr, checker) => {
    for (const item of arr) {
      if (checker(item))
        return item;
    }
    return void 0;
  };
  util2.isInteger = typeof Number.isInteger === "function" ? (val) => Number.isInteger(val) : (val) => typeof val === "number" && isFinite(val) && Math.floor(val) === val;
  function joinValues(array, separator = " | ") {
    return array.map((val) => typeof val === "string" ? `'${val}'` : val).join(separator);
  }
  util2.joinValues = joinValues;
  util2.jsonStringifyReplacer = (_, value) => {
    if (typeof value === "bigint") {
      return value.toString();
    }
    return value;
  };
})(util || (util = {}));
var ZodParsedType = util.arrayToEnum([
  "string",
  "nan",
  "number",
  "integer",
  "float",
  "boolean",
  "date",
  "bigint",
  "symbol",
  "function",
  "undefined",
  "null",
  "array",
  "object",
  "unknown",
  "promise",
  "void",
  "never",
  "map",
  "set"
]);
var getParsedType = (data) => {
  const t = typeof data;
  switch (t) {
    case "undefined":
      return ZodParsedType.undefined;
    case "string":
      return ZodParsedType.string;
    case "number":
      return isNaN(data) ? ZodParsedType.nan : ZodParsedType.number;
    case "boolean":
      return ZodParsedType.boolean;
    case "function":
      return ZodParsedType.function;
    case "bigint":
      return ZodParsedType.bigint;
    case "symbol":
      return ZodParsedType.symbol;
    case "object":
      if (Array.isArray(data)) {
        return ZodParsedType.array;
      }
      if (data === null) {
        return ZodParsedType.null;
      }
      if (data.then && typeof data.then === "function" && data.catch && typeof data.catch === "function") {
        return ZodParsedType.promise;
      }
      if (typeof Map !== "undefined" && data instanceof Map) {
        return ZodParsedType.map;
      }
      if (typeof Set !== "undefined" && data instanceof Set) {
        return ZodParsedType.set;
      }
      if (typeof Date !== "undefined" && data instanceof Date) {
        return ZodParsedType.date;
      }
      return ZodParsedType.object;
    default:
      return ZodParsedType.unknown;
  }
};
var ZodIssueCode = util.arrayToEnum([
  "invalid_type",
  "invalid_literal",
  "custom",
  "invalid_union",
  "invalid_union_discriminator",
  "invalid_enum_value",
  "unrecognized_keys",
  "invalid_arguments",
  "invalid_return_type",
  "invalid_date",
  "invalid_string",
  "too_small",
  "too_big",
  "invalid_intersection_types",
  "not_multiple_of",
  "not_finite"
]);
var quotelessJson = (obj) => {
  const json = JSON.stringify(obj, null, 2);
  return json.replace(/"([^"]+)":/g, "$1:");
};
var ZodError = class extends Error {
  constructor(issues) {
    super();
    this.issues = [];
    this.addIssue = (sub) => {
      this.issues = [...this.issues, sub];
    };
    this.addIssues = (subs = []) => {
      this.issues = [...this.issues, ...subs];
    };
    const actualProto = new.target.prototype;
    if (Object.setPrototypeOf) {
      Object.setPrototypeOf(this, actualProto);
    } else {
      this.__proto__ = actualProto;
    }
    this.name = "ZodError";
    this.issues = issues;
  }
  get errors() {
    return this.issues;
  }
  format(_mapper) {
    const mapper = _mapper || function(issue) {
      return issue.message;
    };
    const fieldErrors = { _errors: [] };
    const processError = (error) => {
      for (const issue of error.issues) {
        if (issue.code === "invalid_union") {
          issue.unionErrors.map(processError);
        } else if (issue.code === "invalid_return_type") {
          processError(issue.returnTypeError);
        } else if (issue.code === "invalid_arguments") {
          processError(issue.argumentsError);
        } else if (issue.path.length === 0) {
          fieldErrors._errors.push(mapper(issue));
        } else {
          let curr = fieldErrors;
          let i = 0;
          while (i < issue.path.length) {
            const el = issue.path[i];
            const terminal = i === issue.path.length - 1;
            if (!terminal) {
              curr[el] = curr[el] || { _errors: [] };
            } else {
              curr[el] = curr[el] || { _errors: [] };
              curr[el]._errors.push(mapper(issue));
            }
            curr = curr[el];
            i++;
          }
        }
      }
    };
    processError(this);
    return fieldErrors;
  }
  toString() {
    return this.message;
  }
  get message() {
    return JSON.stringify(this.issues, util.jsonStringifyReplacer, 2);
  }
  get isEmpty() {
    return this.issues.length === 0;
  }
  flatten(mapper = (issue) => issue.message) {
    const fieldErrors = {};
    const formErrors = [];
    for (const sub of this.issues) {
      if (sub.path.length > 0) {
        fieldErrors[sub.path[0]] = fieldErrors[sub.path[0]] || [];
        fieldErrors[sub.path[0]].push(mapper(sub));
      } else {
        formErrors.push(mapper(sub));
      }
    }
    return { formErrors, fieldErrors };
  }
  get formErrors() {
    return this.flatten();
  }
};
ZodError.create = (issues) => {
  const error = new ZodError(issues);
  return error;
};
var errorMap = (issue, _ctx) => {
  let message;
  switch (issue.code) {
    case ZodIssueCode.invalid_type:
      if (issue.received === ZodParsedType.undefined) {
        message = "Required";
      } else {
        message = `Expected ${issue.expected}, received ${issue.received}`;
      }
      break;
    case ZodIssueCode.invalid_literal:
      message = `Invalid literal value, expected ${JSON.stringify(issue.expected, util.jsonStringifyReplacer)}`;
      break;
    case ZodIssueCode.unrecognized_keys:
      message = `Unrecognized key(s) in object: ${util.joinValues(issue.keys, ", ")}`;
      break;
    case ZodIssueCode.invalid_union:
      message = `Invalid input`;
      break;
    case ZodIssueCode.invalid_union_discriminator:
      message = `Invalid discriminator value. Expected ${util.joinValues(issue.options)}`;
      break;
    case ZodIssueCode.invalid_enum_value:
      message = `Invalid enum value. Expected ${util.joinValues(issue.options)}, received '${issue.received}'`;
      break;
    case ZodIssueCode.invalid_arguments:
      message = `Invalid function arguments`;
      break;
    case ZodIssueCode.invalid_return_type:
      message = `Invalid function return type`;
      break;
    case ZodIssueCode.invalid_date:
      message = `Invalid date`;
      break;
    case ZodIssueCode.invalid_string:
      if (typeof issue.validation === "object") {
        if ("startsWith" in issue.validation) {
          message = `Invalid input: must start with "${issue.validation.startsWith}"`;
        } else if ("endsWith" in issue.validation) {
          message = `Invalid input: must end with "${issue.validation.endsWith}"`;
        } else {
          util.assertNever(issue.validation);
        }
      } else if (issue.validation !== "regex") {
        message = `Invalid ${issue.validation}`;
      } else {
        message = "Invalid";
      }
      break;
    case ZodIssueCode.too_small:
      if (issue.type === "array")
        message = `Array must contain ${issue.exact ? "exactly" : issue.inclusive ? `at least` : `more than`} ${issue.minimum} element(s)`;
      else if (issue.type === "string")
        message = `String must contain ${issue.exact ? "exactly" : issue.inclusive ? `at least` : `over`} ${issue.minimum} character(s)`;
      else if (issue.type === "number")
        message = `Number must be ${issue.exact ? `exactly equal to ` : issue.inclusive ? `greater than or equal to ` : `greater than `}${issue.minimum}`;
      else if (issue.type === "date")
        message = `Date must be ${issue.exact ? `exactly equal to ` : issue.inclusive ? `greater than or equal to ` : `greater than `}${new Date(issue.minimum)}`;
      else
        message = "Invalid input";
      break;
    case ZodIssueCode.too_big:
      if (issue.type === "array")
        message = `Array must contain ${issue.exact ? `exactly` : issue.inclusive ? `at most` : `less than`} ${issue.maximum} element(s)`;
      else if (issue.type === "string")
        message = `String must contain ${issue.exact ? `exactly` : issue.inclusive ? `at most` : `under`} ${issue.maximum} character(s)`;
      else if (issue.type === "number")
        message = `Number must be ${issue.exact ? `exactly` : issue.inclusive ? `less than or equal to` : `less than`} ${issue.maximum}`;
      else if (issue.type === "date")
        message = `Date must be ${issue.exact ? `exactly` : issue.inclusive ? `smaller than or equal to` : `smaller than`} ${new Date(issue.maximum)}`;
      else
        message = "Invalid input";
      break;
    case ZodIssueCode.custom:
      message = `Invalid input`;
      break;
    case ZodIssueCode.invalid_intersection_types:
      message = `Intersection results could not be merged`;
      break;
    case ZodIssueCode.not_multiple_of:
      message = `Number must be a multiple of ${issue.multipleOf}`;
      break;
    case ZodIssueCode.not_finite:
      message = "Number must be finite";
      break;
    default:
      message = _ctx.defaultError;
      util.assertNever(issue);
  }
  return { message };
};
var overrideErrorMap = errorMap;
function setErrorMap(map) {
  overrideErrorMap = map;
}
function getErrorMap() {
  return overrideErrorMap;
}
var makeIssue = (params) => {
  const { data, path, errorMaps, issueData } = params;
  const fullPath = [...path, ...issueData.path || []];
  const fullIssue = {
    ...issueData,
    path: fullPath
  };
  let errorMessage = "";
  const maps = errorMaps.filter((m) => !!m).slice().reverse();
  for (const map of maps) {
    errorMessage = map(fullIssue, { data, defaultError: errorMessage }).message;
  }
  return {
    ...issueData,
    path: fullPath,
    message: issueData.message || errorMessage
  };
};
var EMPTY_PATH = [];
function addIssueToContext(ctx, issueData) {
  const issue = makeIssue({
    issueData,
    data: ctx.data,
    path: ctx.path,
    errorMaps: [
      ctx.common.contextualErrorMap,
      ctx.schemaErrorMap,
      getErrorMap(),
      errorMap
    ].filter((x) => !!x)
  });
  ctx.common.issues.push(issue);
}
var ParseStatus = class {
  constructor() {
    this.value = "valid";
  }
  dirty() {
    if (this.value === "valid")
      this.value = "dirty";
  }
  abort() {
    if (this.value !== "aborted")
      this.value = "aborted";
  }
  static mergeArray(status, results) {
    const arrayValue = [];
    for (const s of results) {
      if (s.status === "aborted")
        return INVALID;
      if (s.status === "dirty")
        status.dirty();
      arrayValue.push(s.value);
    }
    return { status: status.value, value: arrayValue };
  }
  static async mergeObjectAsync(status, pairs) {
    const syncPairs = [];
    for (const pair of pairs) {
      syncPairs.push({
        key: await pair.key,
        value: await pair.value
      });
    }
    return ParseStatus.mergeObjectSync(status, syncPairs);
  }
  static mergeObjectSync(status, pairs) {
    const finalObject = {};
    for (const pair of pairs) {
      const { key, value } = pair;
      if (key.status === "aborted")
        return INVALID;
      if (value.status === "aborted")
        return INVALID;
      if (key.status === "dirty")
        status.dirty();
      if (value.status === "dirty")
        status.dirty();
      if (typeof value.value !== "undefined" || pair.alwaysSet) {
        finalObject[key.value] = value.value;
      }
    }
    return { status: status.value, value: finalObject };
  }
};
var INVALID = Object.freeze({
  status: "aborted"
});
var DIRTY = (value) => ({ status: "dirty", value });
var OK = (value) => ({ status: "valid", value });
var isAborted = (x) => x.status === "aborted";
var isDirty = (x) => x.status === "dirty";
var isValid = (x) => x.status === "valid";
var isAsync = (x) => typeof Promise !== void 0 && x instanceof Promise;
var errorUtil;
(function(errorUtil2) {
  errorUtil2.errToObj = (message) => typeof message === "string" ? { message } : message || {};
  errorUtil2.toString = (message) => typeof message === "string" ? message : message === null || message === void 0 ? void 0 : message.message;
})(errorUtil || (errorUtil = {}));
var ParseInputLazyPath = class {
  constructor(parent, value, path, key) {
    this.parent = parent;
    this.data = value;
    this._path = path;
    this._key = key;
  }
  get path() {
    return this._path.concat(this._key);
  }
};
var handleResult = (ctx, result) => {
  if (isValid(result)) {
    return { success: true, data: result.value };
  } else {
    if (!ctx.common.issues.length) {
      throw new Error("Validation failed but no issues detected.");
    }
    const error = new ZodError(ctx.common.issues);
    return { success: false, error };
  }
};
function processCreateParams(params) {
  if (!params)
    return {};
  const { errorMap: errorMap2, invalid_type_error, required_error, description } = params;
  if (errorMap2 && (invalid_type_error || required_error)) {
    throw new Error(`Can't use "invalid_type_error" or "required_error" in conjunction with custom error map.`);
  }
  if (errorMap2)
    return { errorMap: errorMap2, description };
  const customMap = (iss, ctx) => {
    if (iss.code !== "invalid_type")
      return { message: ctx.defaultError };
    if (typeof ctx.data === "undefined") {
      return { message: required_error !== null && required_error !== void 0 ? required_error : ctx.defaultError };
    }
    return { message: invalid_type_error !== null && invalid_type_error !== void 0 ? invalid_type_error : ctx.defaultError };
  };
  return { errorMap: customMap, description };
}
var ZodType = class {
  constructor(def) {
    this.spa = this.safeParseAsync;
    this._def = def;
    this.parse = this.parse.bind(this);
    this.safeParse = this.safeParse.bind(this);
    this.parseAsync = this.parseAsync.bind(this);
    this.safeParseAsync = this.safeParseAsync.bind(this);
    this.spa = this.spa.bind(this);
    this.refine = this.refine.bind(this);
    this.refinement = this.refinement.bind(this);
    this.superRefine = this.superRefine.bind(this);
    this.optional = this.optional.bind(this);
    this.nullable = this.nullable.bind(this);
    this.nullish = this.nullish.bind(this);
    this.array = this.array.bind(this);
    this.promise = this.promise.bind(this);
    this.or = this.or.bind(this);
    this.and = this.and.bind(this);
    this.transform = this.transform.bind(this);
    this.brand = this.brand.bind(this);
    this.default = this.default.bind(this);
    this.catch = this.catch.bind(this);
    this.describe = this.describe.bind(this);
    this.pipe = this.pipe.bind(this);
    this.isNullable = this.isNullable.bind(this);
    this.isOptional = this.isOptional.bind(this);
  }
  get description() {
    return this._def.description;
  }
  _getType(input) {
    return getParsedType(input.data);
  }
  _getOrReturnCtx(input, ctx) {
    return ctx || {
      common: input.parent.common,
      data: input.data,
      parsedType: getParsedType(input.data),
      schemaErrorMap: this._def.errorMap,
      path: input.path,
      parent: input.parent
    };
  }
  _processInputParams(input) {
    return {
      status: new ParseStatus(),
      ctx: {
        common: input.parent.common,
        data: input.data,
        parsedType: getParsedType(input.data),
        schemaErrorMap: this._def.errorMap,
        path: input.path,
        parent: input.parent
      }
    };
  }
  _parseSync(input) {
    const result = this._parse(input);
    if (isAsync(result)) {
      throw new Error("Synchronous parse encountered promise.");
    }
    return result;
  }
  _parseAsync(input) {
    const result = this._parse(input);
    return Promise.resolve(result);
  }
  parse(data, params) {
    const result = this.safeParse(data, params);
    if (result.success)
      return result.data;
    throw result.error;
  }
  safeParse(data, params) {
    var _a;
    const ctx = {
      common: {
        issues: [],
        async: (_a = params === null || params === void 0 ? void 0 : params.async) !== null && _a !== void 0 ? _a : false,
        contextualErrorMap: params === null || params === void 0 ? void 0 : params.errorMap
      },
      path: (params === null || params === void 0 ? void 0 : params.path) || [],
      schemaErrorMap: this._def.errorMap,
      parent: null,
      data,
      parsedType: getParsedType(data)
    };
    const result = this._parseSync({ data, path: ctx.path, parent: ctx });
    return handleResult(ctx, result);
  }
  async parseAsync(data, params) {
    const result = await this.safeParseAsync(data, params);
    if (result.success)
      return result.data;
    throw result.error;
  }
  async safeParseAsync(data, params) {
    const ctx = {
      common: {
        issues: [],
        contextualErrorMap: params === null || params === void 0 ? void 0 : params.errorMap,
        async: true
      },
      path: (params === null || params === void 0 ? void 0 : params.path) || [],
      schemaErrorMap: this._def.errorMap,
      parent: null,
      data,
      parsedType: getParsedType(data)
    };
    const maybeAsyncResult = this._parse({ data, path: ctx.path, parent: ctx });
    const result = await (isAsync(maybeAsyncResult) ? maybeAsyncResult : Promise.resolve(maybeAsyncResult));
    return handleResult(ctx, result);
  }
  refine(check, message) {
    const getIssueProperties = (val) => {
      if (typeof message === "string" || typeof message === "undefined") {
        return { message };
      } else if (typeof message === "function") {
        return message(val);
      } else {
        return message;
      }
    };
    return this._refinement((val, ctx) => {
      const result = check(val);
      const setError = () => ctx.addIssue({
        code: ZodIssueCode.custom,
        ...getIssueProperties(val)
      });
      if (typeof Promise !== "undefined" && result instanceof Promise) {
        return result.then((data) => {
          if (!data) {
            setError();
            return false;
          } else {
            return true;
          }
        });
      }
      if (!result) {
        setError();
        return false;
      } else {
        return true;
      }
    });
  }
  refinement(check, refinementData) {
    return this._refinement((val, ctx) => {
      if (!check(val)) {
        ctx.addIssue(typeof refinementData === "function" ? refinementData(val, ctx) : refinementData);
        return false;
      } else {
        return true;
      }
    });
  }
  _refinement(refinement) {
    return new ZodEffects({
      schema: this,
      typeName: ZodFirstPartyTypeKind.ZodEffects,
      effect: { type: "refinement", refinement }
    });
  }
  superRefine(refinement) {
    return this._refinement(refinement);
  }
  optional() {
    return ZodOptional.create(this);
  }
  nullable() {
    return ZodNullable.create(this);
  }
  nullish() {
    return this.optional().nullable();
  }
  array() {
    return ZodArray.create(this);
  }
  promise() {
    return ZodPromise.create(this);
  }
  or(option) {
    return ZodUnion.create([this, option]);
  }
  and(incoming) {
    return ZodIntersection.create(this, incoming);
  }
  transform(transform) {
    return new ZodEffects({
      schema: this,
      typeName: ZodFirstPartyTypeKind.ZodEffects,
      effect: { type: "transform", transform }
    });
  }
  default(def) {
    const defaultValueFunc = typeof def === "function" ? def : () => def;
    return new ZodDefault({
      innerType: this,
      defaultValue: defaultValueFunc,
      typeName: ZodFirstPartyTypeKind.ZodDefault
    });
  }
  brand() {
    return new ZodBranded({
      typeName: ZodFirstPartyTypeKind.ZodBranded,
      type: this,
      ...processCreateParams(void 0)
    });
  }
  catch(def) {
    const defaultValueFunc = typeof def === "function" ? def : () => def;
    return new ZodCatch({
      innerType: this,
      defaultValue: defaultValueFunc,
      typeName: ZodFirstPartyTypeKind.ZodCatch
    });
  }
  describe(description) {
    const This = this.constructor;
    return new This({
      ...this._def,
      description
    });
  }
  pipe(target) {
    return ZodPipeline.create(this, target);
  }
  isOptional() {
    return this.safeParse(void 0).success;
  }
  isNullable() {
    return this.safeParse(null).success;
  }
};
var cuidRegex = /^c[^\s-]{8,}$/i;
var uuidRegex = /^([a-f0-9]{8}-[a-f0-9]{4}-[1-5][a-f0-9]{3}-[a-f0-9]{4}-[a-f0-9]{12}|00000000-0000-0000-0000-000000000000)$/i;
var emailRegex = /^(([^<>()[\]\.,;:\s@\"]+(\.[^<>()[\]\.,;:\s@\"]+)*)|(\".+\"))@(([^<>()[\]\.,;:\s@\"]+\.)+[^<>()[\]\.,;:\s@\"]{2,})$/i;
var datetimeRegex = (args) => {
  if (args.precision) {
    if (args.offset) {
      return new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}\\.\\d{${args.precision}}(([+-]\\d{2}:\\d{2})|Z)$`);
    } else {
      return new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}\\.\\d{${args.precision}}Z$`);
    }
  } else if (args.precision === 0) {
    if (args.offset) {
      return new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(([+-]\\d{2}:\\d{2})|Z)$`);
    } else {
      return new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}Z$`);
    }
  } else {
    if (args.offset) {
      return new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(\\.\\d+)?(([+-]\\d{2}:\\d{2})|Z)$`);
    } else {
      return new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(\\.\\d+)?Z$`);
    }
  }
};
var ZodString = class extends ZodType {
  constructor() {
    super(...arguments);
    this._regex = (regex, validation, message) => this.refinement((data) => regex.test(data), {
      validation,
      code: ZodIssueCode.invalid_string,
      ...errorUtil.errToObj(message)
    });
    this.nonempty = (message) => this.min(1, errorUtil.errToObj(message));
    this.trim = () => new ZodString({
      ...this._def,
      checks: [...this._def.checks, { kind: "trim" }]
    });
  }
  _parse(input) {
    if (this._def.coerce) {
      input.data = String(input.data);
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.string) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(
        ctx2,
        {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.string,
          received: ctx2.parsedType
        }
      );
      return INVALID;
    }
    const status = new ParseStatus();
    let ctx = void 0;
    for (const check of this._def.checks) {
      if (check.kind === "min") {
        if (input.data.length < check.value) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_small,
            minimum: check.value,
            type: "string",
            inclusive: true,
            exact: false,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "max") {
        if (input.data.length > check.value) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_big,
            maximum: check.value,
            type: "string",
            inclusive: true,
            exact: false,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "length") {
        const tooBig = input.data.length > check.value;
        const tooSmall = input.data.length < check.value;
        if (tooBig || tooSmall) {
          ctx = this._getOrReturnCtx(input, ctx);
          if (tooBig) {
            addIssueToContext(ctx, {
              code: ZodIssueCode.too_big,
              maximum: check.value,
              type: "string",
              inclusive: true,
              exact: true,
              message: check.message
            });
          } else if (tooSmall) {
            addIssueToContext(ctx, {
              code: ZodIssueCode.too_small,
              minimum: check.value,
              type: "string",
              inclusive: true,
              exact: true,
              message: check.message
            });
          }
          status.dirty();
        }
      } else if (check.kind === "email") {
        if (!emailRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "email",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "uuid") {
        if (!uuidRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "uuid",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "cuid") {
        if (!cuidRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "cuid",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "url") {
        try {
          new URL(input.data);
        } catch (_a) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "url",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "regex") {
        check.regex.lastIndex = 0;
        const testResult = check.regex.test(input.data);
        if (!testResult) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "regex",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "trim") {
        input.data = input.data.trim();
      } else if (check.kind === "startsWith") {
        if (!input.data.startsWith(check.value)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_string,
            validation: { startsWith: check.value },
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "endsWith") {
        if (!input.data.endsWith(check.value)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_string,
            validation: { endsWith: check.value },
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "datetime") {
        const regex = datetimeRegex(check);
        if (!regex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_string,
            validation: "datetime",
            message: check.message
          });
          status.dirty();
        }
      } else {
        util.assertNever(check);
      }
    }
    return { status: status.value, value: input.data };
  }
  _addCheck(check) {
    return new ZodString({
      ...this._def,
      checks: [...this._def.checks, check]
    });
  }
  email(message) {
    return this._addCheck({ kind: "email", ...errorUtil.errToObj(message) });
  }
  url(message) {
    return this._addCheck({ kind: "url", ...errorUtil.errToObj(message) });
  }
  uuid(message) {
    return this._addCheck({ kind: "uuid", ...errorUtil.errToObj(message) });
  }
  cuid(message) {
    return this._addCheck({ kind: "cuid", ...errorUtil.errToObj(message) });
  }
  datetime(options) {
    var _a;
    if (typeof options === "string") {
      return this._addCheck({
        kind: "datetime",
        precision: null,
        offset: false,
        message: options
      });
    }
    return this._addCheck({
      kind: "datetime",
      precision: typeof (options === null || options === void 0 ? void 0 : options.precision) === "undefined" ? null : options === null || options === void 0 ? void 0 : options.precision,
      offset: (_a = options === null || options === void 0 ? void 0 : options.offset) !== null && _a !== void 0 ? _a : false,
      ...errorUtil.errToObj(options === null || options === void 0 ? void 0 : options.message)
    });
  }
  regex(regex, message) {
    return this._addCheck({
      kind: "regex",
      regex,
      ...errorUtil.errToObj(message)
    });
  }
  startsWith(value, message) {
    return this._addCheck({
      kind: "startsWith",
      value,
      ...errorUtil.errToObj(message)
    });
  }
  endsWith(value, message) {
    return this._addCheck({
      kind: "endsWith",
      value,
      ...errorUtil.errToObj(message)
    });
  }
  min(minLength, message) {
    return this._addCheck({
      kind: "min",
      value: minLength,
      ...errorUtil.errToObj(message)
    });
  }
  max(maxLength, message) {
    return this._addCheck({
      kind: "max",
      value: maxLength,
      ...errorUtil.errToObj(message)
    });
  }
  length(len, message) {
    return this._addCheck({
      kind: "length",
      value: len,
      ...errorUtil.errToObj(message)
    });
  }
  get isDatetime() {
    return !!this._def.checks.find((ch) => ch.kind === "datetime");
  }
  get isEmail() {
    return !!this._def.checks.find((ch) => ch.kind === "email");
  }
  get isURL() {
    return !!this._def.checks.find((ch) => ch.kind === "url");
  }
  get isUUID() {
    return !!this._def.checks.find((ch) => ch.kind === "uuid");
  }
  get isCUID() {
    return !!this._def.checks.find((ch) => ch.kind === "cuid");
  }
  get minLength() {
    let min = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "min") {
        if (min === null || ch.value > min)
          min = ch.value;
      }
    }
    return min;
  }
  get maxLength() {
    let max = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "max") {
        if (max === null || ch.value < max)
          max = ch.value;
      }
    }
    return max;
  }
};
ZodString.create = (params) => {
  var _a;
  return new ZodString({
    checks: [],
    typeName: ZodFirstPartyTypeKind.ZodString,
    coerce: (_a = params === null || params === void 0 ? void 0 : params.coerce) !== null && _a !== void 0 ? _a : false,
    ...processCreateParams(params)
  });
};
function floatSafeRemainder(val, step) {
  const valDecCount = (val.toString().split(".")[1] || "").length;
  const stepDecCount = (step.toString().split(".")[1] || "").length;
  const decCount = valDecCount > stepDecCount ? valDecCount : stepDecCount;
  const valInt = parseInt(val.toFixed(decCount).replace(".", ""));
  const stepInt = parseInt(step.toFixed(decCount).replace(".", ""));
  return valInt % stepInt / Math.pow(10, decCount);
}
var ZodNumber = class extends ZodType {
  constructor() {
    super(...arguments);
    this.min = this.gte;
    this.max = this.lte;
    this.step = this.multipleOf;
  }
  _parse(input) {
    if (this._def.coerce) {
      input.data = Number(input.data);
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.number) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.number,
        received: ctx2.parsedType
      });
      return INVALID;
    }
    let ctx = void 0;
    const status = new ParseStatus();
    for (const check of this._def.checks) {
      if (check.kind === "int") {
        if (!util.isInteger(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_type,
            expected: "integer",
            received: "float",
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "min") {
        const tooSmall = check.inclusive ? input.data < check.value : input.data <= check.value;
        if (tooSmall) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_small,
            minimum: check.value,
            type: "number",
            inclusive: check.inclusive,
            exact: false,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "max") {
        const tooBig = check.inclusive ? input.data > check.value : input.data >= check.value;
        if (tooBig) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_big,
            maximum: check.value,
            type: "number",
            inclusive: check.inclusive,
            exact: false,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "multipleOf") {
        if (floatSafeRemainder(input.data, check.value) !== 0) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.not_multiple_of,
            multipleOf: check.value,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "finite") {
        if (!Number.isFinite(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.not_finite,
            message: check.message
          });
          status.dirty();
        }
      } else {
        util.assertNever(check);
      }
    }
    return { status: status.value, value: input.data };
  }
  gte(value, message) {
    return this.setLimit("min", value, true, errorUtil.toString(message));
  }
  gt(value, message) {
    return this.setLimit("min", value, false, errorUtil.toString(message));
  }
  lte(value, message) {
    return this.setLimit("max", value, true, errorUtil.toString(message));
  }
  lt(value, message) {
    return this.setLimit("max", value, false, errorUtil.toString(message));
  }
  setLimit(kind, value, inclusive, message) {
    return new ZodNumber({
      ...this._def,
      checks: [
        ...this._def.checks,
        {
          kind,
          value,
          inclusive,
          message: errorUtil.toString(message)
        }
      ]
    });
  }
  _addCheck(check) {
    return new ZodNumber({
      ...this._def,
      checks: [...this._def.checks, check]
    });
  }
  int(message) {
    return this._addCheck({
      kind: "int",
      message: errorUtil.toString(message)
    });
  }
  positive(message) {
    return this._addCheck({
      kind: "min",
      value: 0,
      inclusive: false,
      message: errorUtil.toString(message)
    });
  }
  negative(message) {
    return this._addCheck({
      kind: "max",
      value: 0,
      inclusive: false,
      message: errorUtil.toString(message)
    });
  }
  nonpositive(message) {
    return this._addCheck({
      kind: "max",
      value: 0,
      inclusive: true,
      message: errorUtil.toString(message)
    });
  }
  nonnegative(message) {
    return this._addCheck({
      kind: "min",
      value: 0,
      inclusive: true,
      message: errorUtil.toString(message)
    });
  }
  multipleOf(value, message) {
    return this._addCheck({
      kind: "multipleOf",
      value,
      message: errorUtil.toString(message)
    });
  }
  finite(message) {
    return this._addCheck({
      kind: "finite",
      message: errorUtil.toString(message)
    });
  }
  get minValue() {
    let min = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "min") {
        if (min === null || ch.value > min)
          min = ch.value;
      }
    }
    return min;
  }
  get maxValue() {
    let max = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "max") {
        if (max === null || ch.value < max)
          max = ch.value;
      }
    }
    return max;
  }
  get isInt() {
    return !!this._def.checks.find((ch) => ch.kind === "int");
  }
};
ZodNumber.create = (params) => {
  return new ZodNumber({
    checks: [],
    typeName: ZodFirstPartyTypeKind.ZodNumber,
    coerce: (params === null || params === void 0 ? void 0 : params.coerce) || false,
    ...processCreateParams(params)
  });
};
var ZodBigInt = class extends ZodType {
  _parse(input) {
    if (this._def.coerce) {
      input.data = BigInt(input.data);
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.bigint) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.bigint,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return OK(input.data);
  }
};
ZodBigInt.create = (params) => {
  var _a;
  return new ZodBigInt({
    typeName: ZodFirstPartyTypeKind.ZodBigInt,
    coerce: (_a = params === null || params === void 0 ? void 0 : params.coerce) !== null && _a !== void 0 ? _a : false,
    ...processCreateParams(params)
  });
};
var ZodBoolean = class extends ZodType {
  _parse(input) {
    if (this._def.coerce) {
      input.data = Boolean(input.data);
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.boolean) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.boolean,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return OK(input.data);
  }
};
ZodBoolean.create = (params) => {
  return new ZodBoolean({
    typeName: ZodFirstPartyTypeKind.ZodBoolean,
    coerce: (params === null || params === void 0 ? void 0 : params.coerce) || false,
    ...processCreateParams(params)
  });
};
var ZodDate = class extends ZodType {
  _parse(input) {
    if (this._def.coerce) {
      input.data = new Date(input.data);
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.date) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.date,
        received: ctx2.parsedType
      });
      return INVALID;
    }
    if (isNaN(input.data.getTime())) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_date
      });
      return INVALID;
    }
    const status = new ParseStatus();
    let ctx = void 0;
    for (const check of this._def.checks) {
      if (check.kind === "min") {
        if (input.data.getTime() < check.value) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_small,
            message: check.message,
            inclusive: true,
            exact: false,
            minimum: check.value,
            type: "date"
          });
          status.dirty();
        }
      } else if (check.kind === "max") {
        if (input.data.getTime() > check.value) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_big,
            message: check.message,
            inclusive: true,
            exact: false,
            maximum: check.value,
            type: "date"
          });
          status.dirty();
        }
      } else {
        util.assertNever(check);
      }
    }
    return {
      status: status.value,
      value: new Date(input.data.getTime())
    };
  }
  _addCheck(check) {
    return new ZodDate({
      ...this._def,
      checks: [...this._def.checks, check]
    });
  }
  min(minDate, message) {
    return this._addCheck({
      kind: "min",
      value: minDate.getTime(),
      message: errorUtil.toString(message)
    });
  }
  max(maxDate, message) {
    return this._addCheck({
      kind: "max",
      value: maxDate.getTime(),
      message: errorUtil.toString(message)
    });
  }
  get minDate() {
    let min = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "min") {
        if (min === null || ch.value > min)
          min = ch.value;
      }
    }
    return min != null ? new Date(min) : null;
  }
  get maxDate() {
    let max = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "max") {
        if (max === null || ch.value < max)
          max = ch.value;
      }
    }
    return max != null ? new Date(max) : null;
  }
};
ZodDate.create = (params) => {
  return new ZodDate({
    checks: [],
    coerce: (params === null || params === void 0 ? void 0 : params.coerce) || false,
    typeName: ZodFirstPartyTypeKind.ZodDate,
    ...processCreateParams(params)
  });
};
var ZodSymbol = class extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.symbol) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.symbol,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return OK(input.data);
  }
};
ZodSymbol.create = (params) => {
  return new ZodSymbol({
    typeName: ZodFirstPartyTypeKind.ZodSymbol,
    ...processCreateParams(params)
  });
};
var ZodUndefined = class extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.undefined) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.undefined,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return OK(input.data);
  }
};
ZodUndefined.create = (params) => {
  return new ZodUndefined({
    typeName: ZodFirstPartyTypeKind.ZodUndefined,
    ...processCreateParams(params)
  });
};
var ZodNull = class extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.null) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.null,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return OK(input.data);
  }
};
ZodNull.create = (params) => {
  return new ZodNull({
    typeName: ZodFirstPartyTypeKind.ZodNull,
    ...processCreateParams(params)
  });
};
var ZodAny = class extends ZodType {
  constructor() {
    super(...arguments);
    this._any = true;
  }
  _parse(input) {
    return OK(input.data);
  }
};
ZodAny.create = (params) => {
  return new ZodAny({
    typeName: ZodFirstPartyTypeKind.ZodAny,
    ...processCreateParams(params)
  });
};
var ZodUnknown = class extends ZodType {
  constructor() {
    super(...arguments);
    this._unknown = true;
  }
  _parse(input) {
    return OK(input.data);
  }
};
ZodUnknown.create = (params) => {
  return new ZodUnknown({
    typeName: ZodFirstPartyTypeKind.ZodUnknown,
    ...processCreateParams(params)
  });
};
var ZodNever = class extends ZodType {
  _parse(input) {
    const ctx = this._getOrReturnCtx(input);
    addIssueToContext(ctx, {
      code: ZodIssueCode.invalid_type,
      expected: ZodParsedType.never,
      received: ctx.parsedType
    });
    return INVALID;
  }
};
ZodNever.create = (params) => {
  return new ZodNever({
    typeName: ZodFirstPartyTypeKind.ZodNever,
    ...processCreateParams(params)
  });
};
var ZodVoid = class extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.undefined) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.void,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return OK(input.data);
  }
};
ZodVoid.create = (params) => {
  return new ZodVoid({
    typeName: ZodFirstPartyTypeKind.ZodVoid,
    ...processCreateParams(params)
  });
};
var ZodArray = class extends ZodType {
  _parse(input) {
    const { ctx, status } = this._processInputParams(input);
    const def = this._def;
    if (ctx.parsedType !== ZodParsedType.array) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.array,
        received: ctx.parsedType
      });
      return INVALID;
    }
    if (def.exactLength !== null) {
      const tooBig = ctx.data.length > def.exactLength.value;
      const tooSmall = ctx.data.length < def.exactLength.value;
      if (tooBig || tooSmall) {
        addIssueToContext(ctx, {
          code: tooBig ? ZodIssueCode.too_big : ZodIssueCode.too_small,
          minimum: tooSmall ? def.exactLength.value : void 0,
          maximum: tooBig ? def.exactLength.value : void 0,
          type: "array",
          inclusive: true,
          exact: true,
          message: def.exactLength.message
        });
        status.dirty();
      }
    }
    if (def.minLength !== null) {
      if (ctx.data.length < def.minLength.value) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.too_small,
          minimum: def.minLength.value,
          type: "array",
          inclusive: true,
          exact: false,
          message: def.minLength.message
        });
        status.dirty();
      }
    }
    if (def.maxLength !== null) {
      if (ctx.data.length > def.maxLength.value) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.too_big,
          maximum: def.maxLength.value,
          type: "array",
          inclusive: true,
          exact: false,
          message: def.maxLength.message
        });
        status.dirty();
      }
    }
    if (ctx.common.async) {
      return Promise.all(ctx.data.map((item, i) => {
        return def.type._parseAsync(new ParseInputLazyPath(ctx, item, ctx.path, i));
      })).then((result2) => {
        return ParseStatus.mergeArray(status, result2);
      });
    }
    const result = ctx.data.map((item, i) => {
      return def.type._parseSync(new ParseInputLazyPath(ctx, item, ctx.path, i));
    });
    return ParseStatus.mergeArray(status, result);
  }
  get element() {
    return this._def.type;
  }
  min(minLength, message) {
    return new ZodArray({
      ...this._def,
      minLength: { value: minLength, message: errorUtil.toString(message) }
    });
  }
  max(maxLength, message) {
    return new ZodArray({
      ...this._def,
      maxLength: { value: maxLength, message: errorUtil.toString(message) }
    });
  }
  length(len, message) {
    return new ZodArray({
      ...this._def,
      exactLength: { value: len, message: errorUtil.toString(message) }
    });
  }
  nonempty(message) {
    return this.min(1, message);
  }
};
ZodArray.create = (schema, params) => {
  return new ZodArray({
    type: schema,
    minLength: null,
    maxLength: null,
    exactLength: null,
    typeName: ZodFirstPartyTypeKind.ZodArray,
    ...processCreateParams(params)
  });
};
var objectUtil;
(function(objectUtil2) {
  objectUtil2.mergeShapes = (first, second) => {
    return {
      ...first,
      ...second
    };
  };
})(objectUtil || (objectUtil = {}));
var AugmentFactory = (def) => (augmentation) => {
  return new ZodObject({
    ...def,
    shape: () => ({
      ...def.shape(),
      ...augmentation
    })
  });
};
function deepPartialify(schema) {
  if (schema instanceof ZodObject) {
    const newShape = {};
    for (const key in schema.shape) {
      const fieldSchema = schema.shape[key];
      newShape[key] = ZodOptional.create(deepPartialify(fieldSchema));
    }
    return new ZodObject({
      ...schema._def,
      shape: () => newShape
    });
  } else if (schema instanceof ZodArray) {
    return ZodArray.create(deepPartialify(schema.element));
  } else if (schema instanceof ZodOptional) {
    return ZodOptional.create(deepPartialify(schema.unwrap()));
  } else if (schema instanceof ZodNullable) {
    return ZodNullable.create(deepPartialify(schema.unwrap()));
  } else if (schema instanceof ZodTuple) {
    return ZodTuple.create(schema.items.map((item) => deepPartialify(item)));
  } else {
    return schema;
  }
}
var ZodObject = class extends ZodType {
  constructor() {
    super(...arguments);
    this._cached = null;
    this.nonstrict = this.passthrough;
    this.augment = AugmentFactory(this._def);
    this.extend = AugmentFactory(this._def);
  }
  _getCached() {
    if (this._cached !== null)
      return this._cached;
    const shape = this._def.shape();
    const keys = util.objectKeys(shape);
    return this._cached = { shape, keys };
  }
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.object) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.object,
        received: ctx2.parsedType
      });
      return INVALID;
    }
    const { status, ctx } = this._processInputParams(input);
    const { shape, keys: shapeKeys } = this._getCached();
    const extraKeys = [];
    if (!(this._def.catchall instanceof ZodNever && this._def.unknownKeys === "strip")) {
      for (const key in ctx.data) {
        if (!shapeKeys.includes(key)) {
          extraKeys.push(key);
        }
      }
    }
    const pairs = [];
    for (const key of shapeKeys) {
      const keyValidator = shape[key];
      const value = ctx.data[key];
      pairs.push({
        key: { status: "valid", value: key },
        value: keyValidator._parse(new ParseInputLazyPath(ctx, value, ctx.path, key)),
        alwaysSet: key in ctx.data
      });
    }
    if (this._def.catchall instanceof ZodNever) {
      const unknownKeys = this._def.unknownKeys;
      if (unknownKeys === "passthrough") {
        for (const key of extraKeys) {
          pairs.push({
            key: { status: "valid", value: key },
            value: { status: "valid", value: ctx.data[key] }
          });
        }
      } else if (unknownKeys === "strict") {
        if (extraKeys.length > 0) {
          addIssueToContext(ctx, {
            code: ZodIssueCode.unrecognized_keys,
            keys: extraKeys
          });
          status.dirty();
        }
      } else if (unknownKeys === "strip")
        ;
      else {
        throw new Error(`Internal ZodObject error: invalid unknownKeys value.`);
      }
    } else {
      const catchall = this._def.catchall;
      for (const key of extraKeys) {
        const value = ctx.data[key];
        pairs.push({
          key: { status: "valid", value: key },
          value: catchall._parse(
            new ParseInputLazyPath(ctx, value, ctx.path, key)
          ),
          alwaysSet: key in ctx.data
        });
      }
    }
    if (ctx.common.async) {
      return Promise.resolve().then(async () => {
        const syncPairs = [];
        for (const pair of pairs) {
          const key = await pair.key;
          syncPairs.push({
            key,
            value: await pair.value,
            alwaysSet: pair.alwaysSet
          });
        }
        return syncPairs;
      }).then((syncPairs) => {
        return ParseStatus.mergeObjectSync(status, syncPairs);
      });
    } else {
      return ParseStatus.mergeObjectSync(status, pairs);
    }
  }
  get shape() {
    return this._def.shape();
  }
  strict(message) {
    errorUtil.errToObj;
    return new ZodObject({
      ...this._def,
      unknownKeys: "strict",
      ...message !== void 0 ? {
        errorMap: (issue, ctx) => {
          var _a, _b, _c, _d;
          const defaultError = (_c = (_b = (_a = this._def).errorMap) === null || _b === void 0 ? void 0 : _b.call(_a, issue, ctx).message) !== null && _c !== void 0 ? _c : ctx.defaultError;
          if (issue.code === "unrecognized_keys")
            return {
              message: (_d = errorUtil.errToObj(message).message) !== null && _d !== void 0 ? _d : defaultError
            };
          return {
            message: defaultError
          };
        }
      } : {}
    });
  }
  strip() {
    return new ZodObject({
      ...this._def,
      unknownKeys: "strip"
    });
  }
  passthrough() {
    return new ZodObject({
      ...this._def,
      unknownKeys: "passthrough"
    });
  }
  setKey(key, schema) {
    return this.augment({ [key]: schema });
  }
  merge(merging) {
    const merged = new ZodObject({
      unknownKeys: merging._def.unknownKeys,
      catchall: merging._def.catchall,
      shape: () => objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
      typeName: ZodFirstPartyTypeKind.ZodObject
    });
    return merged;
  }
  catchall(index) {
    return new ZodObject({
      ...this._def,
      catchall: index
    });
  }
  pick(mask) {
    const shape = {};
    util.objectKeys(mask).map((key) => {
      if (this.shape[key])
        shape[key] = this.shape[key];
    });
    return new ZodObject({
      ...this._def,
      shape: () => shape
    });
  }
  omit(mask) {
    const shape = {};
    util.objectKeys(this.shape).map((key) => {
      if (util.objectKeys(mask).indexOf(key) === -1) {
        shape[key] = this.shape[key];
      }
    });
    return new ZodObject({
      ...this._def,
      shape: () => shape
    });
  }
  deepPartial() {
    return deepPartialify(this);
  }
  partial(mask) {
    const newShape = {};
    if (mask) {
      util.objectKeys(this.shape).map((key) => {
        if (util.objectKeys(mask).indexOf(key) === -1) {
          newShape[key] = this.shape[key];
        } else {
          newShape[key] = this.shape[key].optional();
        }
      });
      return new ZodObject({
        ...this._def,
        shape: () => newShape
      });
    } else {
      for (const key in this.shape) {
        const fieldSchema = this.shape[key];
        newShape[key] = fieldSchema.optional();
      }
    }
    return new ZodObject({
      ...this._def,
      shape: () => newShape
    });
  }
  required(mask) {
    const newShape = {};
    if (mask) {
      util.objectKeys(this.shape).map((key) => {
        if (util.objectKeys(mask).indexOf(key) === -1) {
          newShape[key] = this.shape[key];
        } else {
          const fieldSchema = this.shape[key];
          let newField = fieldSchema;
          while (newField instanceof ZodOptional) {
            newField = newField._def.innerType;
          }
          newShape[key] = newField;
        }
      });
    } else {
      for (const key in this.shape) {
        const fieldSchema = this.shape[key];
        let newField = fieldSchema;
        while (newField instanceof ZodOptional) {
          newField = newField._def.innerType;
        }
        newShape[key] = newField;
      }
    }
    return new ZodObject({
      ...this._def,
      shape: () => newShape
    });
  }
  keyof() {
    return createZodEnum(util.objectKeys(this.shape));
  }
};
ZodObject.create = (shape, params) => {
  return new ZodObject({
    shape: () => shape,
    unknownKeys: "strip",
    catchall: ZodNever.create(),
    typeName: ZodFirstPartyTypeKind.ZodObject,
    ...processCreateParams(params)
  });
};
ZodObject.strictCreate = (shape, params) => {
  return new ZodObject({
    shape: () => shape,
    unknownKeys: "strict",
    catchall: ZodNever.create(),
    typeName: ZodFirstPartyTypeKind.ZodObject,
    ...processCreateParams(params)
  });
};
ZodObject.lazycreate = (shape, params) => {
  return new ZodObject({
    shape,
    unknownKeys: "strip",
    catchall: ZodNever.create(),
    typeName: ZodFirstPartyTypeKind.ZodObject,
    ...processCreateParams(params)
  });
};
var ZodUnion = class extends ZodType {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    const options = this._def.options;
    function handleResults(results) {
      for (const result of results) {
        if (result.result.status === "valid") {
          return result.result;
        }
      }
      for (const result of results) {
        if (result.result.status === "dirty") {
          ctx.common.issues.push(...result.ctx.common.issues);
          return result.result;
        }
      }
      const unionErrors = results.map((result) => new ZodError(result.ctx.common.issues));
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_union,
        unionErrors
      });
      return INVALID;
    }
    if (ctx.common.async) {
      return Promise.all(options.map(async (option) => {
        const childCtx = {
          ...ctx,
          common: {
            ...ctx.common,
            issues: []
          },
          parent: null
        };
        return {
          result: await option._parseAsync({
            data: ctx.data,
            path: ctx.path,
            parent: childCtx
          }),
          ctx: childCtx
        };
      })).then(handleResults);
    } else {
      let dirty = void 0;
      const issues = [];
      for (const option of options) {
        const childCtx = {
          ...ctx,
          common: {
            ...ctx.common,
            issues: []
          },
          parent: null
        };
        const result = option._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: childCtx
        });
        if (result.status === "valid") {
          return result;
        } else if (result.status === "dirty" && !dirty) {
          dirty = { result, ctx: childCtx };
        }
        if (childCtx.common.issues.length) {
          issues.push(childCtx.common.issues);
        }
      }
      if (dirty) {
        ctx.common.issues.push(...dirty.ctx.common.issues);
        return dirty.result;
      }
      const unionErrors = issues.map((issues2) => new ZodError(issues2));
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_union,
        unionErrors
      });
      return INVALID;
    }
  }
  get options() {
    return this._def.options;
  }
};
ZodUnion.create = (types, params) => {
  return new ZodUnion({
    options: types,
    typeName: ZodFirstPartyTypeKind.ZodUnion,
    ...processCreateParams(params)
  });
};
var getDiscriminator = (type) => {
  if (type instanceof ZodLazy) {
    return getDiscriminator(type.schema);
  } else if (type instanceof ZodEffects) {
    return getDiscriminator(type.innerType());
  } else if (type instanceof ZodLiteral) {
    return [type.value];
  } else if (type instanceof ZodEnum) {
    return type.options;
  } else if (type instanceof ZodNativeEnum) {
    return Object.keys(type.enum);
  } else if (type instanceof ZodDefault) {
    return getDiscriminator(type._def.innerType);
  } else if (type instanceof ZodUndefined) {
    return [void 0];
  } else if (type instanceof ZodNull) {
    return [null];
  } else {
    return null;
  }
};
var ZodDiscriminatedUnion = class extends ZodType {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.object) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.object,
        received: ctx.parsedType
      });
      return INVALID;
    }
    const discriminator = this.discriminator;
    const discriminatorValue = ctx.data[discriminator];
    const option = this.optionsMap.get(discriminatorValue);
    if (!option) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_union_discriminator,
        options: Array.from(this.optionsMap.keys()),
        path: [discriminator]
      });
      return INVALID;
    }
    if (ctx.common.async) {
      return option._parseAsync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      });
    } else {
      return option._parseSync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      });
    }
  }
  get discriminator() {
    return this._def.discriminator;
  }
  get options() {
    return this._def.options;
  }
  get optionsMap() {
    return this._def.optionsMap;
  }
  static create(discriminator, options, params) {
    const optionsMap = /* @__PURE__ */ new Map();
    for (const type of options) {
      const discriminatorValues = getDiscriminator(type.shape[discriminator]);
      if (!discriminatorValues) {
        throw new Error(`A discriminator value for key \`${discriminator}\` could not be extracted from all schema options`);
      }
      for (const value of discriminatorValues) {
        if (optionsMap.has(value)) {
          throw new Error(`Discriminator property ${String(discriminator)} has duplicate value ${String(value)}`);
        }
        optionsMap.set(value, type);
      }
    }
    return new ZodDiscriminatedUnion({
      typeName: ZodFirstPartyTypeKind.ZodDiscriminatedUnion,
      discriminator,
      options,
      optionsMap,
      ...processCreateParams(params)
    });
  }
};
function mergeValues(a, b) {
  const aType = getParsedType(a);
  const bType = getParsedType(b);
  if (a === b) {
    return { valid: true, data: a };
  } else if (aType === ZodParsedType.object && bType === ZodParsedType.object) {
    const bKeys = util.objectKeys(b);
    const sharedKeys = util.objectKeys(a).filter((key) => bKeys.indexOf(key) !== -1);
    const newObj = { ...a, ...b };
    for (const key of sharedKeys) {
      const sharedValue = mergeValues(a[key], b[key]);
      if (!sharedValue.valid) {
        return { valid: false };
      }
      newObj[key] = sharedValue.data;
    }
    return { valid: true, data: newObj };
  } else if (aType === ZodParsedType.array && bType === ZodParsedType.array) {
    if (a.length !== b.length) {
      return { valid: false };
    }
    const newArray = [];
    for (let index = 0; index < a.length; index++) {
      const itemA = a[index];
      const itemB = b[index];
      const sharedValue = mergeValues(itemA, itemB);
      if (!sharedValue.valid) {
        return { valid: false };
      }
      newArray.push(sharedValue.data);
    }
    return { valid: true, data: newArray };
  } else if (aType === ZodParsedType.date && bType === ZodParsedType.date && +a === +b) {
    return { valid: true, data: a };
  } else {
    return { valid: false };
  }
}
var ZodIntersection = class extends ZodType {
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    const handleParsed = (parsedLeft, parsedRight) => {
      if (isAborted(parsedLeft) || isAborted(parsedRight)) {
        return INVALID;
      }
      const merged = mergeValues(parsedLeft.value, parsedRight.value);
      if (!merged.valid) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_intersection_types
        });
        return INVALID;
      }
      if (isDirty(parsedLeft) || isDirty(parsedRight)) {
        status.dirty();
      }
      return { status: status.value, value: merged.data };
    };
    if (ctx.common.async) {
      return Promise.all([
        this._def.left._parseAsync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        }),
        this._def.right._parseAsync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        })
      ]).then(([left, right]) => handleParsed(left, right));
    } else {
      return handleParsed(this._def.left._parseSync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      }), this._def.right._parseSync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      }));
    }
  }
};
ZodIntersection.create = (left, right, params) => {
  return new ZodIntersection({
    left,
    right,
    typeName: ZodFirstPartyTypeKind.ZodIntersection,
    ...processCreateParams(params)
  });
};
var ZodTuple = class extends ZodType {
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.array) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.array,
        received: ctx.parsedType
      });
      return INVALID;
    }
    if (ctx.data.length < this._def.items.length) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.too_small,
        minimum: this._def.items.length,
        inclusive: true,
        exact: false,
        type: "array"
      });
      return INVALID;
    }
    const rest = this._def.rest;
    if (!rest && ctx.data.length > this._def.items.length) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.too_big,
        maximum: this._def.items.length,
        inclusive: true,
        exact: false,
        type: "array"
      });
      status.dirty();
    }
    const items = ctx.data.map((item, itemIndex) => {
      const schema = this._def.items[itemIndex] || this._def.rest;
      if (!schema)
        return null;
      return schema._parse(new ParseInputLazyPath(ctx, item, ctx.path, itemIndex));
    }).filter((x) => !!x);
    if (ctx.common.async) {
      return Promise.all(items).then((results) => {
        return ParseStatus.mergeArray(status, results);
      });
    } else {
      return ParseStatus.mergeArray(status, items);
    }
  }
  get items() {
    return this._def.items;
  }
  rest(rest) {
    return new ZodTuple({
      ...this._def,
      rest
    });
  }
};
ZodTuple.create = (schemas, params) => {
  if (!Array.isArray(schemas)) {
    throw new Error("You must pass an array of schemas to z.tuple([ ... ])");
  }
  return new ZodTuple({
    items: schemas,
    typeName: ZodFirstPartyTypeKind.ZodTuple,
    rest: null,
    ...processCreateParams(params)
  });
};
var ZodRecord = class extends ZodType {
  get keySchema() {
    return this._def.keyType;
  }
  get valueSchema() {
    return this._def.valueType;
  }
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.object) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.object,
        received: ctx.parsedType
      });
      return INVALID;
    }
    const pairs = [];
    const keyType = this._def.keyType;
    const valueType = this._def.valueType;
    for (const key in ctx.data) {
      pairs.push({
        key: keyType._parse(new ParseInputLazyPath(ctx, key, ctx.path, key)),
        value: valueType._parse(new ParseInputLazyPath(ctx, ctx.data[key], ctx.path, key))
      });
    }
    if (ctx.common.async) {
      return ParseStatus.mergeObjectAsync(status, pairs);
    } else {
      return ParseStatus.mergeObjectSync(status, pairs);
    }
  }
  get element() {
    return this._def.valueType;
  }
  static create(first, second, third) {
    if (second instanceof ZodType) {
      return new ZodRecord({
        keyType: first,
        valueType: second,
        typeName: ZodFirstPartyTypeKind.ZodRecord,
        ...processCreateParams(third)
      });
    }
    return new ZodRecord({
      keyType: ZodString.create(),
      valueType: first,
      typeName: ZodFirstPartyTypeKind.ZodRecord,
      ...processCreateParams(second)
    });
  }
};
var ZodMap = class extends ZodType {
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.map) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.map,
        received: ctx.parsedType
      });
      return INVALID;
    }
    const keyType = this._def.keyType;
    const valueType = this._def.valueType;
    const pairs = [...ctx.data.entries()].map(([key, value], index) => {
      return {
        key: keyType._parse(new ParseInputLazyPath(ctx, key, ctx.path, [index, "key"])),
        value: valueType._parse(new ParseInputLazyPath(ctx, value, ctx.path, [index, "value"]))
      };
    });
    if (ctx.common.async) {
      const finalMap = /* @__PURE__ */ new Map();
      return Promise.resolve().then(async () => {
        for (const pair of pairs) {
          const key = await pair.key;
          const value = await pair.value;
          if (key.status === "aborted" || value.status === "aborted") {
            return INVALID;
          }
          if (key.status === "dirty" || value.status === "dirty") {
            status.dirty();
          }
          finalMap.set(key.value, value.value);
        }
        return { status: status.value, value: finalMap };
      });
    } else {
      const finalMap = /* @__PURE__ */ new Map();
      for (const pair of pairs) {
        const key = pair.key;
        const value = pair.value;
        if (key.status === "aborted" || value.status === "aborted") {
          return INVALID;
        }
        if (key.status === "dirty" || value.status === "dirty") {
          status.dirty();
        }
        finalMap.set(key.value, value.value);
      }
      return { status: status.value, value: finalMap };
    }
  }
};
ZodMap.create = (keyType, valueType, params) => {
  return new ZodMap({
    valueType,
    keyType,
    typeName: ZodFirstPartyTypeKind.ZodMap,
    ...processCreateParams(params)
  });
};
var ZodSet = class extends ZodType {
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.set) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.set,
        received: ctx.parsedType
      });
      return INVALID;
    }
    const def = this._def;
    if (def.minSize !== null) {
      if (ctx.data.size < def.minSize.value) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.too_small,
          minimum: def.minSize.value,
          type: "set",
          inclusive: true,
          exact: false,
          message: def.minSize.message
        });
        status.dirty();
      }
    }
    if (def.maxSize !== null) {
      if (ctx.data.size > def.maxSize.value) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.too_big,
          maximum: def.maxSize.value,
          type: "set",
          inclusive: true,
          exact: false,
          message: def.maxSize.message
        });
        status.dirty();
      }
    }
    const valueType = this._def.valueType;
    function finalizeSet(elements2) {
      const parsedSet = /* @__PURE__ */ new Set();
      for (const element of elements2) {
        if (element.status === "aborted")
          return INVALID;
        if (element.status === "dirty")
          status.dirty();
        parsedSet.add(element.value);
      }
      return { status: status.value, value: parsedSet };
    }
    const elements = [...ctx.data.values()].map((item, i) => valueType._parse(new ParseInputLazyPath(ctx, item, ctx.path, i)));
    if (ctx.common.async) {
      return Promise.all(elements).then((elements2) => finalizeSet(elements2));
    } else {
      return finalizeSet(elements);
    }
  }
  min(minSize, message) {
    return new ZodSet({
      ...this._def,
      minSize: { value: minSize, message: errorUtil.toString(message) }
    });
  }
  max(maxSize, message) {
    return new ZodSet({
      ...this._def,
      maxSize: { value: maxSize, message: errorUtil.toString(message) }
    });
  }
  size(size, message) {
    return this.min(size, message).max(size, message);
  }
  nonempty(message) {
    return this.min(1, message);
  }
};
ZodSet.create = (valueType, params) => {
  return new ZodSet({
    valueType,
    minSize: null,
    maxSize: null,
    typeName: ZodFirstPartyTypeKind.ZodSet,
    ...processCreateParams(params)
  });
};
var ZodFunction = class extends ZodType {
  constructor() {
    super(...arguments);
    this.validate = this.implement;
  }
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.function) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.function,
        received: ctx.parsedType
      });
      return INVALID;
    }
    function makeArgsIssue(args, error) {
      return makeIssue({
        data: args,
        path: ctx.path,
        errorMaps: [
          ctx.common.contextualErrorMap,
          ctx.schemaErrorMap,
          getErrorMap(),
          errorMap
        ].filter((x) => !!x),
        issueData: {
          code: ZodIssueCode.invalid_arguments,
          argumentsError: error
        }
      });
    }
    function makeReturnsIssue(returns, error) {
      return makeIssue({
        data: returns,
        path: ctx.path,
        errorMaps: [
          ctx.common.contextualErrorMap,
          ctx.schemaErrorMap,
          getErrorMap(),
          errorMap
        ].filter((x) => !!x),
        issueData: {
          code: ZodIssueCode.invalid_return_type,
          returnTypeError: error
        }
      });
    }
    const params = { errorMap: ctx.common.contextualErrorMap };
    const fn = ctx.data;
    if (this._def.returns instanceof ZodPromise) {
      return OK(async (...args) => {
        const error = new ZodError([]);
        const parsedArgs = await this._def.args.parseAsync(args, params).catch((e) => {
          error.addIssue(makeArgsIssue(args, e));
          throw error;
        });
        const result = await fn(...parsedArgs);
        const parsedReturns = await this._def.returns._def.type.parseAsync(result, params).catch((e) => {
          error.addIssue(makeReturnsIssue(result, e));
          throw error;
        });
        return parsedReturns;
      });
    } else {
      return OK((...args) => {
        const parsedArgs = this._def.args.safeParse(args, params);
        if (!parsedArgs.success) {
          throw new ZodError([makeArgsIssue(args, parsedArgs.error)]);
        }
        const result = fn(...parsedArgs.data);
        const parsedReturns = this._def.returns.safeParse(result, params);
        if (!parsedReturns.success) {
          throw new ZodError([makeReturnsIssue(result, parsedReturns.error)]);
        }
        return parsedReturns.data;
      });
    }
  }
  parameters() {
    return this._def.args;
  }
  returnType() {
    return this._def.returns;
  }
  args(...items) {
    return new ZodFunction({
      ...this._def,
      args: ZodTuple.create(items).rest(ZodUnknown.create())
    });
  }
  returns(returnType) {
    return new ZodFunction({
      ...this._def,
      returns: returnType
    });
  }
  implement(func) {
    const validatedFunc = this.parse(func);
    return validatedFunc;
  }
  strictImplement(func) {
    const validatedFunc = this.parse(func);
    return validatedFunc;
  }
  static create(args, returns, params) {
    return new ZodFunction({
      args: args ? args : ZodTuple.create([]).rest(ZodUnknown.create()),
      returns: returns || ZodUnknown.create(),
      typeName: ZodFirstPartyTypeKind.ZodFunction,
      ...processCreateParams(params)
    });
  }
};
var ZodLazy = class extends ZodType {
  get schema() {
    return this._def.getter();
  }
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    const lazySchema = this._def.getter();
    return lazySchema._parse({ data: ctx.data, path: ctx.path, parent: ctx });
  }
};
ZodLazy.create = (getter, params) => {
  return new ZodLazy({
    getter,
    typeName: ZodFirstPartyTypeKind.ZodLazy,
    ...processCreateParams(params)
  });
};
var ZodLiteral = class extends ZodType {
  _parse(input) {
    if (input.data !== this._def.value) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_literal,
        expected: this._def.value
      });
      return INVALID;
    }
    return { status: "valid", value: input.data };
  }
  get value() {
    return this._def.value;
  }
};
ZodLiteral.create = (value, params) => {
  return new ZodLiteral({
    value,
    typeName: ZodFirstPartyTypeKind.ZodLiteral,
    ...processCreateParams(params)
  });
};
function createZodEnum(values, params) {
  return new ZodEnum({
    values,
    typeName: ZodFirstPartyTypeKind.ZodEnum,
    ...processCreateParams(params)
  });
}
var ZodEnum = class extends ZodType {
  _parse(input) {
    if (typeof input.data !== "string") {
      const ctx = this._getOrReturnCtx(input);
      const expectedValues = this._def.values;
      addIssueToContext(ctx, {
        expected: util.joinValues(expectedValues),
        received: ctx.parsedType,
        code: ZodIssueCode.invalid_type
      });
      return INVALID;
    }
    if (this._def.values.indexOf(input.data) === -1) {
      const ctx = this._getOrReturnCtx(input);
      const expectedValues = this._def.values;
      addIssueToContext(ctx, {
        received: ctx.data,
        code: ZodIssueCode.invalid_enum_value,
        options: expectedValues
      });
      return INVALID;
    }
    return OK(input.data);
  }
  get options() {
    return this._def.values;
  }
  get enum() {
    const enumValues = {};
    for (const val of this._def.values) {
      enumValues[val] = val;
    }
    return enumValues;
  }
  get Values() {
    const enumValues = {};
    for (const val of this._def.values) {
      enumValues[val] = val;
    }
    return enumValues;
  }
  get Enum() {
    const enumValues = {};
    for (const val of this._def.values) {
      enumValues[val] = val;
    }
    return enumValues;
  }
};
ZodEnum.create = createZodEnum;
var ZodNativeEnum = class extends ZodType {
  _parse(input) {
    const nativeEnumValues = util.getValidEnumValues(this._def.values);
    const ctx = this._getOrReturnCtx(input);
    if (ctx.parsedType !== ZodParsedType.string && ctx.parsedType !== ZodParsedType.number) {
      const expectedValues = util.objectValues(nativeEnumValues);
      addIssueToContext(ctx, {
        expected: util.joinValues(expectedValues),
        received: ctx.parsedType,
        code: ZodIssueCode.invalid_type
      });
      return INVALID;
    }
    if (nativeEnumValues.indexOf(input.data) === -1) {
      const expectedValues = util.objectValues(nativeEnumValues);
      addIssueToContext(ctx, {
        received: ctx.data,
        code: ZodIssueCode.invalid_enum_value,
        options: expectedValues
      });
      return INVALID;
    }
    return OK(input.data);
  }
  get enum() {
    return this._def.values;
  }
};
ZodNativeEnum.create = (values, params) => {
  return new ZodNativeEnum({
    values,
    typeName: ZodFirstPartyTypeKind.ZodNativeEnum,
    ...processCreateParams(params)
  });
};
var ZodPromise = class extends ZodType {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.promise && ctx.common.async === false) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.promise,
        received: ctx.parsedType
      });
      return INVALID;
    }
    const promisified = ctx.parsedType === ZodParsedType.promise ? ctx.data : Promise.resolve(ctx.data);
    return OK(promisified.then((data) => {
      return this._def.type.parseAsync(data, {
        path: ctx.path,
        errorMap: ctx.common.contextualErrorMap
      });
    }));
  }
};
ZodPromise.create = (schema, params) => {
  return new ZodPromise({
    type: schema,
    typeName: ZodFirstPartyTypeKind.ZodPromise,
    ...processCreateParams(params)
  });
};
var ZodEffects = class extends ZodType {
  innerType() {
    return this._def.schema;
  }
  sourceType() {
    return this._def.schema._def.typeName === ZodFirstPartyTypeKind.ZodEffects ? this._def.schema.sourceType() : this._def.schema;
  }
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    const effect = this._def.effect || null;
    if (effect.type === "preprocess") {
      const processed = effect.transform(ctx.data);
      if (ctx.common.async) {
        return Promise.resolve(processed).then((processed2) => {
          return this._def.schema._parseAsync({
            data: processed2,
            path: ctx.path,
            parent: ctx
          });
        });
      } else {
        return this._def.schema._parseSync({
          data: processed,
          path: ctx.path,
          parent: ctx
        });
      }
    }
    const checkCtx = {
      addIssue: (arg) => {
        addIssueToContext(ctx, arg);
        if (arg.fatal) {
          status.abort();
        } else {
          status.dirty();
        }
      },
      get path() {
        return ctx.path;
      }
    };
    checkCtx.addIssue = checkCtx.addIssue.bind(checkCtx);
    if (effect.type === "refinement") {
      const executeRefinement = (acc) => {
        const result = effect.refinement(acc, checkCtx);
        if (ctx.common.async) {
          return Promise.resolve(result);
        }
        if (result instanceof Promise) {
          throw new Error("Async refinement encountered during synchronous parse operation. Use .parseAsync instead.");
        }
        return acc;
      };
      if (ctx.common.async === false) {
        const inner = this._def.schema._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        });
        if (inner.status === "aborted")
          return INVALID;
        if (inner.status === "dirty")
          status.dirty();
        executeRefinement(inner.value);
        return { status: status.value, value: inner.value };
      } else {
        return this._def.schema._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx }).then((inner) => {
          if (inner.status === "aborted")
            return INVALID;
          if (inner.status === "dirty")
            status.dirty();
          return executeRefinement(inner.value).then(() => {
            return { status: status.value, value: inner.value };
          });
        });
      }
    }
    if (effect.type === "transform") {
      if (ctx.common.async === false) {
        const base = this._def.schema._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        });
        if (!isValid(base))
          return base;
        const result = effect.transform(base.value, checkCtx);
        if (result instanceof Promise) {
          throw new Error(`Asynchronous transform encountered during synchronous parse operation. Use .parseAsync instead.`);
        }
        return { status: status.value, value: result };
      } else {
        return this._def.schema._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx }).then((base) => {
          if (!isValid(base))
            return base;
          return Promise.resolve(effect.transform(base.value, checkCtx)).then((result) => ({ status: status.value, value: result }));
        });
      }
    }
    util.assertNever(effect);
  }
};
ZodEffects.create = (schema, effect, params) => {
  return new ZodEffects({
    schema,
    typeName: ZodFirstPartyTypeKind.ZodEffects,
    effect,
    ...processCreateParams(params)
  });
};
ZodEffects.createWithPreprocess = (preprocess, schema, params) => {
  return new ZodEffects({
    schema,
    effect: { type: "preprocess", transform: preprocess },
    typeName: ZodFirstPartyTypeKind.ZodEffects,
    ...processCreateParams(params)
  });
};
var ZodOptional = class extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType === ZodParsedType.undefined) {
      return OK(void 0);
    }
    return this._def.innerType._parse(input);
  }
  unwrap() {
    return this._def.innerType;
  }
};
ZodOptional.create = (type, params) => {
  return new ZodOptional({
    innerType: type,
    typeName: ZodFirstPartyTypeKind.ZodOptional,
    ...processCreateParams(params)
  });
};
var ZodNullable = class extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType === ZodParsedType.null) {
      return OK(null);
    }
    return this._def.innerType._parse(input);
  }
  unwrap() {
    return this._def.innerType;
  }
};
ZodNullable.create = (type, params) => {
  return new ZodNullable({
    innerType: type,
    typeName: ZodFirstPartyTypeKind.ZodNullable,
    ...processCreateParams(params)
  });
};
var ZodDefault = class extends ZodType {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    let data = ctx.data;
    if (ctx.parsedType === ZodParsedType.undefined) {
      data = this._def.defaultValue();
    }
    return this._def.innerType._parse({
      data,
      path: ctx.path,
      parent: ctx
    });
  }
  removeDefault() {
    return this._def.innerType;
  }
};
ZodDefault.create = (type, params) => {
  return new ZodDefault({
    innerType: type,
    typeName: ZodFirstPartyTypeKind.ZodDefault,
    defaultValue: typeof params.default === "function" ? params.default : () => params.default,
    ...processCreateParams(params)
  });
};
var ZodCatch = class extends ZodType {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    const result = this._def.innerType._parse({
      data: ctx.data,
      path: ctx.path,
      parent: ctx
    });
    if (isAsync(result)) {
      return result.then((result2) => {
        return {
          status: "valid",
          value: result2.status === "valid" ? result2.value : this._def.defaultValue()
        };
      });
    } else {
      return {
        status: "valid",
        value: result.status === "valid" ? result.value : this._def.defaultValue()
      };
    }
  }
  removeDefault() {
    return this._def.innerType;
  }
};
ZodCatch.create = (type, params) => {
  return new ZodCatch({
    innerType: type,
    typeName: ZodFirstPartyTypeKind.ZodCatch,
    defaultValue: typeof params.default === "function" ? params.default : () => params.default,
    ...processCreateParams(params)
  });
};
var ZodNaN = class extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.nan) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.nan,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return { status: "valid", value: input.data };
  }
};
ZodNaN.create = (params) => {
  return new ZodNaN({
    typeName: ZodFirstPartyTypeKind.ZodNaN,
    ...processCreateParams(params)
  });
};
var BRAND = Symbol("zod_brand");
var ZodBranded = class extends ZodType {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    const data = ctx.data;
    return this._def.type._parse({
      data,
      path: ctx.path,
      parent: ctx
    });
  }
  unwrap() {
    return this._def.type;
  }
};
var ZodPipeline = class extends ZodType {
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.common.async) {
      const handleAsync = async () => {
        const inResult = await this._def.in._parseAsync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        });
        if (inResult.status === "aborted")
          return INVALID;
        if (inResult.status === "dirty") {
          status.dirty();
          return DIRTY(inResult.value);
        } else {
          return this._def.out._parseAsync({
            data: inResult.value,
            path: ctx.path,
            parent: ctx
          });
        }
      };
      return handleAsync();
    } else {
      const inResult = this._def.in._parseSync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      });
      if (inResult.status === "aborted")
        return INVALID;
      if (inResult.status === "dirty") {
        status.dirty();
        return {
          status: "dirty",
          value: inResult.value
        };
      } else {
        return this._def.out._parseSync({
          data: inResult.value,
          path: ctx.path,
          parent: ctx
        });
      }
    }
  }
  static create(a, b) {
    return new ZodPipeline({
      in: a,
      out: b,
      typeName: ZodFirstPartyTypeKind.ZodPipeline
    });
  }
};
var custom = (check, params = {}, fatal) => {
  if (check)
    return ZodAny.create().superRefine((data, ctx) => {
      if (!check(data)) {
        const p = typeof params === "function" ? params(data) : params;
        const p2 = typeof p === "string" ? { message: p } : p;
        ctx.addIssue({ code: "custom", ...p2, fatal });
      }
    });
  return ZodAny.create();
};
var late = {
  object: ZodObject.lazycreate
};
var ZodFirstPartyTypeKind;
(function(ZodFirstPartyTypeKind2) {
  ZodFirstPartyTypeKind2["ZodString"] = "ZodString";
  ZodFirstPartyTypeKind2["ZodNumber"] = "ZodNumber";
  ZodFirstPartyTypeKind2["ZodNaN"] = "ZodNaN";
  ZodFirstPartyTypeKind2["ZodBigInt"] = "ZodBigInt";
  ZodFirstPartyTypeKind2["ZodBoolean"] = "ZodBoolean";
  ZodFirstPartyTypeKind2["ZodDate"] = "ZodDate";
  ZodFirstPartyTypeKind2["ZodSymbol"] = "ZodSymbol";
  ZodFirstPartyTypeKind2["ZodUndefined"] = "ZodUndefined";
  ZodFirstPartyTypeKind2["ZodNull"] = "ZodNull";
  ZodFirstPartyTypeKind2["ZodAny"] = "ZodAny";
  ZodFirstPartyTypeKind2["ZodUnknown"] = "ZodUnknown";
  ZodFirstPartyTypeKind2["ZodNever"] = "ZodNever";
  ZodFirstPartyTypeKind2["ZodVoid"] = "ZodVoid";
  ZodFirstPartyTypeKind2["ZodArray"] = "ZodArray";
  ZodFirstPartyTypeKind2["ZodObject"] = "ZodObject";
  ZodFirstPartyTypeKind2["ZodUnion"] = "ZodUnion";
  ZodFirstPartyTypeKind2["ZodDiscriminatedUnion"] = "ZodDiscriminatedUnion";
  ZodFirstPartyTypeKind2["ZodIntersection"] = "ZodIntersection";
  ZodFirstPartyTypeKind2["ZodTuple"] = "ZodTuple";
  ZodFirstPartyTypeKind2["ZodRecord"] = "ZodRecord";
  ZodFirstPartyTypeKind2["ZodMap"] = "ZodMap";
  ZodFirstPartyTypeKind2["ZodSet"] = "ZodSet";
  ZodFirstPartyTypeKind2["ZodFunction"] = "ZodFunction";
  ZodFirstPartyTypeKind2["ZodLazy"] = "ZodLazy";
  ZodFirstPartyTypeKind2["ZodLiteral"] = "ZodLiteral";
  ZodFirstPartyTypeKind2["ZodEnum"] = "ZodEnum";
  ZodFirstPartyTypeKind2["ZodEffects"] = "ZodEffects";
  ZodFirstPartyTypeKind2["ZodNativeEnum"] = "ZodNativeEnum";
  ZodFirstPartyTypeKind2["ZodOptional"] = "ZodOptional";
  ZodFirstPartyTypeKind2["ZodNullable"] = "ZodNullable";
  ZodFirstPartyTypeKind2["ZodDefault"] = "ZodDefault";
  ZodFirstPartyTypeKind2["ZodCatch"] = "ZodCatch";
  ZodFirstPartyTypeKind2["ZodPromise"] = "ZodPromise";
  ZodFirstPartyTypeKind2["ZodBranded"] = "ZodBranded";
  ZodFirstPartyTypeKind2["ZodPipeline"] = "ZodPipeline";
})(ZodFirstPartyTypeKind || (ZodFirstPartyTypeKind = {}));
var instanceOfType = (cls, params = {
  message: `Input not instance of ${cls.name}`
}) => custom((data) => data instanceof cls, params, true);
var stringType = ZodString.create;
var numberType = ZodNumber.create;
var nanType = ZodNaN.create;
var bigIntType = ZodBigInt.create;
var booleanType = ZodBoolean.create;
var dateType = ZodDate.create;
var symbolType = ZodSymbol.create;
var undefinedType = ZodUndefined.create;
var nullType = ZodNull.create;
var anyType = ZodAny.create;
var unknownType = ZodUnknown.create;
var neverType = ZodNever.create;
var voidType = ZodVoid.create;
var arrayType = ZodArray.create;
var objectType = ZodObject.create;
var strictObjectType = ZodObject.strictCreate;
var unionType = ZodUnion.create;
var discriminatedUnionType = ZodDiscriminatedUnion.create;
var intersectionType = ZodIntersection.create;
var tupleType = ZodTuple.create;
var recordType = ZodRecord.create;
var mapType = ZodMap.create;
var setType = ZodSet.create;
var functionType = ZodFunction.create;
var lazyType = ZodLazy.create;
var literalType = ZodLiteral.create;
var enumType = ZodEnum.create;
var nativeEnumType = ZodNativeEnum.create;
var promiseType = ZodPromise.create;
var effectsType = ZodEffects.create;
var optionalType = ZodOptional.create;
var nullableType = ZodNullable.create;
var preprocessType = ZodEffects.createWithPreprocess;
var pipelineType = ZodPipeline.create;
var ostring = () => stringType().optional();
var onumber = () => numberType().optional();
var oboolean = () => booleanType().optional();
var coerce = {
  string: (arg) => ZodString.create({ ...arg, coerce: true }),
  number: (arg) => ZodNumber.create({ ...arg, coerce: true }),
  boolean: (arg) => ZodBoolean.create({ ...arg, coerce: true }),
  bigint: (arg) => ZodBigInt.create({ ...arg, coerce: true }),
  date: (arg) => ZodDate.create({ ...arg, coerce: true })
};
var NEVER = INVALID;
var mod = Object.freeze({
  __proto__: null,
  defaultErrorMap: errorMap,
  setErrorMap,
  getErrorMap,
  makeIssue,
  EMPTY_PATH,
  addIssueToContext,
  ParseStatus,
  INVALID,
  DIRTY,
  OK,
  isAborted,
  isDirty,
  isValid,
  isAsync,
  get util() {
    return util;
  },
  ZodParsedType,
  getParsedType,
  ZodType,
  ZodString,
  ZodNumber,
  ZodBigInt,
  ZodBoolean,
  ZodDate,
  ZodSymbol,
  ZodUndefined,
  ZodNull,
  ZodAny,
  ZodUnknown,
  ZodNever,
  ZodVoid,
  ZodArray,
  get objectUtil() {
    return objectUtil;
  },
  ZodObject,
  ZodUnion,
  ZodDiscriminatedUnion,
  ZodIntersection,
  ZodTuple,
  ZodRecord,
  ZodMap,
  ZodSet,
  ZodFunction,
  ZodLazy,
  ZodLiteral,
  ZodEnum,
  ZodNativeEnum,
  ZodPromise,
  ZodEffects,
  ZodTransformer: ZodEffects,
  ZodOptional,
  ZodNullable,
  ZodDefault,
  ZodCatch,
  ZodNaN,
  BRAND,
  ZodBranded,
  ZodPipeline,
  custom,
  Schema: ZodType,
  ZodSchema: ZodType,
  late,
  get ZodFirstPartyTypeKind() {
    return ZodFirstPartyTypeKind;
  },
  coerce,
  any: anyType,
  array: arrayType,
  bigint: bigIntType,
  boolean: booleanType,
  date: dateType,
  discriminatedUnion: discriminatedUnionType,
  effect: effectsType,
  "enum": enumType,
  "function": functionType,
  "instanceof": instanceOfType,
  intersection: intersectionType,
  lazy: lazyType,
  literal: literalType,
  map: mapType,
  nan: nanType,
  nativeEnum: nativeEnumType,
  never: neverType,
  "null": nullType,
  nullable: nullableType,
  number: numberType,
  object: objectType,
  oboolean,
  onumber,
  optional: optionalType,
  ostring,
  pipeline: pipelineType,
  preprocess: preprocessType,
  promise: promiseType,
  record: recordType,
  set: setType,
  strictObject: strictObjectType,
  string: stringType,
  symbol: symbolType,
  transformer: effectsType,
  tuple: tupleType,
  "undefined": undefinedType,
  union: unionType,
  unknown: unknownType,
  "void": voidType,
  NEVER,
  ZodIssueCode,
  quotelessJson,
  ZodError
});

// node_modules/@thirdweb-dev/sdk/dist/QueryParams-ac0149c6.esm.js
var import_bn = __toESM(require_bn());
var isBrowser = () => typeof window !== "undefined";
var FileOrBufferUnionSchema = isBrowser() ? mod.instanceof(File) : mod.instanceof(Buffer);
var FileOrBufferSchema = mod.union([FileOrBufferUnionSchema, mod.object({
  data: mod.union([FileOrBufferUnionSchema, mod.string()]),
  name: mod.string()
})]);
var FileOrBufferOrStringSchema = mod.union([FileOrBufferSchema, mod.string()]);
var MAX_BPS = 1e4;
var BytesLikeSchema = mod.union([mod.array(mod.number()), mod.string()]);
var BigNumberSchema = mod.union([mod.string(), mod.number(), mod.bigint(), mod.custom((data) => {
  return BigNumber.isBigNumber(data);
}), mod.custom((data) => {
  return import_bn.default.isBN(data);
})]).transform((arg) => {
  let str = import_bn.default.isBN(arg) ? new import_bn.default(arg).toString() : BigNumber.from(arg).toString();
  return BigNumber.from(str);
});
BigNumberSchema.transform((arg) => arg.toString());
var BigNumberTransformSchema = mod.union([mod.bigint(), mod.custom((data) => {
  return BigNumber.isBigNumber(data);
}), mod.custom((data) => {
  return import_bn.default.isBN(data);
})]).transform((arg) => {
  if (import_bn.default.isBN(arg)) {
    return new import_bn.default(arg).toString();
  }
  return BigNumber.from(arg).toString();
});
var BasisPointsSchema = mod.number().max(MAX_BPS, "Cannot exceed 100%").min(0, "Cannot be below 0%");
var PercentSchema = mod.number().max(100, "Cannot exceed 100%").min(0, "Cannot be below 0%");
var HexColor = mod.union([mod.string().regex(/^([A-Fa-f0-9]{6}|[A-Fa-f0-9]{3})$/, "Invalid hex color"), mod.string().regex(/^#([A-Fa-f0-9]{6}|[A-Fa-f0-9]{3})$/, "Invalid hex color").transform((val) => val.replace("#", "")), mod.string().length(0)]);
var AmountSchema = mod.union([mod.string().regex(/^([0-9]+\.?[0-9]*|\.[0-9]+)$/, "Invalid amount"), mod.number().min(0, "Amount cannot be negative")]).transform((arg) => typeof arg === "number" ? arg.toString() : arg);
var QuantitySchema = mod.union([AmountSchema, mod.literal("unlimited")]).default("unlimited");
var RawDateSchema = mod.date().transform((i) => {
  return BigNumber.from(Math.floor(i.getTime() / 1e3));
});
RawDateSchema.default(new Date(0));
RawDateSchema.default(new Date(Date.now() + 1e3 * 60 * 60 * 24 * 365 * 10));
var PropertiesInput = mod.object({}).catchall(mod.union([BigNumberTransformSchema, mod.unknown()]));
var OptionalPropertiesInput = mod.union([mod.array(PropertiesInput), PropertiesInput]).optional();
var CommonNFTInput = mod.object({
  name: mod.union([mod.string(), mod.number()]).optional(),
  description: mod.string().nullable().optional(),
  image: FileOrBufferOrStringSchema.nullable().optional(),
  external_url: FileOrBufferOrStringSchema.nullable().optional(),
  animation_url: FileOrBufferOrStringSchema.optional(),
  background_color: HexColor.optional(),
  properties: OptionalPropertiesInput,
  attributes: OptionalPropertiesInput
}).catchall(mod.union([BigNumberTransformSchema, mod.unknown()]));
var NFTInputOrUriSchema = mod.union([CommonNFTInput, mod.string()]);
var CommonNFTOutput = CommonNFTInput.extend({
  id: mod.string(),
  uri: mod.string(),
  image: mod.string().nullable().optional(),
  external_url: mod.string().nullable().optional(),
  animation_url: mod.string().nullable().optional()
});
var DEFAULT_API_KEY = "c6634ad2d97b74baf15ff556016830c251050e6c36b9da508ce3ec80095d3dc1";
function getRpcUrl(network) {
  return `https://${network}.rpc.thirdweb.com/${DEFAULT_API_KEY}`;
}
var DEFAULT_QUERY_ALL_COUNT = 100;
var QueryAllParamsSchema = mod.object({
  start: mod.number().default(0),
  count: mod.number().default(DEFAULT_QUERY_ALL_COUNT)
}).default({
  start: 0,
  count: DEFAULT_QUERY_ALL_COUNT
});

// node_modules/@thirdweb-dev/sdk/dist/defineProperty-e24c82ea.esm.js
function _toPrimitive(input, hint) {
  if (typeof input !== "object" || input === null)
    return input;
  var prim = input[Symbol.toPrimitive];
  if (prim !== void 0) {
    var res = prim.call(input, hint || "default");
    if (typeof res !== "object")
      return res;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (hint === "string" ? String : Number)(input);
}
function _toPropertyKey(arg) {
  var key = _toPrimitive(arg, "string");
  return typeof key === "symbol" ? key : String(key);
}
function _defineProperty(obj, key, value) {
  key = _toPropertyKey(key);
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
}

// node_modules/@thirdweb-dev/contracts-js/dist/abis/IERC165.json
var IERC165_default = [
  {
    inputs: [
      {
        internalType: "bytes4",
        name: "interfaceId",
        type: "bytes4"
      }
    ],
    name: "supportsInterface",
    outputs: [
      {
        internalType: "bool",
        name: "",
        type: "bool"
      }
    ],
    stateMutability: "view",
    type: "function"
  }
];

// node_modules/@thirdweb-dev/contracts-js/dist/abis/IERC721.json
var IERC721_default = [
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "owner",
        type: "address"
      },
      {
        indexed: true,
        internalType: "address",
        name: "approved",
        type: "address"
      },
      {
        indexed: true,
        internalType: "uint256",
        name: "tokenId",
        type: "uint256"
      }
    ],
    name: "Approval",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "owner",
        type: "address"
      },
      {
        indexed: true,
        internalType: "address",
        name: "operator",
        type: "address"
      },
      {
        indexed: false,
        internalType: "bool",
        name: "approved",
        type: "bool"
      }
    ],
    name: "ApprovalForAll",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "from",
        type: "address"
      },
      {
        indexed: true,
        internalType: "address",
        name: "to",
        type: "address"
      },
      {
        indexed: true,
        internalType: "uint256",
        name: "tokenId",
        type: "uint256"
      }
    ],
    name: "Transfer",
    type: "event"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "to",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "tokenId",
        type: "uint256"
      }
    ],
    name: "approve",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "owner",
        type: "address"
      }
    ],
    name: "balanceOf",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "tokenId",
        type: "uint256"
      }
    ],
    name: "getApproved",
    outputs: [
      {
        internalType: "address",
        name: "",
        type: "address"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "owner",
        type: "address"
      },
      {
        internalType: "address",
        name: "operator",
        type: "address"
      }
    ],
    name: "isApprovedForAll",
    outputs: [
      {
        internalType: "bool",
        name: "",
        type: "bool"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "tokenId",
        type: "uint256"
      }
    ],
    name: "ownerOf",
    outputs: [
      {
        internalType: "address",
        name: "",
        type: "address"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "from",
        type: "address"
      },
      {
        internalType: "address",
        name: "to",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "tokenId",
        type: "uint256"
      }
    ],
    name: "safeTransferFrom",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "from",
        type: "address"
      },
      {
        internalType: "address",
        name: "to",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "tokenId",
        type: "uint256"
      },
      {
        internalType: "bytes",
        name: "data",
        type: "bytes"
      }
    ],
    name: "safeTransferFrom",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "operator",
        type: "address"
      },
      {
        internalType: "bool",
        name: "_approved",
        type: "bool"
      }
    ],
    name: "setApprovalForAll",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "from",
        type: "address"
      },
      {
        internalType: "address",
        name: "to",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "tokenId",
        type: "uint256"
      }
    ],
    name: "transferFrom",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  }
];

// node_modules/@thirdweb-dev/contracts-js/dist/abis/IERC1155.json
var IERC1155_default = [
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "_owner",
        type: "address"
      },
      {
        indexed: true,
        internalType: "address",
        name: "_operator",
        type: "address"
      },
      {
        indexed: false,
        internalType: "bool",
        name: "_approved",
        type: "bool"
      }
    ],
    name: "ApprovalForAll",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "_operator",
        type: "address"
      },
      {
        indexed: true,
        internalType: "address",
        name: "_from",
        type: "address"
      },
      {
        indexed: true,
        internalType: "address",
        name: "_to",
        type: "address"
      },
      {
        indexed: false,
        internalType: "uint256[]",
        name: "_ids",
        type: "uint256[]"
      },
      {
        indexed: false,
        internalType: "uint256[]",
        name: "_values",
        type: "uint256[]"
      }
    ],
    name: "TransferBatch",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "_operator",
        type: "address"
      },
      {
        indexed: true,
        internalType: "address",
        name: "_from",
        type: "address"
      },
      {
        indexed: true,
        internalType: "address",
        name: "_to",
        type: "address"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "_id",
        type: "uint256"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "_value",
        type: "uint256"
      }
    ],
    name: "TransferSingle",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: false,
        internalType: "string",
        name: "_value",
        type: "string"
      },
      {
        indexed: true,
        internalType: "uint256",
        name: "_id",
        type: "uint256"
      }
    ],
    name: "URI",
    type: "event"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "_owner",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "_id",
        type: "uint256"
      }
    ],
    name: "balanceOf",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address[]",
        name: "_owners",
        type: "address[]"
      },
      {
        internalType: "uint256[]",
        name: "_ids",
        type: "uint256[]"
      }
    ],
    name: "balanceOfBatch",
    outputs: [
      {
        internalType: "uint256[]",
        name: "",
        type: "uint256[]"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "_owner",
        type: "address"
      },
      {
        internalType: "address",
        name: "_operator",
        type: "address"
      }
    ],
    name: "isApprovedForAll",
    outputs: [
      {
        internalType: "bool",
        name: "",
        type: "bool"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "_from",
        type: "address"
      },
      {
        internalType: "address",
        name: "_to",
        type: "address"
      },
      {
        internalType: "uint256[]",
        name: "_ids",
        type: "uint256[]"
      },
      {
        internalType: "uint256[]",
        name: "_values",
        type: "uint256[]"
      },
      {
        internalType: "bytes",
        name: "_data",
        type: "bytes"
      }
    ],
    name: "safeBatchTransferFrom",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "_from",
        type: "address"
      },
      {
        internalType: "address",
        name: "_to",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "_id",
        type: "uint256"
      },
      {
        internalType: "uint256",
        name: "_value",
        type: "uint256"
      },
      {
        internalType: "bytes",
        name: "_data",
        type: "bytes"
      }
    ],
    name: "safeTransferFrom",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "_operator",
        type: "address"
      },
      {
        internalType: "bool",
        name: "_approved",
        type: "bool"
      }
    ],
    name: "setApprovalForAll",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  }
];

// node_modules/tiny-invariant/dist/esm/tiny-invariant.js
var isProduction = false;
var prefix = "Invariant failed";
function invariant(condition, message) {
  if (condition) {
    return;
  }
  if (isProduction) {
    throw new Error(prefix);
  }
  var provided = typeof message === "function" ? message() : message;
  var value = provided ? "".concat(prefix, ": ").concat(provided) : prefix;
  throw new Error(value);
}

// node_modules/@thirdweb-dev/contracts-js/dist/abis/IThirdwebContract.json
var IThirdwebContract_default = [
  {
    inputs: [],
    name: "contractType",
    outputs: [
      {
        internalType: "bytes32",
        name: "",
        type: "bytes32"
      }
    ],
    stateMutability: "pure",
    type: "function"
  },
  {
    inputs: [],
    name: "contractURI",
    outputs: [
      {
        internalType: "string",
        name: "",
        type: "string"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "contractVersion",
    outputs: [
      {
        internalType: "uint8",
        name: "",
        type: "uint8"
      }
    ],
    stateMutability: "pure",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "string",
        name: "_uri",
        type: "string"
      }
    ],
    name: "setContractURI",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  }
];

// node_modules/@thirdweb-dev/sdk/node_modules/eventemitter3/index.mjs
var import_index = __toESM(require_eventemitter3(), 1);
var eventemitter3_default = import_index.default;

// node_modules/@thirdweb-dev/contracts-js/dist/abis/Forwarder.json
var Forwarder_default = [
  {
    inputs: [],
    stateMutability: "nonpayable",
    type: "constructor"
  },
  {
    inputs: [
      {
        components: [
          {
            internalType: "address",
            name: "from",
            type: "address"
          },
          {
            internalType: "address",
            name: "to",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "value",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "gas",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "nonce",
            type: "uint256"
          },
          {
            internalType: "bytes",
            name: "data",
            type: "bytes"
          }
        ],
        internalType: "struct Forwarder.ForwardRequest",
        name: "req",
        type: "tuple"
      },
      {
        internalType: "bytes",
        name: "signature",
        type: "bytes"
      }
    ],
    name: "execute",
    outputs: [
      {
        internalType: "bool",
        name: "",
        type: "bool"
      },
      {
        internalType: "bytes",
        name: "",
        type: "bytes"
      }
    ],
    stateMutability: "payable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "from",
        type: "address"
      }
    ],
    name: "getNonce",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        components: [
          {
            internalType: "address",
            name: "from",
            type: "address"
          },
          {
            internalType: "address",
            name: "to",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "value",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "gas",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "nonce",
            type: "uint256"
          },
          {
            internalType: "bytes",
            name: "data",
            type: "bytes"
          }
        ],
        internalType: "struct Forwarder.ForwardRequest",
        name: "req",
        type: "tuple"
      },
      {
        internalType: "bytes",
        name: "signature",
        type: "bytes"
      }
    ],
    name: "verify",
    outputs: [
      {
        internalType: "bool",
        name: "",
        type: "bool"
      }
    ],
    stateMutability: "view",
    type: "function"
  }
];

// node_modules/@thirdweb-dev/contracts-js/dist/abis/IBurnableERC20.json
var IBurnableERC20_default = [
  {
    inputs: [
      {
        internalType: "uint256",
        name: "amount",
        type: "uint256"
      }
    ],
    name: "burn",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "account",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "amount",
        type: "uint256"
      }
    ],
    name: "burnFrom",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  }
];

// node_modules/@thirdweb-dev/contracts-js/dist/abis/IDrop.json
var IDrop_default = [
  {
    anonymous: false,
    inputs: [
      {
        components: [
          {
            internalType: "uint256",
            name: "startTimestamp",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "maxClaimableSupply",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "supplyClaimed",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "quantityLimitPerWallet",
            type: "uint256"
          },
          {
            internalType: "bytes32",
            name: "merkleRoot",
            type: "bytes32"
          },
          {
            internalType: "uint256",
            name: "pricePerToken",
            type: "uint256"
          },
          {
            internalType: "address",
            name: "currency",
            type: "address"
          },
          {
            internalType: "string",
            name: "metadata",
            type: "string"
          }
        ],
        indexed: false,
        internalType: "struct IClaimCondition.ClaimCondition[]",
        name: "claimConditions",
        type: "tuple[]"
      },
      {
        indexed: false,
        internalType: "bool",
        name: "resetEligibility",
        type: "bool"
      }
    ],
    name: "ClaimConditionsUpdated",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "uint256",
        name: "claimConditionIndex",
        type: "uint256"
      },
      {
        indexed: true,
        internalType: "address",
        name: "claimer",
        type: "address"
      },
      {
        indexed: true,
        internalType: "address",
        name: "receiver",
        type: "address"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "startTokenId",
        type: "uint256"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "quantityClaimed",
        type: "uint256"
      }
    ],
    name: "TokensClaimed",
    type: "event"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "receiver",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "quantity",
        type: "uint256"
      },
      {
        internalType: "address",
        name: "currency",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "pricePerToken",
        type: "uint256"
      },
      {
        components: [
          {
            internalType: "bytes32[]",
            name: "proof",
            type: "bytes32[]"
          },
          {
            internalType: "uint256",
            name: "quantityLimitPerWallet",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "pricePerToken",
            type: "uint256"
          },
          {
            internalType: "address",
            name: "currency",
            type: "address"
          }
        ],
        internalType: "struct IDrop.AllowlistProof",
        name: "allowlistProof",
        type: "tuple"
      },
      {
        internalType: "bytes",
        name: "data",
        type: "bytes"
      }
    ],
    name: "claim",
    outputs: [],
    stateMutability: "payable",
    type: "function"
  },
  {
    inputs: [
      {
        components: [
          {
            internalType: "uint256",
            name: "startTimestamp",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "maxClaimableSupply",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "supplyClaimed",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "quantityLimitPerWallet",
            type: "uint256"
          },
          {
            internalType: "bytes32",
            name: "merkleRoot",
            type: "bytes32"
          },
          {
            internalType: "uint256",
            name: "pricePerToken",
            type: "uint256"
          },
          {
            internalType: "address",
            name: "currency",
            type: "address"
          },
          {
            internalType: "string",
            name: "metadata",
            type: "string"
          }
        ],
        internalType: "struct IClaimCondition.ClaimCondition[]",
        name: "phases",
        type: "tuple[]"
      },
      {
        internalType: "bool",
        name: "resetClaimEligibility",
        type: "bool"
      }
    ],
    name: "setClaimConditions",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  }
];

// node_modules/@thirdweb-dev/contracts-js/dist/abis/IDropSinglePhase.json
var IDropSinglePhase_default = [
  {
    anonymous: false,
    inputs: [
      {
        components: [
          {
            internalType: "uint256",
            name: "startTimestamp",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "maxClaimableSupply",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "supplyClaimed",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "quantityLimitPerWallet",
            type: "uint256"
          },
          {
            internalType: "bytes32",
            name: "merkleRoot",
            type: "bytes32"
          },
          {
            internalType: "uint256",
            name: "pricePerToken",
            type: "uint256"
          },
          {
            internalType: "address",
            name: "currency",
            type: "address"
          },
          {
            internalType: "string",
            name: "metadata",
            type: "string"
          }
        ],
        indexed: false,
        internalType: "struct IClaimCondition.ClaimCondition",
        name: "condition",
        type: "tuple"
      },
      {
        indexed: false,
        internalType: "bool",
        name: "resetEligibility",
        type: "bool"
      }
    ],
    name: "ClaimConditionUpdated",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "claimer",
        type: "address"
      },
      {
        indexed: true,
        internalType: "address",
        name: "receiver",
        type: "address"
      },
      {
        indexed: true,
        internalType: "uint256",
        name: "startTokenId",
        type: "uint256"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "quantityClaimed",
        type: "uint256"
      }
    ],
    name: "TokensClaimed",
    type: "event"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "receiver",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "quantity",
        type: "uint256"
      },
      {
        internalType: "address",
        name: "currency",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "pricePerToken",
        type: "uint256"
      },
      {
        components: [
          {
            internalType: "bytes32[]",
            name: "proof",
            type: "bytes32[]"
          },
          {
            internalType: "uint256",
            name: "quantityLimitPerWallet",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "pricePerToken",
            type: "uint256"
          },
          {
            internalType: "address",
            name: "currency",
            type: "address"
          }
        ],
        internalType: "struct IDropSinglePhase.AllowlistProof",
        name: "allowlistProof",
        type: "tuple"
      },
      {
        internalType: "bytes",
        name: "data",
        type: "bytes"
      }
    ],
    name: "claim",
    outputs: [],
    stateMutability: "payable",
    type: "function"
  },
  {
    inputs: [
      {
        components: [
          {
            internalType: "uint256",
            name: "startTimestamp",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "maxClaimableSupply",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "supplyClaimed",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "quantityLimitPerWallet",
            type: "uint256"
          },
          {
            internalType: "bytes32",
            name: "merkleRoot",
            type: "bytes32"
          },
          {
            internalType: "uint256",
            name: "pricePerToken",
            type: "uint256"
          },
          {
            internalType: "address",
            name: "currency",
            type: "address"
          },
          {
            internalType: "string",
            name: "metadata",
            type: "string"
          }
        ],
        internalType: "struct IClaimCondition.ClaimCondition",
        name: "phase",
        type: "tuple"
      },
      {
        internalType: "bool",
        name: "resetClaimEligibility",
        type: "bool"
      }
    ],
    name: "setClaimConditions",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  }
];

// node_modules/@thirdweb-dev/contracts-js/dist/abis/IDropSinglePhase_V1.json
var IDropSinglePhase_V1_default = [
  {
    anonymous: false,
    inputs: [
      {
        components: [
          {
            internalType: "uint256",
            name: "startTimestamp",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "maxClaimableSupply",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "supplyClaimed",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "quantityLimitPerTransaction",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "waitTimeInSecondsBetweenClaims",
            type: "uint256"
          },
          {
            internalType: "bytes32",
            name: "merkleRoot",
            type: "bytes32"
          },
          {
            internalType: "uint256",
            name: "pricePerToken",
            type: "uint256"
          },
          {
            internalType: "address",
            name: "currency",
            type: "address"
          }
        ],
        indexed: false,
        internalType: "struct IClaimCondition_V1.ClaimCondition",
        name: "condition",
        type: "tuple"
      },
      {
        indexed: false,
        internalType: "bool",
        name: "resetEligibility",
        type: "bool"
      }
    ],
    name: "ClaimConditionUpdated",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "claimer",
        type: "address"
      },
      {
        indexed: true,
        internalType: "address",
        name: "receiver",
        type: "address"
      },
      {
        indexed: true,
        internalType: "uint256",
        name: "startTokenId",
        type: "uint256"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "quantityClaimed",
        type: "uint256"
      }
    ],
    name: "TokensClaimed",
    type: "event"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "receiver",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "quantity",
        type: "uint256"
      },
      {
        internalType: "address",
        name: "currency",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "pricePerToken",
        type: "uint256"
      },
      {
        components: [
          {
            internalType: "bytes32[]",
            name: "proof",
            type: "bytes32[]"
          },
          {
            internalType: "uint256",
            name: "maxQuantityInAllowlist",
            type: "uint256"
          }
        ],
        internalType: "struct IDropSinglePhase_V1.AllowlistProof",
        name: "allowlistProof",
        type: "tuple"
      },
      {
        internalType: "bytes",
        name: "data",
        type: "bytes"
      }
    ],
    name: "claim",
    outputs: [],
    stateMutability: "payable",
    type: "function"
  },
  {
    inputs: [
      {
        components: [
          {
            internalType: "uint256",
            name: "startTimestamp",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "maxClaimableSupply",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "supplyClaimed",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "quantityLimitPerTransaction",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "waitTimeInSecondsBetweenClaims",
            type: "uint256"
          },
          {
            internalType: "bytes32",
            name: "merkleRoot",
            type: "bytes32"
          },
          {
            internalType: "uint256",
            name: "pricePerToken",
            type: "uint256"
          },
          {
            internalType: "address",
            name: "currency",
            type: "address"
          }
        ],
        internalType: "struct IClaimCondition_V1.ClaimCondition",
        name: "phase",
        type: "tuple"
      },
      {
        internalType: "bool",
        name: "resetClaimEligibility",
        type: "bool"
      }
    ],
    name: "setClaimConditions",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  }
];

// node_modules/@thirdweb-dev/contracts-js/dist/abis/IERC20.json
var IERC20_default = [
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "owner",
        type: "address"
      },
      {
        indexed: true,
        internalType: "address",
        name: "spender",
        type: "address"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "value",
        type: "uint256"
      }
    ],
    name: "Approval",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "from",
        type: "address"
      },
      {
        indexed: true,
        internalType: "address",
        name: "to",
        type: "address"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "value",
        type: "uint256"
      }
    ],
    name: "Transfer",
    type: "event"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "owner",
        type: "address"
      },
      {
        internalType: "address",
        name: "spender",
        type: "address"
      }
    ],
    name: "allowance",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "spender",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "value",
        type: "uint256"
      }
    ],
    name: "approve",
    outputs: [
      {
        internalType: "bool",
        name: "",
        type: "bool"
      }
    ],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "who",
        type: "address"
      }
    ],
    name: "balanceOf",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "totalSupply",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "to",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "value",
        type: "uint256"
      }
    ],
    name: "transfer",
    outputs: [
      {
        internalType: "bool",
        name: "",
        type: "bool"
      }
    ],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "from",
        type: "address"
      },
      {
        internalType: "address",
        name: "to",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "value",
        type: "uint256"
      }
    ],
    name: "transferFrom",
    outputs: [
      {
        internalType: "bool",
        name: "",
        type: "bool"
      }
    ],
    stateMutability: "nonpayable",
    type: "function"
  }
];

// node_modules/@thirdweb-dev/contracts-js/dist/abis/IMintableERC20.json
var IMintableERC20_default = [
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "mintedTo",
        type: "address"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "quantityMinted",
        type: "uint256"
      }
    ],
    name: "TokensMinted",
    type: "event"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "to",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "amount",
        type: "uint256"
      }
    ],
    name: "mintTo",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  }
];

// node_modules/@thirdweb-dev/contracts-js/dist/abis/IMulticall.json
var IMulticall_default = [
  {
    inputs: [
      {
        internalType: "bytes[]",
        name: "data",
        type: "bytes[]"
      }
    ],
    name: "multicall",
    outputs: [
      {
        internalType: "bytes[]",
        name: "results",
        type: "bytes[]"
      }
    ],
    stateMutability: "nonpayable",
    type: "function"
  }
];

// node_modules/@thirdweb-dev/contracts-js/dist/abis/ISignatureMintERC20.json
var ISignatureMintERC20_default = [
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "signer",
        type: "address"
      },
      {
        indexed: true,
        internalType: "address",
        name: "mintedTo",
        type: "address"
      },
      {
        components: [
          {
            internalType: "address",
            name: "to",
            type: "address"
          },
          {
            internalType: "address",
            name: "primarySaleRecipient",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "quantity",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "pricePerToken",
            type: "uint256"
          },
          {
            internalType: "address",
            name: "currency",
            type: "address"
          },
          {
            internalType: "uint128",
            name: "validityStartTimestamp",
            type: "uint128"
          },
          {
            internalType: "uint128",
            name: "validityEndTimestamp",
            type: "uint128"
          },
          {
            internalType: "bytes32",
            name: "uid",
            type: "bytes32"
          }
        ],
        indexed: false,
        internalType: "struct ISignatureMintERC20.MintRequest",
        name: "mintRequest",
        type: "tuple"
      }
    ],
    name: "TokensMintedWithSignature",
    type: "event"
  },
  {
    inputs: [
      {
        components: [
          {
            internalType: "address",
            name: "to",
            type: "address"
          },
          {
            internalType: "address",
            name: "primarySaleRecipient",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "quantity",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "pricePerToken",
            type: "uint256"
          },
          {
            internalType: "address",
            name: "currency",
            type: "address"
          },
          {
            internalType: "uint128",
            name: "validityStartTimestamp",
            type: "uint128"
          },
          {
            internalType: "uint128",
            name: "validityEndTimestamp",
            type: "uint128"
          },
          {
            internalType: "bytes32",
            name: "uid",
            type: "bytes32"
          }
        ],
        internalType: "struct ISignatureMintERC20.MintRequest",
        name: "req",
        type: "tuple"
      },
      {
        internalType: "bytes",
        name: "signature",
        type: "bytes"
      }
    ],
    name: "mintWithSignature",
    outputs: [
      {
        internalType: "address",
        name: "signer",
        type: "address"
      }
    ],
    stateMutability: "payable",
    type: "function"
  },
  {
    inputs: [
      {
        components: [
          {
            internalType: "address",
            name: "to",
            type: "address"
          },
          {
            internalType: "address",
            name: "primarySaleRecipient",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "quantity",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "pricePerToken",
            type: "uint256"
          },
          {
            internalType: "address",
            name: "currency",
            type: "address"
          },
          {
            internalType: "uint128",
            name: "validityStartTimestamp",
            type: "uint128"
          },
          {
            internalType: "uint128",
            name: "validityEndTimestamp",
            type: "uint128"
          },
          {
            internalType: "bytes32",
            name: "uid",
            type: "bytes32"
          }
        ],
        internalType: "struct ISignatureMintERC20.MintRequest",
        name: "req",
        type: "tuple"
      },
      {
        internalType: "bytes",
        name: "signature",
        type: "bytes"
      }
    ],
    name: "verify",
    outputs: [
      {
        internalType: "bool",
        name: "success",
        type: "bool"
      },
      {
        internalType: "address",
        name: "signer",
        type: "address"
      }
    ],
    stateMutability: "view",
    type: "function"
  }
];

// node_modules/@thirdweb-dev/contracts-js/dist/abis/IBurnableERC721.json
var IBurnableERC721_default = [
  {
    inputs: [
      {
        internalType: "uint256",
        name: "tokenId",
        type: "uint256"
      }
    ],
    name: "burn",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  }
];

// node_modules/@thirdweb-dev/contracts-js/dist/abis/IClaimableERC721.json
var IClaimableERC721_default = [
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "claimer",
        type: "address"
      },
      {
        indexed: true,
        internalType: "address",
        name: "receiver",
        type: "address"
      },
      {
        indexed: true,
        internalType: "uint256",
        name: "startTokenId",
        type: "uint256"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "quantityClaimed",
        type: "uint256"
      }
    ],
    name: "TokensClaimed",
    type: "event"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "_receiver",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "_quantity",
        type: "uint256"
      }
    ],
    name: "claim",
    outputs: [],
    stateMutability: "payable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "_claimer",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "_quantity",
        type: "uint256"
      }
    ],
    name: "verifyClaim",
    outputs: [],
    stateMutability: "view",
    type: "function"
  }
];

// node_modules/@thirdweb-dev/contracts-js/dist/abis/IDelayedReveal.json
var IDelayedReveal_default = [
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "uint256",
        name: "index",
        type: "uint256"
      },
      {
        indexed: false,
        internalType: "string",
        name: "revealedURI",
        type: "string"
      }
    ],
    name: "TokenURIRevealed",
    type: "event"
  },
  {
    inputs: [
      {
        internalType: "bytes",
        name: "data",
        type: "bytes"
      },
      {
        internalType: "bytes",
        name: "key",
        type: "bytes"
      }
    ],
    name: "encryptDecrypt",
    outputs: [
      {
        internalType: "bytes",
        name: "result",
        type: "bytes"
      }
    ],
    stateMutability: "pure",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "identifier",
        type: "uint256"
      },
      {
        internalType: "bytes",
        name: "key",
        type: "bytes"
      }
    ],
    name: "reveal",
    outputs: [
      {
        internalType: "string",
        name: "revealedURI",
        type: "string"
      }
    ],
    stateMutability: "nonpayable",
    type: "function"
  }
];

// node_modules/@thirdweb-dev/contracts-js/dist/abis/IERC721Enumerable.json
var IERC721Enumerable_default = [
  {
    inputs: [
      {
        internalType: "uint256",
        name: "_index",
        type: "uint256"
      }
    ],
    name: "tokenByIndex",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "_owner",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "_index",
        type: "uint256"
      }
    ],
    name: "tokenOfOwnerByIndex",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    stateMutability: "view",
    type: "function"
  }
];

// node_modules/@thirdweb-dev/contracts-js/dist/abis/IERC721Supply.json
var IERC721Supply_default = [
  {
    inputs: [],
    name: "totalSupply",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    stateMutability: "view",
    type: "function"
  }
];

// node_modules/@thirdweb-dev/contracts-js/dist/abis/ILazyMint.json
var ILazyMint_default = [
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "uint256",
        name: "startTokenId",
        type: "uint256"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "endTokenId",
        type: "uint256"
      },
      {
        indexed: false,
        internalType: "string",
        name: "baseURI",
        type: "string"
      },
      {
        indexed: false,
        internalType: "bytes",
        name: "encryptedBaseURI",
        type: "bytes"
      }
    ],
    name: "TokensLazyMinted",
    type: "event"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "amount",
        type: "uint256"
      },
      {
        internalType: "string",
        name: "baseURIForTokens",
        type: "string"
      },
      {
        internalType: "bytes",
        name: "extraData",
        type: "bytes"
      }
    ],
    name: "lazyMint",
    outputs: [
      {
        internalType: "uint256",
        name: "batchId",
        type: "uint256"
      }
    ],
    stateMutability: "nonpayable",
    type: "function"
  }
];

// node_modules/@thirdweb-dev/contracts-js/dist/abis/IMintableERC721.json
var IMintableERC721_default = [
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "mintedTo",
        type: "address"
      },
      {
        indexed: true,
        internalType: "uint256",
        name: "tokenIdMinted",
        type: "uint256"
      },
      {
        indexed: false,
        internalType: "string",
        name: "uri",
        type: "string"
      }
    ],
    name: "TokensMinted",
    type: "event"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "to",
        type: "address"
      },
      {
        internalType: "string",
        name: "uri",
        type: "string"
      }
    ],
    name: "mintTo",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    stateMutability: "nonpayable",
    type: "function"
  }
];

// node_modules/@thirdweb-dev/contracts-js/dist/abis/ISignatureMintERC721.json
var ISignatureMintERC721_default = [
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "signer",
        type: "address"
      },
      {
        indexed: true,
        internalType: "address",
        name: "mintedTo",
        type: "address"
      },
      {
        indexed: true,
        internalType: "uint256",
        name: "tokenIdMinted",
        type: "uint256"
      },
      {
        components: [
          {
            internalType: "address",
            name: "to",
            type: "address"
          },
          {
            internalType: "address",
            name: "royaltyRecipient",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "royaltyBps",
            type: "uint256"
          },
          {
            internalType: "address",
            name: "primarySaleRecipient",
            type: "address"
          },
          {
            internalType: "string",
            name: "uri",
            type: "string"
          },
          {
            internalType: "uint256",
            name: "quantity",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "pricePerToken",
            type: "uint256"
          },
          {
            internalType: "address",
            name: "currency",
            type: "address"
          },
          {
            internalType: "uint128",
            name: "validityStartTimestamp",
            type: "uint128"
          },
          {
            internalType: "uint128",
            name: "validityEndTimestamp",
            type: "uint128"
          },
          {
            internalType: "bytes32",
            name: "uid",
            type: "bytes32"
          }
        ],
        indexed: false,
        internalType: "struct ISignatureMintERC721.MintRequest",
        name: "mintRequest",
        type: "tuple"
      }
    ],
    name: "TokensMintedWithSignature",
    type: "event"
  },
  {
    inputs: [
      {
        components: [
          {
            internalType: "address",
            name: "to",
            type: "address"
          },
          {
            internalType: "address",
            name: "royaltyRecipient",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "royaltyBps",
            type: "uint256"
          },
          {
            internalType: "address",
            name: "primarySaleRecipient",
            type: "address"
          },
          {
            internalType: "string",
            name: "uri",
            type: "string"
          },
          {
            internalType: "uint256",
            name: "quantity",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "pricePerToken",
            type: "uint256"
          },
          {
            internalType: "address",
            name: "currency",
            type: "address"
          },
          {
            internalType: "uint128",
            name: "validityStartTimestamp",
            type: "uint128"
          },
          {
            internalType: "uint128",
            name: "validityEndTimestamp",
            type: "uint128"
          },
          {
            internalType: "bytes32",
            name: "uid",
            type: "bytes32"
          }
        ],
        internalType: "struct ISignatureMintERC721.MintRequest",
        name: "req",
        type: "tuple"
      },
      {
        internalType: "bytes",
        name: "signature",
        type: "bytes"
      }
    ],
    name: "mintWithSignature",
    outputs: [
      {
        internalType: "address",
        name: "signer",
        type: "address"
      }
    ],
    stateMutability: "payable",
    type: "function"
  },
  {
    inputs: [
      {
        components: [
          {
            internalType: "address",
            name: "to",
            type: "address"
          },
          {
            internalType: "address",
            name: "royaltyRecipient",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "royaltyBps",
            type: "uint256"
          },
          {
            internalType: "address",
            name: "primarySaleRecipient",
            type: "address"
          },
          {
            internalType: "string",
            name: "uri",
            type: "string"
          },
          {
            internalType: "uint256",
            name: "quantity",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "pricePerToken",
            type: "uint256"
          },
          {
            internalType: "address",
            name: "currency",
            type: "address"
          },
          {
            internalType: "uint128",
            name: "validityStartTimestamp",
            type: "uint128"
          },
          {
            internalType: "uint128",
            name: "validityEndTimestamp",
            type: "uint128"
          },
          {
            internalType: "bytes32",
            name: "uid",
            type: "bytes32"
          }
        ],
        internalType: "struct ISignatureMintERC721.MintRequest",
        name: "req",
        type: "tuple"
      },
      {
        internalType: "bytes",
        name: "signature",
        type: "bytes"
      }
    ],
    name: "verify",
    outputs: [
      {
        internalType: "bool",
        name: "success",
        type: "bool"
      },
      {
        internalType: "address",
        name: "signer",
        type: "address"
      }
    ],
    stateMutability: "view",
    type: "function"
  }
];

// node_modules/@thirdweb-dev/contracts-js/dist/abis/ISignatureMintERC721_V1.json
var ISignatureMintERC721_V1_default = [
  {
    inputs: [
      {
        components: [
          {
            internalType: "address",
            name: "to",
            type: "address"
          },
          {
            internalType: "address",
            name: "royaltyRecipient",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "royaltyBps",
            type: "uint256"
          },
          {
            internalType: "address",
            name: "primarySaleRecipient",
            type: "address"
          },
          {
            internalType: "string",
            name: "uri",
            type: "string"
          },
          {
            internalType: "uint256",
            name: "price",
            type: "uint256"
          },
          {
            internalType: "address",
            name: "currency",
            type: "address"
          },
          {
            internalType: "uint128",
            name: "validityStartTimestamp",
            type: "uint128"
          },
          {
            internalType: "uint128",
            name: "validityEndTimestamp",
            type: "uint128"
          },
          {
            internalType: "bytes32",
            name: "uid",
            type: "bytes32"
          }
        ],
        internalType: "struct ITokenERC721.MintRequest",
        name: "_req",
        type: "tuple"
      },
      {
        internalType: "bytes",
        name: "_signature",
        type: "bytes"
      }
    ],
    name: "mintWithSignature",
    outputs: [
      {
        internalType: "uint256",
        name: "tokenIdMinted",
        type: "uint256"
      }
    ],
    stateMutability: "payable",
    type: "function"
  },
  {
    inputs: [
      {
        components: [
          {
            internalType: "address",
            name: "to",
            type: "address"
          },
          {
            internalType: "address",
            name: "royaltyRecipient",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "royaltyBps",
            type: "uint256"
          },
          {
            internalType: "address",
            name: "primarySaleRecipient",
            type: "address"
          },
          {
            internalType: "string",
            name: "uri",
            type: "string"
          },
          {
            internalType: "uint256",
            name: "price",
            type: "uint256"
          },
          {
            internalType: "address",
            name: "currency",
            type: "address"
          },
          {
            internalType: "uint128",
            name: "validityStartTimestamp",
            type: "uint128"
          },
          {
            internalType: "uint128",
            name: "validityEndTimestamp",
            type: "uint128"
          },
          {
            internalType: "bytes32",
            name: "uid",
            type: "bytes32"
          }
        ],
        internalType: "struct ITokenERC721.MintRequest",
        name: "_req",
        type: "tuple"
      },
      {
        internalType: "bytes",
        name: "_signature",
        type: "bytes"
      }
    ],
    name: "verify",
    outputs: [
      {
        internalType: "bool",
        name: "",
        type: "bool"
      },
      {
        internalType: "address",
        name: "",
        type: "address"
      }
    ],
    stateMutability: "view",
    type: "function"
  }
];

// node_modules/@thirdweb-dev/contracts-js/dist/abis/LazyMintWithTier.json
var LazyMintWithTier_default = [
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "string",
        name: "tier",
        type: "string"
      },
      {
        indexed: true,
        internalType: "uint256",
        name: "startTokenId",
        type: "uint256"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "endTokenId",
        type: "uint256"
      },
      {
        indexed: false,
        internalType: "string",
        name: "baseURI",
        type: "string"
      },
      {
        indexed: false,
        internalType: "bytes",
        name: "encryptedBaseURI",
        type: "bytes"
      }
    ],
    name: "TokensLazyMinted",
    type: "event"
  },
  {
    inputs: [],
    name: "getBaseURICount",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "_index",
        type: "uint256"
      }
    ],
    name: "getBatchIdAtIndex",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "getMetadataForAllTiers",
    outputs: [
      {
        components: [
          {
            internalType: "string",
            name: "tier",
            type: "string"
          },
          {
            components: [
              {
                internalType: "uint256",
                name: "startIdInclusive",
                type: "uint256"
              },
              {
                internalType: "uint256",
                name: "endIdNonInclusive",
                type: "uint256"
              }
            ],
            internalType: "struct LazyMintWithTier.TokenRange[]",
            name: "ranges",
            type: "tuple[]"
          },
          {
            internalType: "string[]",
            name: "baseURIs",
            type: "string[]"
          }
        ],
        internalType: "struct LazyMintWithTier.TierMetadata[]",
        name: "metadataForAllTiers",
        type: "tuple[]"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "_amount",
        type: "uint256"
      },
      {
        internalType: "string",
        name: "_baseURIForTokens",
        type: "string"
      },
      {
        internalType: "string",
        name: "_tier",
        type: "string"
      },
      {
        internalType: "bytes",
        name: "_data",
        type: "bytes"
      }
    ],
    name: "lazyMint",
    outputs: [
      {
        internalType: "uint256",
        name: "batchId",
        type: "uint256"
      }
    ],
    stateMutability: "nonpayable",
    type: "function"
  }
];

// node_modules/@thirdweb-dev/contracts-js/dist/abis/IBurnableERC1155.json
var IBurnableERC1155_default = [
  {
    inputs: [
      {
        internalType: "address",
        name: "account",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "id",
        type: "uint256"
      },
      {
        internalType: "uint256",
        name: "value",
        type: "uint256"
      }
    ],
    name: "burn",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "account",
        type: "address"
      },
      {
        internalType: "uint256[]",
        name: "ids",
        type: "uint256[]"
      },
      {
        internalType: "uint256[]",
        name: "values",
        type: "uint256[]"
      }
    ],
    name: "burnBatch",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  }
];

// node_modules/@thirdweb-dev/contracts-js/dist/abis/IClaimableERC1155.json
var IClaimableERC1155_default = [
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "claimer",
        type: "address"
      },
      {
        indexed: true,
        internalType: "address",
        name: "receiver",
        type: "address"
      },
      {
        indexed: true,
        internalType: "uint256",
        name: "tokenId",
        type: "uint256"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "quantityClaimed",
        type: "uint256"
      }
    ],
    name: "TokensClaimed",
    type: "event"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "_receiver",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "_tokenId",
        type: "uint256"
      },
      {
        internalType: "uint256",
        name: "_quantity",
        type: "uint256"
      }
    ],
    name: "claim",
    outputs: [],
    stateMutability: "payable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "_claimer",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "_tokenId",
        type: "uint256"
      },
      {
        internalType: "uint256",
        name: "_quantity",
        type: "uint256"
      }
    ],
    name: "verifyClaim",
    outputs: [],
    stateMutability: "view",
    type: "function"
  }
];

// node_modules/@thirdweb-dev/contracts-js/dist/abis/IDrop1155.json
var IDrop1155_default = [
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "uint256",
        name: "tokenId",
        type: "uint256"
      },
      {
        components: [
          {
            internalType: "uint256",
            name: "startTimestamp",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "maxClaimableSupply",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "supplyClaimed",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "quantityLimitPerWallet",
            type: "uint256"
          },
          {
            internalType: "bytes32",
            name: "merkleRoot",
            type: "bytes32"
          },
          {
            internalType: "uint256",
            name: "pricePerToken",
            type: "uint256"
          },
          {
            internalType: "address",
            name: "currency",
            type: "address"
          },
          {
            internalType: "string",
            name: "metadata",
            type: "string"
          }
        ],
        indexed: false,
        internalType: "struct IClaimCondition.ClaimCondition[]",
        name: "claimConditions",
        type: "tuple[]"
      },
      {
        indexed: false,
        internalType: "bool",
        name: "resetEligibility",
        type: "bool"
      }
    ],
    name: "ClaimConditionsUpdated",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "uint256",
        name: "claimConditionIndex",
        type: "uint256"
      },
      {
        indexed: true,
        internalType: "address",
        name: "claimer",
        type: "address"
      },
      {
        indexed: true,
        internalType: "address",
        name: "receiver",
        type: "address"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "tokenId",
        type: "uint256"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "quantityClaimed",
        type: "uint256"
      }
    ],
    name: "TokensClaimed",
    type: "event"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "receiver",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "tokenId",
        type: "uint256"
      },
      {
        internalType: "uint256",
        name: "quantity",
        type: "uint256"
      },
      {
        internalType: "address",
        name: "currency",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "pricePerToken",
        type: "uint256"
      },
      {
        components: [
          {
            internalType: "bytes32[]",
            name: "proof",
            type: "bytes32[]"
          },
          {
            internalType: "uint256",
            name: "quantityLimitPerWallet",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "pricePerToken",
            type: "uint256"
          },
          {
            internalType: "address",
            name: "currency",
            type: "address"
          }
        ],
        internalType: "struct IDrop1155.AllowlistProof",
        name: "allowlistProof",
        type: "tuple"
      },
      {
        internalType: "bytes",
        name: "data",
        type: "bytes"
      }
    ],
    name: "claim",
    outputs: [],
    stateMutability: "payable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "tokenId",
        type: "uint256"
      },
      {
        components: [
          {
            internalType: "uint256",
            name: "startTimestamp",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "maxClaimableSupply",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "supplyClaimed",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "quantityLimitPerWallet",
            type: "uint256"
          },
          {
            internalType: "bytes32",
            name: "merkleRoot",
            type: "bytes32"
          },
          {
            internalType: "uint256",
            name: "pricePerToken",
            type: "uint256"
          },
          {
            internalType: "address",
            name: "currency",
            type: "address"
          },
          {
            internalType: "string",
            name: "metadata",
            type: "string"
          }
        ],
        internalType: "struct IClaimCondition.ClaimCondition[]",
        name: "phases",
        type: "tuple[]"
      },
      {
        internalType: "bool",
        name: "resetClaimEligibility",
        type: "bool"
      }
    ],
    name: "setClaimConditions",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  }
];

// node_modules/@thirdweb-dev/contracts-js/dist/abis/IDropSinglePhase1155.json
var IDropSinglePhase1155_default = [
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "uint256",
        name: "tokenId",
        type: "uint256"
      },
      {
        components: [
          {
            internalType: "uint256",
            name: "startTimestamp",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "maxClaimableSupply",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "supplyClaimed",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "quantityLimitPerWallet",
            type: "uint256"
          },
          {
            internalType: "bytes32",
            name: "merkleRoot",
            type: "bytes32"
          },
          {
            internalType: "uint256",
            name: "pricePerToken",
            type: "uint256"
          },
          {
            internalType: "address",
            name: "currency",
            type: "address"
          },
          {
            internalType: "string",
            name: "metadata",
            type: "string"
          }
        ],
        indexed: false,
        internalType: "struct IClaimCondition.ClaimCondition",
        name: "condition",
        type: "tuple"
      },
      {
        indexed: false,
        internalType: "bool",
        name: "resetEligibility",
        type: "bool"
      }
    ],
    name: "ClaimConditionUpdated",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "claimer",
        type: "address"
      },
      {
        indexed: true,
        internalType: "address",
        name: "receiver",
        type: "address"
      },
      {
        indexed: true,
        internalType: "uint256",
        name: "tokenId",
        type: "uint256"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "quantityClaimed",
        type: "uint256"
      }
    ],
    name: "TokensClaimed",
    type: "event"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "receiver",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "tokenId",
        type: "uint256"
      },
      {
        internalType: "uint256",
        name: "quantity",
        type: "uint256"
      },
      {
        internalType: "address",
        name: "currency",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "pricePerToken",
        type: "uint256"
      },
      {
        components: [
          {
            internalType: "bytes32[]",
            name: "proof",
            type: "bytes32[]"
          },
          {
            internalType: "uint256",
            name: "quantityLimitPerWallet",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "pricePerToken",
            type: "uint256"
          },
          {
            internalType: "address",
            name: "currency",
            type: "address"
          }
        ],
        internalType: "struct IDropSinglePhase1155.AllowlistProof",
        name: "allowlistProof",
        type: "tuple"
      },
      {
        internalType: "bytes",
        name: "data",
        type: "bytes"
      }
    ],
    name: "claim",
    outputs: [],
    stateMutability: "payable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "tokenId",
        type: "uint256"
      },
      {
        components: [
          {
            internalType: "uint256",
            name: "startTimestamp",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "maxClaimableSupply",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "supplyClaimed",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "quantityLimitPerWallet",
            type: "uint256"
          },
          {
            internalType: "bytes32",
            name: "merkleRoot",
            type: "bytes32"
          },
          {
            internalType: "uint256",
            name: "pricePerToken",
            type: "uint256"
          },
          {
            internalType: "address",
            name: "currency",
            type: "address"
          },
          {
            internalType: "string",
            name: "metadata",
            type: "string"
          }
        ],
        internalType: "struct IClaimCondition.ClaimCondition",
        name: "phase",
        type: "tuple"
      },
      {
        internalType: "bool",
        name: "resetClaimEligibility",
        type: "bool"
      }
    ],
    name: "setClaimConditions",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  }
];

// node_modules/@thirdweb-dev/contracts-js/dist/abis/IDropSinglePhase1155_V1.json
var IDropSinglePhase1155_V1_default = [
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "uint256",
        name: "tokenId",
        type: "uint256"
      },
      {
        components: [
          {
            internalType: "uint256",
            name: "startTimestamp",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "maxClaimableSupply",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "supplyClaimed",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "quantityLimitPerTransaction",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "waitTimeInSecondsBetweenClaims",
            type: "uint256"
          },
          {
            internalType: "bytes32",
            name: "merkleRoot",
            type: "bytes32"
          },
          {
            internalType: "uint256",
            name: "pricePerToken",
            type: "uint256"
          },
          {
            internalType: "address",
            name: "currency",
            type: "address"
          }
        ],
        indexed: false,
        internalType: "struct IClaimCondition_V1.ClaimCondition",
        name: "condition",
        type: "tuple"
      },
      {
        indexed: false,
        internalType: "bool",
        name: "resetEligibility",
        type: "bool"
      }
    ],
    name: "ClaimConditionUpdated",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "claimer",
        type: "address"
      },
      {
        indexed: true,
        internalType: "address",
        name: "receiver",
        type: "address"
      },
      {
        indexed: true,
        internalType: "uint256",
        name: "tokenId",
        type: "uint256"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "quantityClaimed",
        type: "uint256"
      }
    ],
    name: "TokensClaimed",
    type: "event"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "receiver",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "tokenId",
        type: "uint256"
      },
      {
        internalType: "uint256",
        name: "quantity",
        type: "uint256"
      },
      {
        internalType: "address",
        name: "currency",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "pricePerToken",
        type: "uint256"
      },
      {
        components: [
          {
            internalType: "bytes32[]",
            name: "proof",
            type: "bytes32[]"
          },
          {
            internalType: "uint256",
            name: "maxQuantityInAllowlist",
            type: "uint256"
          }
        ],
        internalType: "struct IDropSinglePhase1155_V1.AllowlistProof",
        name: "allowlistProof",
        type: "tuple"
      },
      {
        internalType: "bytes",
        name: "data",
        type: "bytes"
      }
    ],
    name: "claim",
    outputs: [],
    stateMutability: "payable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "tokenId",
        type: "uint256"
      },
      {
        components: [
          {
            internalType: "uint256",
            name: "startTimestamp",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "maxClaimableSupply",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "supplyClaimed",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "quantityLimitPerTransaction",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "waitTimeInSecondsBetweenClaims",
            type: "uint256"
          },
          {
            internalType: "bytes32",
            name: "merkleRoot",
            type: "bytes32"
          },
          {
            internalType: "uint256",
            name: "pricePerToken",
            type: "uint256"
          },
          {
            internalType: "address",
            name: "currency",
            type: "address"
          }
        ],
        internalType: "struct IClaimCondition_V1.ClaimCondition",
        name: "phase",
        type: "tuple"
      },
      {
        internalType: "bool",
        name: "resetClaimEligibility",
        type: "bool"
      }
    ],
    name: "setClaimConditions",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  }
];

// node_modules/@thirdweb-dev/contracts-js/dist/abis/IERC1155Enumerable.json
var IERC1155Enumerable_default = [
  {
    inputs: [],
    name: "nextTokenIdToMint",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    stateMutability: "view",
    type: "function"
  }
];

// node_modules/@thirdweb-dev/contracts-js/dist/abis/IMintableERC1155.json
var IMintableERC1155_default = [
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "mintedTo",
        type: "address"
      },
      {
        indexed: true,
        internalType: "uint256",
        name: "tokenIdMinted",
        type: "uint256"
      },
      {
        indexed: false,
        internalType: "string",
        name: "uri",
        type: "string"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "quantityMinted",
        type: "uint256"
      }
    ],
    name: "TokensMinted",
    type: "event"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "to",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "tokenId",
        type: "uint256"
      },
      {
        internalType: "string",
        name: "uri",
        type: "string"
      },
      {
        internalType: "uint256",
        name: "amount",
        type: "uint256"
      }
    ],
    name: "mintTo",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  }
];

// node_modules/@thirdweb-dev/contracts-js/dist/abis/ISignatureMintERC1155.json
var ISignatureMintERC1155_default = [
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "signer",
        type: "address"
      },
      {
        indexed: true,
        internalType: "address",
        name: "mintedTo",
        type: "address"
      },
      {
        indexed: true,
        internalType: "uint256",
        name: "tokenIdMinted",
        type: "uint256"
      },
      {
        components: [
          {
            internalType: "address",
            name: "to",
            type: "address"
          },
          {
            internalType: "address",
            name: "royaltyRecipient",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "royaltyBps",
            type: "uint256"
          },
          {
            internalType: "address",
            name: "primarySaleRecipient",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "tokenId",
            type: "uint256"
          },
          {
            internalType: "string",
            name: "uri",
            type: "string"
          },
          {
            internalType: "uint256",
            name: "quantity",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "pricePerToken",
            type: "uint256"
          },
          {
            internalType: "address",
            name: "currency",
            type: "address"
          },
          {
            internalType: "uint128",
            name: "validityStartTimestamp",
            type: "uint128"
          },
          {
            internalType: "uint128",
            name: "validityEndTimestamp",
            type: "uint128"
          },
          {
            internalType: "bytes32",
            name: "uid",
            type: "bytes32"
          }
        ],
        indexed: false,
        internalType: "struct ISignatureMintERC1155.MintRequest",
        name: "mintRequest",
        type: "tuple"
      }
    ],
    name: "TokensMintedWithSignature",
    type: "event"
  },
  {
    inputs: [
      {
        components: [
          {
            internalType: "address",
            name: "to",
            type: "address"
          },
          {
            internalType: "address",
            name: "royaltyRecipient",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "royaltyBps",
            type: "uint256"
          },
          {
            internalType: "address",
            name: "primarySaleRecipient",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "tokenId",
            type: "uint256"
          },
          {
            internalType: "string",
            name: "uri",
            type: "string"
          },
          {
            internalType: "uint256",
            name: "quantity",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "pricePerToken",
            type: "uint256"
          },
          {
            internalType: "address",
            name: "currency",
            type: "address"
          },
          {
            internalType: "uint128",
            name: "validityStartTimestamp",
            type: "uint128"
          },
          {
            internalType: "uint128",
            name: "validityEndTimestamp",
            type: "uint128"
          },
          {
            internalType: "bytes32",
            name: "uid",
            type: "bytes32"
          }
        ],
        internalType: "struct ISignatureMintERC1155.MintRequest",
        name: "req",
        type: "tuple"
      },
      {
        internalType: "bytes",
        name: "signature",
        type: "bytes"
      }
    ],
    name: "mintWithSignature",
    outputs: [
      {
        internalType: "address",
        name: "signer",
        type: "address"
      }
    ],
    stateMutability: "payable",
    type: "function"
  },
  {
    inputs: [
      {
        components: [
          {
            internalType: "address",
            name: "to",
            type: "address"
          },
          {
            internalType: "address",
            name: "royaltyRecipient",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "royaltyBps",
            type: "uint256"
          },
          {
            internalType: "address",
            name: "primarySaleRecipient",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "tokenId",
            type: "uint256"
          },
          {
            internalType: "string",
            name: "uri",
            type: "string"
          },
          {
            internalType: "uint256",
            name: "quantity",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "pricePerToken",
            type: "uint256"
          },
          {
            internalType: "address",
            name: "currency",
            type: "address"
          },
          {
            internalType: "uint128",
            name: "validityStartTimestamp",
            type: "uint128"
          },
          {
            internalType: "uint128",
            name: "validityEndTimestamp",
            type: "uint128"
          },
          {
            internalType: "bytes32",
            name: "uid",
            type: "bytes32"
          }
        ],
        internalType: "struct ISignatureMintERC1155.MintRequest",
        name: "req",
        type: "tuple"
      },
      {
        internalType: "bytes",
        name: "signature",
        type: "bytes"
      }
    ],
    name: "verify",
    outputs: [
      {
        internalType: "bool",
        name: "success",
        type: "bool"
      },
      {
        internalType: "address",
        name: "signer",
        type: "address"
      }
    ],
    stateMutability: "view",
    type: "function"
  }
];

// node_modules/@thirdweb-dev/contracts-js/dist/abis/IERC20Metadata.json
var IERC20Metadata_default = [
  {
    inputs: [],
    name: "decimals",
    outputs: [
      {
        internalType: "uint8",
        name: "",
        type: "uint8"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "name",
    outputs: [
      {
        internalType: "string",
        name: "",
        type: "string"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "symbol",
    outputs: [
      {
        internalType: "string",
        name: "",
        type: "string"
      }
    ],
    stateMutability: "view",
    type: "function"
  }
];

// node_modules/@thirdweb-dev/sdk/node_modules/uuid/dist/esm-browser/rng.js
var getRandomValues;
var rnds8 = new Uint8Array(16);
function rng() {
  if (!getRandomValues) {
    getRandomValues = typeof crypto !== "undefined" && crypto.getRandomValues && crypto.getRandomValues.bind(crypto);
    if (!getRandomValues) {
      throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");
    }
  }
  return getRandomValues(rnds8);
}

// node_modules/@thirdweb-dev/sdk/node_modules/uuid/dist/esm-browser/regex.js
var regex_default = /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i;

// node_modules/@thirdweb-dev/sdk/node_modules/uuid/dist/esm-browser/validate.js
function validate(uuid) {
  return typeof uuid === "string" && regex_default.test(uuid);
}
var validate_default = validate;

// node_modules/@thirdweb-dev/sdk/node_modules/uuid/dist/esm-browser/stringify.js
var byteToHex = [];
for (let i = 0; i < 256; ++i) {
  byteToHex.push((i + 256).toString(16).slice(1));
}
function unsafeStringify(arr, offset = 0) {
  return (byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + "-" + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + "-" + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + "-" + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + "-" + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]]).toLowerCase();
}

// node_modules/@thirdweb-dev/sdk/node_modules/uuid/dist/esm-browser/parse.js
function parse(uuid) {
  if (!validate_default(uuid)) {
    throw TypeError("Invalid UUID");
  }
  let v;
  const arr = new Uint8Array(16);
  arr[0] = (v = parseInt(uuid.slice(0, 8), 16)) >>> 24;
  arr[1] = v >>> 16 & 255;
  arr[2] = v >>> 8 & 255;
  arr[3] = v & 255;
  arr[4] = (v = parseInt(uuid.slice(9, 13), 16)) >>> 8;
  arr[5] = v & 255;
  arr[6] = (v = parseInt(uuid.slice(14, 18), 16)) >>> 8;
  arr[7] = v & 255;
  arr[8] = (v = parseInt(uuid.slice(19, 23), 16)) >>> 8;
  arr[9] = v & 255;
  arr[10] = (v = parseInt(uuid.slice(24, 36), 16)) / 1099511627776 & 255;
  arr[11] = v / 4294967296 & 255;
  arr[12] = v >>> 24 & 255;
  arr[13] = v >>> 16 & 255;
  arr[14] = v >>> 8 & 255;
  arr[15] = v & 255;
  return arr;
}
var parse_default = parse;

// node_modules/@thirdweb-dev/sdk/node_modules/uuid/dist/esm-browser/v35.js
function stringToBytes(str) {
  str = unescape(encodeURIComponent(str));
  const bytes = [];
  for (let i = 0; i < str.length; ++i) {
    bytes.push(str.charCodeAt(i));
  }
  return bytes;
}
var DNS = "6ba7b810-9dad-11d1-80b4-00c04fd430c8";
var URL2 = "6ba7b811-9dad-11d1-80b4-00c04fd430c8";
function v35(name, version, hashfunc) {
  function generateUUID(value, namespace, buf, offset) {
    var _namespace;
    if (typeof value === "string") {
      value = stringToBytes(value);
    }
    if (typeof namespace === "string") {
      namespace = parse_default(namespace);
    }
    if (((_namespace = namespace) === null || _namespace === void 0 ? void 0 : _namespace.length) !== 16) {
      throw TypeError("Namespace must be array-like (16 iterable integer values, 0-255)");
    }
    let bytes = new Uint8Array(16 + value.length);
    bytes.set(namespace);
    bytes.set(value, namespace.length);
    bytes = hashfunc(bytes);
    bytes[6] = bytes[6] & 15 | version;
    bytes[8] = bytes[8] & 63 | 128;
    if (buf) {
      offset = offset || 0;
      for (let i = 0; i < 16; ++i) {
        buf[offset + i] = bytes[i];
      }
      return buf;
    }
    return unsafeStringify(bytes);
  }
  try {
    generateUUID.name = name;
  } catch (err) {
  }
  generateUUID.DNS = DNS;
  generateUUID.URL = URL2;
  return generateUUID;
}

// node_modules/@thirdweb-dev/sdk/node_modules/uuid/dist/esm-browser/md5.js
function md5(bytes) {
  if (typeof bytes === "string") {
    const msg = unescape(encodeURIComponent(bytes));
    bytes = new Uint8Array(msg.length);
    for (let i = 0; i < msg.length; ++i) {
      bytes[i] = msg.charCodeAt(i);
    }
  }
  return md5ToHexEncodedArray(wordsToMd5(bytesToWords(bytes), bytes.length * 8));
}
function md5ToHexEncodedArray(input) {
  const output = [];
  const length32 = input.length * 32;
  const hexTab = "0123456789abcdef";
  for (let i = 0; i < length32; i += 8) {
    const x = input[i >> 5] >>> i % 32 & 255;
    const hex = parseInt(hexTab.charAt(x >>> 4 & 15) + hexTab.charAt(x & 15), 16);
    output.push(hex);
  }
  return output;
}
function getOutputLength(inputLength8) {
  return (inputLength8 + 64 >>> 9 << 4) + 14 + 1;
}
function wordsToMd5(x, len) {
  x[len >> 5] |= 128 << len % 32;
  x[getOutputLength(len) - 1] = len;
  let a = 1732584193;
  let b = -271733879;
  let c = -1732584194;
  let d = 271733878;
  for (let i = 0; i < x.length; i += 16) {
    const olda = a;
    const oldb = b;
    const oldc = c;
    const oldd = d;
    a = md5ff(a, b, c, d, x[i], 7, -680876936);
    d = md5ff(d, a, b, c, x[i + 1], 12, -389564586);
    c = md5ff(c, d, a, b, x[i + 2], 17, 606105819);
    b = md5ff(b, c, d, a, x[i + 3], 22, -1044525330);
    a = md5ff(a, b, c, d, x[i + 4], 7, -176418897);
    d = md5ff(d, a, b, c, x[i + 5], 12, 1200080426);
    c = md5ff(c, d, a, b, x[i + 6], 17, -1473231341);
    b = md5ff(b, c, d, a, x[i + 7], 22, -45705983);
    a = md5ff(a, b, c, d, x[i + 8], 7, 1770035416);
    d = md5ff(d, a, b, c, x[i + 9], 12, -1958414417);
    c = md5ff(c, d, a, b, x[i + 10], 17, -42063);
    b = md5ff(b, c, d, a, x[i + 11], 22, -1990404162);
    a = md5ff(a, b, c, d, x[i + 12], 7, 1804603682);
    d = md5ff(d, a, b, c, x[i + 13], 12, -40341101);
    c = md5ff(c, d, a, b, x[i + 14], 17, -1502002290);
    b = md5ff(b, c, d, a, x[i + 15], 22, 1236535329);
    a = md5gg(a, b, c, d, x[i + 1], 5, -165796510);
    d = md5gg(d, a, b, c, x[i + 6], 9, -1069501632);
    c = md5gg(c, d, a, b, x[i + 11], 14, 643717713);
    b = md5gg(b, c, d, a, x[i], 20, -373897302);
    a = md5gg(a, b, c, d, x[i + 5], 5, -701558691);
    d = md5gg(d, a, b, c, x[i + 10], 9, 38016083);
    c = md5gg(c, d, a, b, x[i + 15], 14, -660478335);
    b = md5gg(b, c, d, a, x[i + 4], 20, -405537848);
    a = md5gg(a, b, c, d, x[i + 9], 5, 568446438);
    d = md5gg(d, a, b, c, x[i + 14], 9, -1019803690);
    c = md5gg(c, d, a, b, x[i + 3], 14, -187363961);
    b = md5gg(b, c, d, a, x[i + 8], 20, 1163531501);
    a = md5gg(a, b, c, d, x[i + 13], 5, -1444681467);
    d = md5gg(d, a, b, c, x[i + 2], 9, -51403784);
    c = md5gg(c, d, a, b, x[i + 7], 14, 1735328473);
    b = md5gg(b, c, d, a, x[i + 12], 20, -1926607734);
    a = md5hh(a, b, c, d, x[i + 5], 4, -378558);
    d = md5hh(d, a, b, c, x[i + 8], 11, -2022574463);
    c = md5hh(c, d, a, b, x[i + 11], 16, 1839030562);
    b = md5hh(b, c, d, a, x[i + 14], 23, -35309556);
    a = md5hh(a, b, c, d, x[i + 1], 4, -1530992060);
    d = md5hh(d, a, b, c, x[i + 4], 11, 1272893353);
    c = md5hh(c, d, a, b, x[i + 7], 16, -155497632);
    b = md5hh(b, c, d, a, x[i + 10], 23, -1094730640);
    a = md5hh(a, b, c, d, x[i + 13], 4, 681279174);
    d = md5hh(d, a, b, c, x[i], 11, -358537222);
    c = md5hh(c, d, a, b, x[i + 3], 16, -722521979);
    b = md5hh(b, c, d, a, x[i + 6], 23, 76029189);
    a = md5hh(a, b, c, d, x[i + 9], 4, -640364487);
    d = md5hh(d, a, b, c, x[i + 12], 11, -421815835);
    c = md5hh(c, d, a, b, x[i + 15], 16, 530742520);
    b = md5hh(b, c, d, a, x[i + 2], 23, -995338651);
    a = md5ii(a, b, c, d, x[i], 6, -198630844);
    d = md5ii(d, a, b, c, x[i + 7], 10, 1126891415);
    c = md5ii(c, d, a, b, x[i + 14], 15, -1416354905);
    b = md5ii(b, c, d, a, x[i + 5], 21, -57434055);
    a = md5ii(a, b, c, d, x[i + 12], 6, 1700485571);
    d = md5ii(d, a, b, c, x[i + 3], 10, -1894986606);
    c = md5ii(c, d, a, b, x[i + 10], 15, -1051523);
    b = md5ii(b, c, d, a, x[i + 1], 21, -2054922799);
    a = md5ii(a, b, c, d, x[i + 8], 6, 1873313359);
    d = md5ii(d, a, b, c, x[i + 15], 10, -30611744);
    c = md5ii(c, d, a, b, x[i + 6], 15, -1560198380);
    b = md5ii(b, c, d, a, x[i + 13], 21, 1309151649);
    a = md5ii(a, b, c, d, x[i + 4], 6, -145523070);
    d = md5ii(d, a, b, c, x[i + 11], 10, -1120210379);
    c = md5ii(c, d, a, b, x[i + 2], 15, 718787259);
    b = md5ii(b, c, d, a, x[i + 9], 21, -343485551);
    a = safeAdd(a, olda);
    b = safeAdd(b, oldb);
    c = safeAdd(c, oldc);
    d = safeAdd(d, oldd);
  }
  return [a, b, c, d];
}
function bytesToWords(input) {
  if (input.length === 0) {
    return [];
  }
  const length8 = input.length * 8;
  const output = new Uint32Array(getOutputLength(length8));
  for (let i = 0; i < length8; i += 8) {
    output[i >> 5] |= (input[i / 8] & 255) << i % 32;
  }
  return output;
}
function safeAdd(x, y) {
  const lsw = (x & 65535) + (y & 65535);
  const msw = (x >> 16) + (y >> 16) + (lsw >> 16);
  return msw << 16 | lsw & 65535;
}
function bitRotateLeft(num, cnt) {
  return num << cnt | num >>> 32 - cnt;
}
function md5cmn(q, a, b, x, s, t) {
  return safeAdd(bitRotateLeft(safeAdd(safeAdd(a, q), safeAdd(x, t)), s), b);
}
function md5ff(a, b, c, d, x, s, t) {
  return md5cmn(b & c | ~b & d, a, b, x, s, t);
}
function md5gg(a, b, c, d, x, s, t) {
  return md5cmn(b & d | c & ~d, a, b, x, s, t);
}
function md5hh(a, b, c, d, x, s, t) {
  return md5cmn(b ^ c ^ d, a, b, x, s, t);
}
function md5ii(a, b, c, d, x, s, t) {
  return md5cmn(c ^ (b | ~d), a, b, x, s, t);
}
var md5_default = md5;

// node_modules/@thirdweb-dev/sdk/node_modules/uuid/dist/esm-browser/v3.js
var v3 = v35("v3", 48, md5_default);

// node_modules/@thirdweb-dev/sdk/node_modules/uuid/dist/esm-browser/native.js
var randomUUID = typeof crypto !== "undefined" && crypto.randomUUID && crypto.randomUUID.bind(crypto);
var native_default = {
  randomUUID
};

// node_modules/@thirdweb-dev/sdk/node_modules/uuid/dist/esm-browser/v4.js
function v4(options, buf, offset) {
  if (native_default.randomUUID && !buf && !options) {
    return native_default.randomUUID();
  }
  options = options || {};
  const rnds = options.random || (options.rng || rng)();
  rnds[6] = rnds[6] & 15 | 64;
  rnds[8] = rnds[8] & 63 | 128;
  if (buf) {
    offset = offset || 0;
    for (let i = 0; i < 16; ++i) {
      buf[offset + i] = rnds[i];
    }
    return buf;
  }
  return unsafeStringify(rnds);
}
var v4_default = v4;

// node_modules/@thirdweb-dev/sdk/node_modules/uuid/dist/esm-browser/sha1.js
function f(s, x, y, z) {
  switch (s) {
    case 0:
      return x & y ^ ~x & z;
    case 1:
      return x ^ y ^ z;
    case 2:
      return x & y ^ x & z ^ y & z;
    case 3:
      return x ^ y ^ z;
  }
}
function ROTL(x, n) {
  return x << n | x >>> 32 - n;
}
function sha1(bytes) {
  const K = [1518500249, 1859775393, 2400959708, 3395469782];
  const H = [1732584193, 4023233417, 2562383102, 271733878, 3285377520];
  if (typeof bytes === "string") {
    const msg = unescape(encodeURIComponent(bytes));
    bytes = [];
    for (let i = 0; i < msg.length; ++i) {
      bytes.push(msg.charCodeAt(i));
    }
  } else if (!Array.isArray(bytes)) {
    bytes = Array.prototype.slice.call(bytes);
  }
  bytes.push(128);
  const l = bytes.length / 4 + 2;
  const N = Math.ceil(l / 16);
  const M = new Array(N);
  for (let i = 0; i < N; ++i) {
    const arr = new Uint32Array(16);
    for (let j = 0; j < 16; ++j) {
      arr[j] = bytes[i * 64 + j * 4] << 24 | bytes[i * 64 + j * 4 + 1] << 16 | bytes[i * 64 + j * 4 + 2] << 8 | bytes[i * 64 + j * 4 + 3];
    }
    M[i] = arr;
  }
  M[N - 1][14] = (bytes.length - 1) * 8 / Math.pow(2, 32);
  M[N - 1][14] = Math.floor(M[N - 1][14]);
  M[N - 1][15] = (bytes.length - 1) * 8 & 4294967295;
  for (let i = 0; i < N; ++i) {
    const W = new Uint32Array(80);
    for (let t = 0; t < 16; ++t) {
      W[t] = M[i][t];
    }
    for (let t = 16; t < 80; ++t) {
      W[t] = ROTL(W[t - 3] ^ W[t - 8] ^ W[t - 14] ^ W[t - 16], 1);
    }
    let a = H[0];
    let b = H[1];
    let c = H[2];
    let d = H[3];
    let e = H[4];
    for (let t = 0; t < 80; ++t) {
      const s = Math.floor(t / 20);
      const T = ROTL(a, 5) + f(s, b, c, d) + e + K[s] + W[t] >>> 0;
      e = d;
      d = c;
      c = ROTL(b, 30) >>> 0;
      b = a;
      a = T;
    }
    H[0] = H[0] + a >>> 0;
    H[1] = H[1] + b >>> 0;
    H[2] = H[2] + c >>> 0;
    H[3] = H[3] + d >>> 0;
    H[4] = H[4] + e >>> 0;
  }
  return [H[0] >> 24 & 255, H[0] >> 16 & 255, H[0] >> 8 & 255, H[0] & 255, H[1] >> 24 & 255, H[1] >> 16 & 255, H[1] >> 8 & 255, H[1] & 255, H[2] >> 24 & 255, H[2] >> 16 & 255, H[2] >> 8 & 255, H[2] & 255, H[3] >> 24 & 255, H[3] >> 16 & 255, H[3] >> 8 & 255, H[3] & 255, H[4] >> 24 & 255, H[4] >> 16 & 255, H[4] >> 8 & 255, H[4] & 255];
}
var sha1_default = sha1;

// node_modules/@thirdweb-dev/sdk/node_modules/uuid/dist/esm-browser/v5.js
var v5 = v35("v5", 80, sha1_default);

// node_modules/@thirdweb-dev/contracts-js/dist/abis/IERC721Metadata.json
var IERC721Metadata_default = [
  {
    inputs: [],
    name: "name",
    outputs: [
      {
        internalType: "string",
        name: "",
        type: "string"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "symbol",
    outputs: [
      {
        internalType: "string",
        name: "",
        type: "string"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "_tokenId",
        type: "uint256"
      }
    ],
    name: "tokenURI",
    outputs: [
      {
        internalType: "string",
        name: "",
        type: "string"
      }
    ],
    stateMutability: "view",
    type: "function"
  }
];

// node_modules/@thirdweb-dev/contracts-js/dist/abis/IERC1155Metadata.json
var IERC1155Metadata_default = [
  {
    inputs: [
      {
        internalType: "uint256",
        name: "_id",
        type: "uint256"
      }
    ],
    name: "uri",
    outputs: [
      {
        internalType: "string",
        name: "",
        type: "string"
      }
    ],
    stateMutability: "view",
    type: "function"
  }
];

// node_modules/@thirdweb-dev/contracts-js/dist/abis/IDelayedRevealDeprecated.json
var IDelayedRevealDeprecated_default = [
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "uint256",
        name: "index",
        type: "uint256"
      },
      {
        indexed: false,
        internalType: "string",
        name: "revealedURI",
        type: "string"
      }
    ],
    name: "TokenURIRevealed",
    type: "event"
  },
  {
    inputs: [
      {
        internalType: "bytes",
        name: "data",
        type: "bytes"
      },
      {
        internalType: "bytes",
        name: "key",
        type: "bytes"
      }
    ],
    name: "encryptDecrypt",
    outputs: [
      {
        internalType: "bytes",
        name: "result",
        type: "bytes"
      }
    ],
    stateMutability: "pure",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "identifier",
        type: "uint256"
      }
    ],
    name: "encryptedBaseURI",
    outputs: [
      {
        internalType: "bytes",
        name: "",
        type: "bytes"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "identifier",
        type: "uint256"
      },
      {
        internalType: "bytes",
        name: "key",
        type: "bytes"
      }
    ],
    name: "reveal",
    outputs: [
      {
        internalType: "string",
        name: "revealedURI",
        type: "string"
      }
    ],
    stateMutability: "nonpayable",
    type: "function"
  }
];

// node_modules/@thirdweb-dev/contracts-js/dist/abis/TWFactory.json
var TWFactory_default = [
  {
    inputs: [
      {
        internalType: "address",
        name: "_trustedForwarder",
        type: "address"
      },
      {
        internalType: "address",
        name: "_registry",
        type: "address"
      }
    ],
    stateMutability: "nonpayable",
    type: "constructor"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: false,
        internalType: "address",
        name: "implementation",
        type: "address"
      },
      {
        indexed: true,
        internalType: "bytes32",
        name: "contractType",
        type: "bytes32"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "version",
        type: "uint256"
      }
    ],
    name: "ImplementationAdded",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: false,
        internalType: "address",
        name: "implementation",
        type: "address"
      },
      {
        indexed: false,
        internalType: "bool",
        name: "isApproved",
        type: "bool"
      }
    ],
    name: "ImplementationApproved",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "implementation",
        type: "address"
      },
      {
        indexed: false,
        internalType: "address",
        name: "proxy",
        type: "address"
      },
      {
        indexed: true,
        internalType: "address",
        name: "deployer",
        type: "address"
      }
    ],
    name: "ProxyDeployed",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "bytes32",
        name: "role",
        type: "bytes32"
      },
      {
        indexed: true,
        internalType: "bytes32",
        name: "previousAdminRole",
        type: "bytes32"
      },
      {
        indexed: true,
        internalType: "bytes32",
        name: "newAdminRole",
        type: "bytes32"
      }
    ],
    name: "RoleAdminChanged",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "bytes32",
        name: "role",
        type: "bytes32"
      },
      {
        indexed: true,
        internalType: "address",
        name: "account",
        type: "address"
      },
      {
        indexed: true,
        internalType: "address",
        name: "sender",
        type: "address"
      }
    ],
    name: "RoleGranted",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "bytes32",
        name: "role",
        type: "bytes32"
      },
      {
        indexed: true,
        internalType: "address",
        name: "account",
        type: "address"
      },
      {
        indexed: true,
        internalType: "address",
        name: "sender",
        type: "address"
      }
    ],
    name: "RoleRevoked",
    type: "event"
  },
  {
    inputs: [],
    name: "DEFAULT_ADMIN_ROLE",
    outputs: [
      {
        internalType: "bytes32",
        name: "",
        type: "bytes32"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "FACTORY_ROLE",
    outputs: [
      {
        internalType: "bytes32",
        name: "",
        type: "bytes32"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "_implementation",
        type: "address"
      }
    ],
    name: "addImplementation",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "",
        type: "address"
      }
    ],
    name: "approval",
    outputs: [
      {
        internalType: "bool",
        name: "",
        type: "bool"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "_implementation",
        type: "address"
      },
      {
        internalType: "bool",
        name: "_toApprove",
        type: "bool"
      }
    ],
    name: "approveImplementation",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "bytes32",
        name: "",
        type: "bytes32"
      }
    ],
    name: "currentVersion",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "bytes32",
        name: "_type",
        type: "bytes32"
      },
      {
        internalType: "bytes",
        name: "_data",
        type: "bytes"
      }
    ],
    name: "deployProxy",
    outputs: [
      {
        internalType: "address",
        name: "",
        type: "address"
      }
    ],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "_implementation",
        type: "address"
      },
      {
        internalType: "bytes",
        name: "_data",
        type: "bytes"
      },
      {
        internalType: "bytes32",
        name: "_salt",
        type: "bytes32"
      }
    ],
    name: "deployProxyByImplementation",
    outputs: [
      {
        internalType: "address",
        name: "deployedProxy",
        type: "address"
      }
    ],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "bytes32",
        name: "_type",
        type: "bytes32"
      },
      {
        internalType: "bytes",
        name: "_data",
        type: "bytes"
      },
      {
        internalType: "bytes32",
        name: "_salt",
        type: "bytes32"
      }
    ],
    name: "deployProxyDeterministic",
    outputs: [
      {
        internalType: "address",
        name: "",
        type: "address"
      }
    ],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "",
        type: "address"
      }
    ],
    name: "deployer",
    outputs: [
      {
        internalType: "address",
        name: "",
        type: "address"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "bytes32",
        name: "_type",
        type: "bytes32"
      },
      {
        internalType: "uint256",
        name: "_version",
        type: "uint256"
      }
    ],
    name: "getImplementation",
    outputs: [
      {
        internalType: "address",
        name: "",
        type: "address"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "bytes32",
        name: "_type",
        type: "bytes32"
      }
    ],
    name: "getLatestImplementation",
    outputs: [
      {
        internalType: "address",
        name: "",
        type: "address"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "bytes32",
        name: "role",
        type: "bytes32"
      }
    ],
    name: "getRoleAdmin",
    outputs: [
      {
        internalType: "bytes32",
        name: "",
        type: "bytes32"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "bytes32",
        name: "role",
        type: "bytes32"
      },
      {
        internalType: "uint256",
        name: "index",
        type: "uint256"
      }
    ],
    name: "getRoleMember",
    outputs: [
      {
        internalType: "address",
        name: "",
        type: "address"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "bytes32",
        name: "role",
        type: "bytes32"
      }
    ],
    name: "getRoleMemberCount",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "bytes32",
        name: "role",
        type: "bytes32"
      },
      {
        internalType: "address",
        name: "account",
        type: "address"
      }
    ],
    name: "grantRole",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "bytes32",
        name: "role",
        type: "bytes32"
      },
      {
        internalType: "address",
        name: "account",
        type: "address"
      }
    ],
    name: "hasRole",
    outputs: [
      {
        internalType: "bool",
        name: "",
        type: "bool"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "bytes32",
        name: "",
        type: "bytes32"
      },
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    name: "implementation",
    outputs: [
      {
        internalType: "address",
        name: "",
        type: "address"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "forwarder",
        type: "address"
      }
    ],
    name: "isTrustedForwarder",
    outputs: [
      {
        internalType: "bool",
        name: "",
        type: "bool"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "bytes[]",
        name: "data",
        type: "bytes[]"
      }
    ],
    name: "multicall",
    outputs: [
      {
        internalType: "bytes[]",
        name: "results",
        type: "bytes[]"
      }
    ],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [],
    name: "registry",
    outputs: [
      {
        internalType: "contract TWRegistry",
        name: "",
        type: "address"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "bytes32",
        name: "role",
        type: "bytes32"
      },
      {
        internalType: "address",
        name: "account",
        type: "address"
      }
    ],
    name: "renounceRole",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "bytes32",
        name: "role",
        type: "bytes32"
      },
      {
        internalType: "address",
        name: "account",
        type: "address"
      }
    ],
    name: "revokeRole",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "bytes4",
        name: "interfaceId",
        type: "bytes4"
      }
    ],
    name: "supportsInterface",
    outputs: [
      {
        internalType: "bool",
        name: "",
        type: "bool"
      }
    ],
    stateMutability: "view",
    type: "function"
  }
];

// node_modules/@thirdweb-dev/contracts-js/dist/abis/TWRegistry.json
var TWRegistry_default = [
  {
    inputs: [
      {
        internalType: "address",
        name: "_trustedForwarder",
        type: "address"
      }
    ],
    stateMutability: "nonpayable",
    type: "constructor"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "deployer",
        type: "address"
      },
      {
        indexed: true,
        internalType: "address",
        name: "deployment",
        type: "address"
      }
    ],
    name: "Added",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "deployer",
        type: "address"
      },
      {
        indexed: true,
        internalType: "address",
        name: "deployment",
        type: "address"
      }
    ],
    name: "Deleted",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "bytes32",
        name: "role",
        type: "bytes32"
      },
      {
        indexed: true,
        internalType: "bytes32",
        name: "previousAdminRole",
        type: "bytes32"
      },
      {
        indexed: true,
        internalType: "bytes32",
        name: "newAdminRole",
        type: "bytes32"
      }
    ],
    name: "RoleAdminChanged",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "bytes32",
        name: "role",
        type: "bytes32"
      },
      {
        indexed: true,
        internalType: "address",
        name: "account",
        type: "address"
      },
      {
        indexed: true,
        internalType: "address",
        name: "sender",
        type: "address"
      }
    ],
    name: "RoleGranted",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "bytes32",
        name: "role",
        type: "bytes32"
      },
      {
        indexed: true,
        internalType: "address",
        name: "account",
        type: "address"
      },
      {
        indexed: true,
        internalType: "address",
        name: "sender",
        type: "address"
      }
    ],
    name: "RoleRevoked",
    type: "event"
  },
  {
    inputs: [],
    name: "DEFAULT_ADMIN_ROLE",
    outputs: [
      {
        internalType: "bytes32",
        name: "",
        type: "bytes32"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "OPERATOR_ROLE",
    outputs: [
      {
        internalType: "bytes32",
        name: "",
        type: "bytes32"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "_deployer",
        type: "address"
      },
      {
        internalType: "address",
        name: "_deployment",
        type: "address"
      }
    ],
    name: "add",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "_deployer",
        type: "address"
      }
    ],
    name: "count",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "_deployer",
        type: "address"
      }
    ],
    name: "getAll",
    outputs: [
      {
        internalType: "address[]",
        name: "",
        type: "address[]"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "bytes32",
        name: "role",
        type: "bytes32"
      }
    ],
    name: "getRoleAdmin",
    outputs: [
      {
        internalType: "bytes32",
        name: "",
        type: "bytes32"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "bytes32",
        name: "role",
        type: "bytes32"
      },
      {
        internalType: "uint256",
        name: "index",
        type: "uint256"
      }
    ],
    name: "getRoleMember",
    outputs: [
      {
        internalType: "address",
        name: "",
        type: "address"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "bytes32",
        name: "role",
        type: "bytes32"
      }
    ],
    name: "getRoleMemberCount",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "bytes32",
        name: "role",
        type: "bytes32"
      },
      {
        internalType: "address",
        name: "account",
        type: "address"
      }
    ],
    name: "grantRole",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "bytes32",
        name: "role",
        type: "bytes32"
      },
      {
        internalType: "address",
        name: "account",
        type: "address"
      }
    ],
    name: "hasRole",
    outputs: [
      {
        internalType: "bool",
        name: "",
        type: "bool"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "forwarder",
        type: "address"
      }
    ],
    name: "isTrustedForwarder",
    outputs: [
      {
        internalType: "bool",
        name: "",
        type: "bool"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "bytes[]",
        name: "data",
        type: "bytes[]"
      }
    ],
    name: "multicall",
    outputs: [
      {
        internalType: "bytes[]",
        name: "results",
        type: "bytes[]"
      }
    ],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "_deployer",
        type: "address"
      },
      {
        internalType: "address",
        name: "_deployment",
        type: "address"
      }
    ],
    name: "remove",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "bytes32",
        name: "role",
        type: "bytes32"
      },
      {
        internalType: "address",
        name: "account",
        type: "address"
      }
    ],
    name: "renounceRole",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "bytes32",
        name: "role",
        type: "bytes32"
      },
      {
        internalType: "address",
        name: "account",
        type: "address"
      }
    ],
    name: "revokeRole",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "bytes4",
        name: "interfaceId",
        type: "bytes4"
      }
    ],
    name: "supportsInterface",
    outputs: [
      {
        internalType: "bool",
        name: "",
        type: "bool"
      }
    ],
    stateMutability: "view",
    type: "function"
  }
];

// node_modules/@thirdweb-dev/contracts-js/dist/abis/ContractPublisher.json
var ContractPublisher_default = [
  {
    inputs: [
      {
        internalType: "address",
        name: "_trustedForwarder",
        type: "address"
      },
      {
        internalType: "contract IContractPublisher",
        name: "_prevPublisher",
        type: "address"
      }
    ],
    stateMutability: "nonpayable",
    type: "constructor"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "operator",
        type: "address"
      },
      {
        indexed: true,
        internalType: "address",
        name: "publisher",
        type: "address"
      },
      {
        components: [
          {
            internalType: "string",
            name: "contractId",
            type: "string"
          },
          {
            internalType: "uint256",
            name: "publishTimestamp",
            type: "uint256"
          },
          {
            internalType: "string",
            name: "publishMetadataUri",
            type: "string"
          },
          {
            internalType: "bytes32",
            name: "bytecodeHash",
            type: "bytes32"
          },
          {
            internalType: "address",
            name: "implementation",
            type: "address"
          }
        ],
        indexed: false,
        internalType: "struct IContractPublisher.CustomContractInstance",
        name: "publishedContract",
        type: "tuple"
      }
    ],
    name: "ContractPublished",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "operator",
        type: "address"
      },
      {
        indexed: true,
        internalType: "address",
        name: "publisher",
        type: "address"
      },
      {
        indexed: true,
        internalType: "string",
        name: "contractId",
        type: "string"
      }
    ],
    name: "ContractUnpublished",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: false,
        internalType: "bool",
        name: "isPaused",
        type: "bool"
      }
    ],
    name: "Paused",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "publisher",
        type: "address"
      },
      {
        indexed: false,
        internalType: "string",
        name: "prevURI",
        type: "string"
      },
      {
        indexed: false,
        internalType: "string",
        name: "newURI",
        type: "string"
      }
    ],
    name: "PublisherProfileUpdated",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "bytes32",
        name: "role",
        type: "bytes32"
      },
      {
        indexed: true,
        internalType: "bytes32",
        name: "previousAdminRole",
        type: "bytes32"
      },
      {
        indexed: true,
        internalType: "bytes32",
        name: "newAdminRole",
        type: "bytes32"
      }
    ],
    name: "RoleAdminChanged",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "bytes32",
        name: "role",
        type: "bytes32"
      },
      {
        indexed: true,
        internalType: "address",
        name: "account",
        type: "address"
      },
      {
        indexed: true,
        internalType: "address",
        name: "sender",
        type: "address"
      }
    ],
    name: "RoleGranted",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "bytes32",
        name: "role",
        type: "bytes32"
      },
      {
        indexed: true,
        internalType: "address",
        name: "account",
        type: "address"
      },
      {
        indexed: true,
        internalType: "address",
        name: "sender",
        type: "address"
      }
    ],
    name: "RoleRevoked",
    type: "event"
  },
  {
    inputs: [],
    name: "DEFAULT_ADMIN_ROLE",
    outputs: [
      {
        internalType: "bytes32",
        name: "",
        type: "bytes32"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "_publisher",
        type: "address"
      }
    ],
    name: "getAllPublishedContracts",
    outputs: [
      {
        components: [
          {
            internalType: "string",
            name: "contractId",
            type: "string"
          },
          {
            internalType: "uint256",
            name: "publishTimestamp",
            type: "uint256"
          },
          {
            internalType: "string",
            name: "publishMetadataUri",
            type: "string"
          },
          {
            internalType: "bytes32",
            name: "bytecodeHash",
            type: "bytes32"
          },
          {
            internalType: "address",
            name: "implementation",
            type: "address"
          }
        ],
        internalType: "struct IContractPublisher.CustomContractInstance[]",
        name: "published",
        type: "tuple[]"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "_publisher",
        type: "address"
      },
      {
        internalType: "string",
        name: "_contractId",
        type: "string"
      }
    ],
    name: "getPublishedContract",
    outputs: [
      {
        components: [
          {
            internalType: "string",
            name: "contractId",
            type: "string"
          },
          {
            internalType: "uint256",
            name: "publishTimestamp",
            type: "uint256"
          },
          {
            internalType: "string",
            name: "publishMetadataUri",
            type: "string"
          },
          {
            internalType: "bytes32",
            name: "bytecodeHash",
            type: "bytes32"
          },
          {
            internalType: "address",
            name: "implementation",
            type: "address"
          }
        ],
        internalType: "struct IContractPublisher.CustomContractInstance",
        name: "published",
        type: "tuple"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "_publisher",
        type: "address"
      },
      {
        internalType: "string",
        name: "_contractId",
        type: "string"
      }
    ],
    name: "getPublishedContractVersions",
    outputs: [
      {
        components: [
          {
            internalType: "string",
            name: "contractId",
            type: "string"
          },
          {
            internalType: "uint256",
            name: "publishTimestamp",
            type: "uint256"
          },
          {
            internalType: "string",
            name: "publishMetadataUri",
            type: "string"
          },
          {
            internalType: "bytes32",
            name: "bytecodeHash",
            type: "bytes32"
          },
          {
            internalType: "address",
            name: "implementation",
            type: "address"
          }
        ],
        internalType: "struct IContractPublisher.CustomContractInstance[]",
        name: "published",
        type: "tuple[]"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "string",
        name: "compilerMetadataUri",
        type: "string"
      }
    ],
    name: "getPublishedUriFromCompilerUri",
    outputs: [
      {
        internalType: "string[]",
        name: "publishedMetadataUris",
        type: "string[]"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "publisher",
        type: "address"
      }
    ],
    name: "getPublisherProfileUri",
    outputs: [
      {
        internalType: "string",
        name: "uri",
        type: "string"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "bytes32",
        name: "role",
        type: "bytes32"
      }
    ],
    name: "getRoleAdmin",
    outputs: [
      {
        internalType: "bytes32",
        name: "",
        type: "bytes32"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "bytes32",
        name: "role",
        type: "bytes32"
      },
      {
        internalType: "uint256",
        name: "index",
        type: "uint256"
      }
    ],
    name: "getRoleMember",
    outputs: [
      {
        internalType: "address",
        name: "",
        type: "address"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "bytes32",
        name: "role",
        type: "bytes32"
      }
    ],
    name: "getRoleMemberCount",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "bytes32",
        name: "role",
        type: "bytes32"
      },
      {
        internalType: "address",
        name: "account",
        type: "address"
      }
    ],
    name: "grantRole",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "bytes32",
        name: "role",
        type: "bytes32"
      },
      {
        internalType: "address",
        name: "account",
        type: "address"
      }
    ],
    name: "hasRole",
    outputs: [
      {
        internalType: "bool",
        name: "",
        type: "bool"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "isPaused",
    outputs: [
      {
        internalType: "bool",
        name: "",
        type: "bool"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "forwarder",
        type: "address"
      }
    ],
    name: "isTrustedForwarder",
    outputs: [
      {
        internalType: "bool",
        name: "",
        type: "bool"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "bytes[]",
        name: "data",
        type: "bytes[]"
      }
    ],
    name: "multicall",
    outputs: [
      {
        internalType: "bytes[]",
        name: "results",
        type: "bytes[]"
      }
    ],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [],
    name: "prevPublisher",
    outputs: [
      {
        internalType: "contract IContractPublisher",
        name: "",
        type: "address"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "_publisher",
        type: "address"
      },
      {
        internalType: "string",
        name: "_contractId",
        type: "string"
      },
      {
        internalType: "string",
        name: "_publishMetadataUri",
        type: "string"
      },
      {
        internalType: "string",
        name: "_compilerMetadataUri",
        type: "string"
      },
      {
        internalType: "bytes32",
        name: "_bytecodeHash",
        type: "bytes32"
      },
      {
        internalType: "address",
        name: "_implementation",
        type: "address"
      }
    ],
    name: "publishContract",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "bytes32",
        name: "role",
        type: "bytes32"
      },
      {
        internalType: "address",
        name: "account",
        type: "address"
      }
    ],
    name: "renounceRole",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "bytes32",
        name: "role",
        type: "bytes32"
      },
      {
        internalType: "address",
        name: "account",
        type: "address"
      }
    ],
    name: "revokeRole",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "bool",
        name: "_pause",
        type: "bool"
      }
    ],
    name: "setPause",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "publisher",
        type: "address"
      },
      {
        internalType: "string",
        name: "uri",
        type: "string"
      }
    ],
    name: "setPublisherProfileUri",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "bytes4",
        name: "interfaceId",
        type: "bytes4"
      }
    ],
    name: "supportsInterface",
    outputs: [
      {
        internalType: "bool",
        name: "",
        type: "bool"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "_publisher",
        type: "address"
      },
      {
        internalType: "string",
        name: "_contractId",
        type: "string"
      }
    ],
    name: "unpublishContract",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  }
];

// node_modules/@thirdweb-dev/storage/dist/thirdweb-dev-storage.esm.js
var import_cross_fetch = __toESM(require_browser_ponyfill());
var import_form_data = __toESM(require_browser());

// node_modules/@thirdweb-dev/storage/node_modules/uuid/dist/esm-browser/rng.js
var rnds82 = new Uint8Array(16);

// node_modules/@thirdweb-dev/storage/node_modules/uuid/dist/esm-browser/regex.js
var regex_default2 = /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i;

// node_modules/@thirdweb-dev/storage/node_modules/uuid/dist/esm-browser/validate.js
function validate2(uuid) {
  return typeof uuid === "string" && regex_default2.test(uuid);
}
var validate_default2 = validate2;

// node_modules/@thirdweb-dev/storage/node_modules/uuid/dist/esm-browser/stringify.js
var byteToHex2 = [];
for (let i = 0; i < 256; ++i) {
  byteToHex2.push((i + 256).toString(16).slice(1));
}
function unsafeStringify2(arr, offset = 0) {
  return (byteToHex2[arr[offset + 0]] + byteToHex2[arr[offset + 1]] + byteToHex2[arr[offset + 2]] + byteToHex2[arr[offset + 3]] + "-" + byteToHex2[arr[offset + 4]] + byteToHex2[arr[offset + 5]] + "-" + byteToHex2[arr[offset + 6]] + byteToHex2[arr[offset + 7]] + "-" + byteToHex2[arr[offset + 8]] + byteToHex2[arr[offset + 9]] + "-" + byteToHex2[arr[offset + 10]] + byteToHex2[arr[offset + 11]] + byteToHex2[arr[offset + 12]] + byteToHex2[arr[offset + 13]] + byteToHex2[arr[offset + 14]] + byteToHex2[arr[offset + 15]]).toLowerCase();
}

// node_modules/@thirdweb-dev/storage/node_modules/uuid/dist/esm-browser/parse.js
function parse2(uuid) {
  if (!validate_default2(uuid)) {
    throw TypeError("Invalid UUID");
  }
  let v;
  const arr = new Uint8Array(16);
  arr[0] = (v = parseInt(uuid.slice(0, 8), 16)) >>> 24;
  arr[1] = v >>> 16 & 255;
  arr[2] = v >>> 8 & 255;
  arr[3] = v & 255;
  arr[4] = (v = parseInt(uuid.slice(9, 13), 16)) >>> 8;
  arr[5] = v & 255;
  arr[6] = (v = parseInt(uuid.slice(14, 18), 16)) >>> 8;
  arr[7] = v & 255;
  arr[8] = (v = parseInt(uuid.slice(19, 23), 16)) >>> 8;
  arr[9] = v & 255;
  arr[10] = (v = parseInt(uuid.slice(24, 36), 16)) / 1099511627776 & 255;
  arr[11] = v / 4294967296 & 255;
  arr[12] = v >>> 24 & 255;
  arr[13] = v >>> 16 & 255;
  arr[14] = v >>> 8 & 255;
  arr[15] = v & 255;
  return arr;
}
var parse_default2 = parse2;

// node_modules/@thirdweb-dev/storage/node_modules/uuid/dist/esm-browser/v35.js
function stringToBytes2(str) {
  str = unescape(encodeURIComponent(str));
  const bytes = [];
  for (let i = 0; i < str.length; ++i) {
    bytes.push(str.charCodeAt(i));
  }
  return bytes;
}
var DNS2 = "6ba7b810-9dad-11d1-80b4-00c04fd430c8";
var URL3 = "6ba7b811-9dad-11d1-80b4-00c04fd430c8";
function v352(name, version, hashfunc) {
  function generateUUID(value, namespace, buf, offset) {
    var _namespace;
    if (typeof value === "string") {
      value = stringToBytes2(value);
    }
    if (typeof namespace === "string") {
      namespace = parse_default2(namespace);
    }
    if (((_namespace = namespace) === null || _namespace === void 0 ? void 0 : _namespace.length) !== 16) {
      throw TypeError("Namespace must be array-like (16 iterable integer values, 0-255)");
    }
    let bytes = new Uint8Array(16 + value.length);
    bytes.set(namespace);
    bytes.set(value, namespace.length);
    bytes = hashfunc(bytes);
    bytes[6] = bytes[6] & 15 | version;
    bytes[8] = bytes[8] & 63 | 128;
    if (buf) {
      offset = offset || 0;
      for (let i = 0; i < 16; ++i) {
        buf[offset + i] = bytes[i];
      }
      return buf;
    }
    return unsafeStringify2(bytes);
  }
  try {
    generateUUID.name = name;
  } catch (err) {
  }
  generateUUID.DNS = DNS2;
  generateUUID.URL = URL3;
  return generateUUID;
}

// node_modules/@thirdweb-dev/storage/node_modules/uuid/dist/esm-browser/md5.js
function md52(bytes) {
  if (typeof bytes === "string") {
    const msg = unescape(encodeURIComponent(bytes));
    bytes = new Uint8Array(msg.length);
    for (let i = 0; i < msg.length; ++i) {
      bytes[i] = msg.charCodeAt(i);
    }
  }
  return md5ToHexEncodedArray2(wordsToMd52(bytesToWords2(bytes), bytes.length * 8));
}
function md5ToHexEncodedArray2(input) {
  const output = [];
  const length32 = input.length * 32;
  const hexTab = "0123456789abcdef";
  for (let i = 0; i < length32; i += 8) {
    const x = input[i >> 5] >>> i % 32 & 255;
    const hex = parseInt(hexTab.charAt(x >>> 4 & 15) + hexTab.charAt(x & 15), 16);
    output.push(hex);
  }
  return output;
}
function getOutputLength2(inputLength8) {
  return (inputLength8 + 64 >>> 9 << 4) + 14 + 1;
}
function wordsToMd52(x, len) {
  x[len >> 5] |= 128 << len % 32;
  x[getOutputLength2(len) - 1] = len;
  let a = 1732584193;
  let b = -271733879;
  let c = -1732584194;
  let d = 271733878;
  for (let i = 0; i < x.length; i += 16) {
    const olda = a;
    const oldb = b;
    const oldc = c;
    const oldd = d;
    a = md5ff2(a, b, c, d, x[i], 7, -680876936);
    d = md5ff2(d, a, b, c, x[i + 1], 12, -389564586);
    c = md5ff2(c, d, a, b, x[i + 2], 17, 606105819);
    b = md5ff2(b, c, d, a, x[i + 3], 22, -1044525330);
    a = md5ff2(a, b, c, d, x[i + 4], 7, -176418897);
    d = md5ff2(d, a, b, c, x[i + 5], 12, 1200080426);
    c = md5ff2(c, d, a, b, x[i + 6], 17, -1473231341);
    b = md5ff2(b, c, d, a, x[i + 7], 22, -45705983);
    a = md5ff2(a, b, c, d, x[i + 8], 7, 1770035416);
    d = md5ff2(d, a, b, c, x[i + 9], 12, -1958414417);
    c = md5ff2(c, d, a, b, x[i + 10], 17, -42063);
    b = md5ff2(b, c, d, a, x[i + 11], 22, -1990404162);
    a = md5ff2(a, b, c, d, x[i + 12], 7, 1804603682);
    d = md5ff2(d, a, b, c, x[i + 13], 12, -40341101);
    c = md5ff2(c, d, a, b, x[i + 14], 17, -1502002290);
    b = md5ff2(b, c, d, a, x[i + 15], 22, 1236535329);
    a = md5gg2(a, b, c, d, x[i + 1], 5, -165796510);
    d = md5gg2(d, a, b, c, x[i + 6], 9, -1069501632);
    c = md5gg2(c, d, a, b, x[i + 11], 14, 643717713);
    b = md5gg2(b, c, d, a, x[i], 20, -373897302);
    a = md5gg2(a, b, c, d, x[i + 5], 5, -701558691);
    d = md5gg2(d, a, b, c, x[i + 10], 9, 38016083);
    c = md5gg2(c, d, a, b, x[i + 15], 14, -660478335);
    b = md5gg2(b, c, d, a, x[i + 4], 20, -405537848);
    a = md5gg2(a, b, c, d, x[i + 9], 5, 568446438);
    d = md5gg2(d, a, b, c, x[i + 14], 9, -1019803690);
    c = md5gg2(c, d, a, b, x[i + 3], 14, -187363961);
    b = md5gg2(b, c, d, a, x[i + 8], 20, 1163531501);
    a = md5gg2(a, b, c, d, x[i + 13], 5, -1444681467);
    d = md5gg2(d, a, b, c, x[i + 2], 9, -51403784);
    c = md5gg2(c, d, a, b, x[i + 7], 14, 1735328473);
    b = md5gg2(b, c, d, a, x[i + 12], 20, -1926607734);
    a = md5hh2(a, b, c, d, x[i + 5], 4, -378558);
    d = md5hh2(d, a, b, c, x[i + 8], 11, -2022574463);
    c = md5hh2(c, d, a, b, x[i + 11], 16, 1839030562);
    b = md5hh2(b, c, d, a, x[i + 14], 23, -35309556);
    a = md5hh2(a, b, c, d, x[i + 1], 4, -1530992060);
    d = md5hh2(d, a, b, c, x[i + 4], 11, 1272893353);
    c = md5hh2(c, d, a, b, x[i + 7], 16, -155497632);
    b = md5hh2(b, c, d, a, x[i + 10], 23, -1094730640);
    a = md5hh2(a, b, c, d, x[i + 13], 4, 681279174);
    d = md5hh2(d, a, b, c, x[i], 11, -358537222);
    c = md5hh2(c, d, a, b, x[i + 3], 16, -722521979);
    b = md5hh2(b, c, d, a, x[i + 6], 23, 76029189);
    a = md5hh2(a, b, c, d, x[i + 9], 4, -640364487);
    d = md5hh2(d, a, b, c, x[i + 12], 11, -421815835);
    c = md5hh2(c, d, a, b, x[i + 15], 16, 530742520);
    b = md5hh2(b, c, d, a, x[i + 2], 23, -995338651);
    a = md5ii2(a, b, c, d, x[i], 6, -198630844);
    d = md5ii2(d, a, b, c, x[i + 7], 10, 1126891415);
    c = md5ii2(c, d, a, b, x[i + 14], 15, -1416354905);
    b = md5ii2(b, c, d, a, x[i + 5], 21, -57434055);
    a = md5ii2(a, b, c, d, x[i + 12], 6, 1700485571);
    d = md5ii2(d, a, b, c, x[i + 3], 10, -1894986606);
    c = md5ii2(c, d, a, b, x[i + 10], 15, -1051523);
    b = md5ii2(b, c, d, a, x[i + 1], 21, -2054922799);
    a = md5ii2(a, b, c, d, x[i + 8], 6, 1873313359);
    d = md5ii2(d, a, b, c, x[i + 15], 10, -30611744);
    c = md5ii2(c, d, a, b, x[i + 6], 15, -1560198380);
    b = md5ii2(b, c, d, a, x[i + 13], 21, 1309151649);
    a = md5ii2(a, b, c, d, x[i + 4], 6, -145523070);
    d = md5ii2(d, a, b, c, x[i + 11], 10, -1120210379);
    c = md5ii2(c, d, a, b, x[i + 2], 15, 718787259);
    b = md5ii2(b, c, d, a, x[i + 9], 21, -343485551);
    a = safeAdd2(a, olda);
    b = safeAdd2(b, oldb);
    c = safeAdd2(c, oldc);
    d = safeAdd2(d, oldd);
  }
  return [a, b, c, d];
}
function bytesToWords2(input) {
  if (input.length === 0) {
    return [];
  }
  const length8 = input.length * 8;
  const output = new Uint32Array(getOutputLength2(length8));
  for (let i = 0; i < length8; i += 8) {
    output[i >> 5] |= (input[i / 8] & 255) << i % 32;
  }
  return output;
}
function safeAdd2(x, y) {
  const lsw = (x & 65535) + (y & 65535);
  const msw = (x >> 16) + (y >> 16) + (lsw >> 16);
  return msw << 16 | lsw & 65535;
}
function bitRotateLeft2(num, cnt) {
  return num << cnt | num >>> 32 - cnt;
}
function md5cmn2(q, a, b, x, s, t) {
  return safeAdd2(bitRotateLeft2(safeAdd2(safeAdd2(a, q), safeAdd2(x, t)), s), b);
}
function md5ff2(a, b, c, d, x, s, t) {
  return md5cmn2(b & c | ~b & d, a, b, x, s, t);
}
function md5gg2(a, b, c, d, x, s, t) {
  return md5cmn2(b & d | c & ~d, a, b, x, s, t);
}
function md5hh2(a, b, c, d, x, s, t) {
  return md5cmn2(b ^ c ^ d, a, b, x, s, t);
}
function md5ii2(a, b, c, d, x, s, t) {
  return md5cmn2(c ^ (b | ~d), a, b, x, s, t);
}
var md5_default2 = md52;

// node_modules/@thirdweb-dev/storage/node_modules/uuid/dist/esm-browser/v3.js
var v32 = v352("v3", 48, md5_default2);

// node_modules/@thirdweb-dev/storage/node_modules/uuid/dist/esm-browser/native.js
var randomUUID2 = typeof crypto !== "undefined" && crypto.randomUUID && crypto.randomUUID.bind(crypto);

// node_modules/@thirdweb-dev/storage/node_modules/uuid/dist/esm-browser/sha1.js
function f2(s, x, y, z) {
  switch (s) {
    case 0:
      return x & y ^ ~x & z;
    case 1:
      return x ^ y ^ z;
    case 2:
      return x & y ^ x & z ^ y & z;
    case 3:
      return x ^ y ^ z;
  }
}
function ROTL2(x, n) {
  return x << n | x >>> 32 - n;
}
function sha12(bytes) {
  const K = [1518500249, 1859775393, 2400959708, 3395469782];
  const H = [1732584193, 4023233417, 2562383102, 271733878, 3285377520];
  if (typeof bytes === "string") {
    const msg = unescape(encodeURIComponent(bytes));
    bytes = [];
    for (let i = 0; i < msg.length; ++i) {
      bytes.push(msg.charCodeAt(i));
    }
  } else if (!Array.isArray(bytes)) {
    bytes = Array.prototype.slice.call(bytes);
  }
  bytes.push(128);
  const l = bytes.length / 4 + 2;
  const N = Math.ceil(l / 16);
  const M = new Array(N);
  for (let i = 0; i < N; ++i) {
    const arr = new Uint32Array(16);
    for (let j = 0; j < 16; ++j) {
      arr[j] = bytes[i * 64 + j * 4] << 24 | bytes[i * 64 + j * 4 + 1] << 16 | bytes[i * 64 + j * 4 + 2] << 8 | bytes[i * 64 + j * 4 + 3];
    }
    M[i] = arr;
  }
  M[N - 1][14] = (bytes.length - 1) * 8 / Math.pow(2, 32);
  M[N - 1][14] = Math.floor(M[N - 1][14]);
  M[N - 1][15] = (bytes.length - 1) * 8 & 4294967295;
  for (let i = 0; i < N; ++i) {
    const W = new Uint32Array(80);
    for (let t = 0; t < 16; ++t) {
      W[t] = M[i][t];
    }
    for (let t = 16; t < 80; ++t) {
      W[t] = ROTL2(W[t - 3] ^ W[t - 8] ^ W[t - 14] ^ W[t - 16], 1);
    }
    let a = H[0];
    let b = H[1];
    let c = H[2];
    let d = H[3];
    let e = H[4];
    for (let t = 0; t < 80; ++t) {
      const s = Math.floor(t / 20);
      const T = ROTL2(a, 5) + f2(s, b, c, d) + e + K[s] + W[t] >>> 0;
      e = d;
      d = c;
      c = ROTL2(b, 30) >>> 0;
      b = a;
      a = T;
    }
    H[0] = H[0] + a >>> 0;
    H[1] = H[1] + b >>> 0;
    H[2] = H[2] + c >>> 0;
    H[3] = H[3] + d >>> 0;
    H[4] = H[4] + e >>> 0;
  }
  return [H[0] >> 24 & 255, H[0] >> 16 & 255, H[0] >> 8 & 255, H[0] & 255, H[1] >> 24 & 255, H[1] >> 16 & 255, H[1] >> 8 & 255, H[1] & 255, H[2] >> 24 & 255, H[2] >> 16 & 255, H[2] >> 8 & 255, H[2] & 255, H[3] >> 24 & 255, H[3] >> 16 & 255, H[3] >> 8 & 255, H[3] & 255, H[4] >> 24 & 255, H[4] >> 16 & 255, H[4] >> 8 & 255, H[4] & 255];
}
var sha1_default2 = sha12;

// node_modules/@thirdweb-dev/storage/node_modules/uuid/dist/esm-browser/v5.js
var v52 = v352("v5", 80, sha1_default2);

// node_modules/@thirdweb-dev/storage/dist/thirdweb-dev-storage.esm.js
function _defineProperty2(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
}
var DEFAULT_GATEWAY_URLS = {
  "ipfs://": ["https://gateway.ipfscdn.io/ipfs/", "https://cloudflare-ipfs.com/ipfs/", "https://ipfs.io/ipfs/"]
};
var TW_IPFS_SERVER_URL = "https://upload.nftlabs.co";
var PINATA_IPFS_URL = `https://api.pinata.cloud/pinning/pinFileToIPFS`;
function prepareGatewayUrls(gatewayUrls) {
  const allGatewayUrls = {
    ...gatewayUrls,
    ...DEFAULT_GATEWAY_URLS
  };
  for (const key of Object.keys(DEFAULT_GATEWAY_URLS)) {
    if (gatewayUrls && gatewayUrls[key]) {
      const cleanedGatewayUrls = gatewayUrls[key].map((url) => url.replace(/\/$/, "") + "/");
      allGatewayUrls[key] = [...cleanedGatewayUrls, ...DEFAULT_GATEWAY_URLS[key]];
    }
  }
  return allGatewayUrls;
}
function isBrowser2() {
  return typeof window !== "undefined";
}
function isFileInstance(data) {
  return global.File && data instanceof File;
}
function isBufferInstance(data) {
  return global.Buffer && data instanceof Buffer;
}
function isBufferOrStringWithName(data) {
  return !!(data && data.name && data.data && typeof data.name === "string" && (typeof data.data === "string" || isBufferInstance(data.data)));
}
function isFileOrBuffer(data) {
  return isFileInstance(data) || isBufferInstance(data) || isBufferOrStringWithName(data);
}
function isFileBufferOrStringEqual(input1, input2) {
  if (isFileInstance(input1) && isFileInstance(input2)) {
    if (input1.name === input2.name && input1.lastModified === input2.lastModified && input1.size === input2.size) {
      return true;
    }
  } else if (isBufferInstance(input1) && isBufferInstance(input2)) {
    return input1.equals(input2);
  } else if (isBufferOrStringWithName(input1) && isBufferOrStringWithName(input2)) {
    if (input1.name === input2.name) {
      if (typeof input1.data === "string" && typeof input2.data === "string") {
        return input1.data === input2.data;
      } else if (isBufferInstance(input1.data) && isBufferInstance(input2.data)) {
        return input1.data.equals(input2.data);
      }
    }
  }
  return false;
}
function replaceGatewayUrlWithScheme(uri, gatewayUrls) {
  for (const scheme of Object.keys(gatewayUrls)) {
    for (const url of gatewayUrls[scheme]) {
      if (uri.startsWith(url)) {
        return uri.replace(url, scheme);
      }
    }
  }
  return uri;
}
function replaceSchemeWithGatewayUrl(uri, gatewayUrls) {
  let index = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0;
  const scheme = Object.keys(gatewayUrls).find((s) => uri.startsWith(s));
  const schemeGatewayUrls = scheme ? gatewayUrls[scheme] : [];
  if (!scheme && index > 0 || scheme && index >= schemeGatewayUrls.length) {
    return void 0;
  }
  if (!scheme) {
    return uri;
  }
  return uri.replace(scheme, schemeGatewayUrls[index]);
}
function replaceObjectGatewayUrlsWithSchemes(data, gatewayUrls) {
  if (typeof data === "string") {
    return replaceGatewayUrlWithScheme(data, gatewayUrls);
  }
  if (typeof data === "object") {
    if (!data) {
      return data;
    }
    if (isFileOrBuffer(data)) {
      return data;
    }
    if (Array.isArray(data)) {
      return data.map((entry) => replaceObjectGatewayUrlsWithSchemes(entry, gatewayUrls));
    }
    return Object.fromEntries(Object.entries(data).map((_ref) => {
      let [key, value] = _ref;
      return [key, replaceObjectGatewayUrlsWithSchemes(value, gatewayUrls)];
    }));
  }
  return data;
}
function replaceObjectSchemesWithGatewayUrls(data, gatewayUrls) {
  if (typeof data === "string") {
    return replaceSchemeWithGatewayUrl(data, gatewayUrls);
  }
  if (typeof data === "object") {
    if (!data) {
      return data;
    }
    if (isFileOrBuffer(data)) {
      return data;
    }
    if (Array.isArray(data)) {
      return data.map((entry) => replaceObjectSchemesWithGatewayUrls(entry, gatewayUrls));
    }
    return Object.fromEntries(Object.entries(data).map((_ref2) => {
      let [key, value] = _ref2;
      return [key, replaceObjectSchemesWithGatewayUrls(value, gatewayUrls)];
    }));
  }
  return data;
}
function extractObjectFiles(data) {
  let files = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];
  if (isFileOrBuffer(data)) {
    files.push(data);
    return files;
  }
  if (typeof data === "object") {
    if (!data) {
      return files;
    }
    if (Array.isArray(data)) {
      data.forEach((entry) => extractObjectFiles(entry, files));
    } else {
      Object.keys(data).map((key) => extractObjectFiles(data[key], files));
    }
  }
  return files;
}
function replaceObjectFilesWithUris(data, uris) {
  if (isFileOrBuffer(data)) {
    if (uris.length) {
      data = uris.shift();
      return data;
    } else {
      console.warn("Not enough URIs to replace all files in object.");
    }
  }
  if (typeof data === "object") {
    if (!data) {
      return data;
    }
    if (Array.isArray(data)) {
      return data.map((entry) => replaceObjectFilesWithUris(entry, uris));
    } else {
      return Object.fromEntries(Object.entries(data).map((_ref3) => {
        let [key, value] = _ref3;
        return [key, replaceObjectFilesWithUris(value, uris)];
      }));
    }
  }
  return data;
}
var StorageDownloader = class {
  async download(uri, gatewayUrls) {
    let attempts = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0;
    if (attempts > 3) {
      throw new Error("[FAILED_TO_DOWNLOAD_ERROR] Failed to download from URI - too many attempts failed.");
    }
    const resolvedUri = replaceSchemeWithGatewayUrl(uri, gatewayUrls, attempts);
    if (!resolvedUri) {
      throw new Error("[FAILED_TO_DOWNLOAD_ERROR] Unable to download from URI - all gateway URLs failed to respond.");
    }
    const res = await (0, import_cross_fetch.default)(resolvedUri);
    if (res.status >= 500 || res.status === 403 || res.status === 408) {
      console.warn(`Request to ${resolvedUri} failed with status ${res.status} - ${res.statusText}`);
      return this.download(uri, gatewayUrls, attempts + 1);
    }
    return res;
  }
};
var IpfsUploader = class {
  constructor(options) {
    _defineProperty2(this, "uploadWithGatewayUrl", void 0);
    this.uploadWithGatewayUrl = (options === null || options === void 0 ? void 0 : options.uploadWithGatewayUrl) || false;
  }
  async uploadBatch(data, options) {
    if (options !== null && options !== void 0 && options.uploadWithoutDirectory && data.length > 1) {
      throw new Error("[UPLOAD_WITHOUT_DIRECTORY_ERROR] Cannot upload more than one file or object without directory!");
    }
    const formData = new import_form_data.default();
    const {
      form,
      fileNames
    } = this.buildFormData(formData, data, options);
    if (isBrowser2()) {
      return this.uploadBatchBrowser(form, fileNames, options);
    } else {
      return this.uploadBatchNode(form, fileNames, options);
    }
  }
  async getUploadToken() {
    const res = await (0, import_cross_fetch.default)(`${TW_IPFS_SERVER_URL}/grant`, {
      method: "GET",
      headers: {
        "X-APP-NAME": !!process.env.CI ? "Storage SDK CI" : "Storage SDK"
      }
    });
    if (!res.ok) {
      throw new Error(`Failed to get upload token`);
    }
    const body = await res.text();
    return body;
  }
  buildFormData(form, files, options) {
    const fileNameToFileMap = /* @__PURE__ */ new Map();
    const fileNames = [];
    for (let i = 0; i < files.length; i++) {
      const file = files[i];
      let fileName = "";
      let fileData = file;
      if (isFileInstance(file)) {
        if (options !== null && options !== void 0 && options.rewriteFileNames) {
          let extensions = "";
          if (file.name) {
            const extensionStartIndex = file.name.lastIndexOf(".");
            if (extensionStartIndex > -1) {
              extensions = file.name.substring(extensionStartIndex);
            }
          }
          fileName = `${i + options.rewriteFileNames.fileStartNumber}${extensions}`;
        } else {
          fileName = `${file.name}`;
        }
      } else if (isBufferOrStringWithName(file)) {
        fileData = file.data;
        if (options !== null && options !== void 0 && options.rewriteFileNames) {
          fileName = `${i + options.rewriteFileNames.fileStartNumber}`;
        } else {
          fileName = `${file.name}`;
        }
      } else {
        if (options !== null && options !== void 0 && options.rewriteFileNames) {
          fileName = `${i + options.rewriteFileNames.fileStartNumber}`;
        } else {
          fileName = `${i}`;
        }
      }
      const filepath = options !== null && options !== void 0 && options.uploadWithoutDirectory ? `files` : `files/${fileName}`;
      if (fileNameToFileMap.has(fileName)) {
        if (isFileBufferOrStringEqual(fileNameToFileMap.get(fileName), file)) {
          fileNames.push(fileName);
          continue;
        }
        throw new Error(`[DUPLICATE_FILE_NAME_ERROR] File name ${fileName} was passed for more than one different file.`);
      }
      fileNameToFileMap.set(fileName, file);
      fileNames.push(fileName);
      if (!isBrowser2()) {
        form.append("file", fileData, {
          filepath
        });
      } else {
        form.append("file", new Blob([fileData]), filepath);
      }
    }
    const metadata = {
      name: `Storage SDK`,
      keyvalues: {}
    };
    form.append("pinataMetadata", JSON.stringify(metadata));
    if (options !== null && options !== void 0 && options.uploadWithoutDirectory) {
      form.append("pinataOptions", JSON.stringify({
        wrapWithDirectory: false
      }));
    }
    return {
      form,
      fileNames: fileNames.map((fName) => encodeURIComponent(fName))
    };
  }
  async uploadBatchBrowser(form, fileNames, options) {
    const token = await this.getUploadToken();
    return new Promise((resolve, reject) => {
      const xhr = new XMLHttpRequest();
      let timer = setTimeout(() => {
        xhr.abort();
        reject(new Error("Request to upload timed out! No upload progress received in 30s"));
      }, 3e4);
      xhr.upload.addEventListener("loadstart", () => {
        console.log(`[${Date.now()}] [IPFS] Started`);
      });
      xhr.upload.addEventListener("progress", (event) => {
        console.log(`[IPFS] Progress Event ${event.loaded}/${event.total}`);
        clearTimeout(timer);
        if (event.loaded < event.total) {
          timer = setTimeout(() => {
            xhr.abort();
            reject(new Error("Request to upload timed out! No upload progress received in 30s"));
          }, 3e4);
        } else {
          console.log(`[${Date.now()}] [IPFS] Uploaded files. Waiting for response.`);
        }
        if (event.lengthComputable && options !== null && options !== void 0 && options.onProgress) {
          options === null || options === void 0 ? void 0 : options.onProgress({
            progress: event.loaded,
            total: event.total
          });
        }
      });
      xhr.addEventListener("load", () => {
        console.log(`[${Date.now()}] [IPFS] Load`);
        clearTimeout(timer);
        if (xhr.status >= 200 && xhr.status < 300) {
          let body;
          try {
            body = JSON.parse(xhr.responseText);
          } catch (err) {
            return reject(new Error("Failed to parse JSON from upload response"));
          }
          const cid = body.IpfsHash;
          if (!cid) {
            throw new Error("Failed to get IPFS hash from upload response");
          }
          if (options !== null && options !== void 0 && options.uploadWithoutDirectory) {
            return resolve([`ipfs://${cid}`]);
          } else {
            return resolve(fileNames.map((name) => `ipfs://${cid}/${name}`));
          }
        }
        return reject(new Error(`Upload failed with status ${xhr.status} - ${xhr.responseText}`));
      });
      xhr.addEventListener("error", () => {
        console.log("[IPFS] Load");
        clearTimeout(timer);
        if (xhr.readyState !== 0 && xhr.readyState !== 4 || xhr.status === 0) {
          return reject(new Error("This looks like a network error, the endpoint might be blocked by an internet provider or a firewall."));
        }
        return reject(new Error("Unknown upload error occured"));
      });
      xhr.open("POST", PINATA_IPFS_URL);
      xhr.setRequestHeader("Authorization", `Bearer ${token}`);
      xhr.send(form);
    });
  }
  async uploadBatchNode(form, fileNames, options) {
    const token = await this.getUploadToken();
    if (options !== null && options !== void 0 && options.onProgress) {
      console.warn("The onProgress option is only supported in the browser");
    }
    const res = await (0, import_cross_fetch.default)(PINATA_IPFS_URL, {
      method: "POST",
      headers: {
        Authorization: `Bearer ${token}`,
        ...form.getHeaders()
      },
      body: form.getBuffer()
    });
    const body = await res.json();
    if (!res.ok) {
      console.warn(body);
      throw new Error("Failed to upload files to IPFS");
    }
    const cid = body.IpfsHash;
    if (!cid) {
      throw new Error("Failed to upload files to IPFS");
    }
    if (options !== null && options !== void 0 && options.uploadWithoutDirectory) {
      return [`ipfs://${cid}`];
    } else {
      return fileNames.map((name) => `ipfs://${cid}/${name}`);
    }
  }
};
var ThirdwebStorage = class {
  constructor(options) {
    _defineProperty2(this, "uploader", void 0);
    _defineProperty2(this, "downloader", void 0);
    _defineProperty2(this, "gatewayUrls", void 0);
    this.uploader = (options === null || options === void 0 ? void 0 : options.uploader) || new IpfsUploader();
    this.downloader = (options === null || options === void 0 ? void 0 : options.downloader) || new StorageDownloader();
    this.gatewayUrls = prepareGatewayUrls(options === null || options === void 0 ? void 0 : options.gatewayUrls);
  }
  resolveScheme(url) {
    return replaceSchemeWithGatewayUrl(url, this.gatewayUrls);
  }
  async download(url) {
    return this.downloader.download(url, this.gatewayUrls);
  }
  async downloadJSON(url) {
    const res = await this.download(url);
    const json = await res.json();
    return replaceObjectSchemesWithGatewayUrls(json, this.gatewayUrls);
  }
  async upload(data, options) {
    const [uri] = await this.uploadBatch([data], options);
    return uri;
  }
  async uploadBatch(data, options) {
    data = data.filter((item) => item !== void 0);
    if (!data.length) {
      return [];
    }
    const isFileArray = data.map((item) => isFileOrBuffer(item) || typeof item === "string").every((item) => !!item);
    let uris = [];
    if (isFileArray) {
      uris = await this.uploader.uploadBatch(data, options);
    } else {
      const metadata = (await this.uploadAndReplaceFilesWithHashes(data, options)).map((item) => {
        if (typeof item === "string") {
          return item;
        }
        return JSON.stringify(item);
      });
      uris = await this.uploader.uploadBatch(metadata, options);
    }
    if (options !== null && options !== void 0 && options.uploadWithGatewayUrl || this.uploader.uploadWithGatewayUrl) {
      return uris.map((uri) => this.resolveScheme(uri));
    } else {
      return uris;
    }
  }
  async uploadAndReplaceFilesWithHashes(data, options) {
    let cleaned = data;
    cleaned = replaceObjectGatewayUrlsWithSchemes(cleaned, this.gatewayUrls);
    const files = extractObjectFiles(cleaned);
    if (files.length) {
      const uris = await this.uploader.uploadBatch(files, options);
      cleaned = replaceObjectFilesWithUris(cleaned, uris);
    }
    if (options !== null && options !== void 0 && options.uploadWithGatewayUrl || this.uploader.uploadWithGatewayUrl) {
      cleaned = replaceObjectSchemesWithGatewayUrls(cleaned, this.gatewayUrls);
    }
    return cleaned;
  }
};

// node_modules/@thirdweb-dev/contracts-js/dist/abis/ERC2771Context.json
var ERC2771Context_default = [
  {
    inputs: [
      {
        internalType: "address",
        name: "forwarder",
        type: "address"
      }
    ],
    name: "isTrustedForwarder",
    outputs: [
      {
        internalType: "bool",
        name: "",
        type: "bool"
      }
    ],
    stateMutability: "view",
    type: "function"
  }
];

// node_modules/@thirdweb-dev/contracts-js/dist/abis/IAppURI.json
var IAppURI_default = [
  {
    anonymous: false,
    inputs: [
      {
        indexed: false,
        internalType: "string",
        name: "prevURI",
        type: "string"
      },
      {
        indexed: false,
        internalType: "string",
        name: "newURI",
        type: "string"
      }
    ],
    name: "AppURIUpdated",
    type: "event"
  },
  {
    inputs: [],
    name: "appURI",
    outputs: [
      {
        internalType: "string",
        name: "",
        type: "string"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "string",
        name: "_uri",
        type: "string"
      }
    ],
    name: "setAppURI",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  }
];

// node_modules/@thirdweb-dev/contracts-js/dist/abis/IContractMetadata.json
var IContractMetadata_default = [
  {
    anonymous: false,
    inputs: [
      {
        indexed: false,
        internalType: "string",
        name: "prevURI",
        type: "string"
      },
      {
        indexed: false,
        internalType: "string",
        name: "newURI",
        type: "string"
      }
    ],
    name: "ContractURIUpdated",
    type: "event"
  },
  {
    inputs: [],
    name: "contractURI",
    outputs: [
      {
        internalType: "string",
        name: "",
        type: "string"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "string",
        name: "_uri",
        type: "string"
      }
    ],
    name: "setContractURI",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  }
];

// node_modules/@thirdweb-dev/contracts-js/dist/abis/IPermissions.json
var IPermissions_default = [
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "bytes32",
        name: "role",
        type: "bytes32"
      },
      {
        indexed: true,
        internalType: "bytes32",
        name: "previousAdminRole",
        type: "bytes32"
      },
      {
        indexed: true,
        internalType: "bytes32",
        name: "newAdminRole",
        type: "bytes32"
      }
    ],
    name: "RoleAdminChanged",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "bytes32",
        name: "role",
        type: "bytes32"
      },
      {
        indexed: true,
        internalType: "address",
        name: "account",
        type: "address"
      },
      {
        indexed: true,
        internalType: "address",
        name: "sender",
        type: "address"
      }
    ],
    name: "RoleGranted",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "bytes32",
        name: "role",
        type: "bytes32"
      },
      {
        indexed: true,
        internalType: "address",
        name: "account",
        type: "address"
      },
      {
        indexed: true,
        internalType: "address",
        name: "sender",
        type: "address"
      }
    ],
    name: "RoleRevoked",
    type: "event"
  },
  {
    inputs: [
      {
        internalType: "bytes32",
        name: "role",
        type: "bytes32"
      }
    ],
    name: "getRoleAdmin",
    outputs: [
      {
        internalType: "bytes32",
        name: "",
        type: "bytes32"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "bytes32",
        name: "role",
        type: "bytes32"
      },
      {
        internalType: "address",
        name: "account",
        type: "address"
      }
    ],
    name: "grantRole",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "bytes32",
        name: "role",
        type: "bytes32"
      },
      {
        internalType: "address",
        name: "account",
        type: "address"
      }
    ],
    name: "hasRole",
    outputs: [
      {
        internalType: "bool",
        name: "",
        type: "bool"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "bytes32",
        name: "role",
        type: "bytes32"
      },
      {
        internalType: "address",
        name: "account",
        type: "address"
      }
    ],
    name: "renounceRole",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "bytes32",
        name: "role",
        type: "bytes32"
      },
      {
        internalType: "address",
        name: "account",
        type: "address"
      }
    ],
    name: "revokeRole",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  }
];

// node_modules/@thirdweb-dev/contracts-js/dist/abis/IPermissionsEnumerable.json
var IPermissionsEnumerable_default = [
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "bytes32",
        name: "role",
        type: "bytes32"
      },
      {
        indexed: true,
        internalType: "bytes32",
        name: "previousAdminRole",
        type: "bytes32"
      },
      {
        indexed: true,
        internalType: "bytes32",
        name: "newAdminRole",
        type: "bytes32"
      }
    ],
    name: "RoleAdminChanged",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "bytes32",
        name: "role",
        type: "bytes32"
      },
      {
        indexed: true,
        internalType: "address",
        name: "account",
        type: "address"
      },
      {
        indexed: true,
        internalType: "address",
        name: "sender",
        type: "address"
      }
    ],
    name: "RoleGranted",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "bytes32",
        name: "role",
        type: "bytes32"
      },
      {
        indexed: true,
        internalType: "address",
        name: "account",
        type: "address"
      },
      {
        indexed: true,
        internalType: "address",
        name: "sender",
        type: "address"
      }
    ],
    name: "RoleRevoked",
    type: "event"
  },
  {
    inputs: [
      {
        internalType: "bytes32",
        name: "role",
        type: "bytes32"
      }
    ],
    name: "getRoleAdmin",
    outputs: [
      {
        internalType: "bytes32",
        name: "",
        type: "bytes32"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "bytes32",
        name: "role",
        type: "bytes32"
      },
      {
        internalType: "uint256",
        name: "index",
        type: "uint256"
      }
    ],
    name: "getRoleMember",
    outputs: [
      {
        internalType: "address",
        name: "",
        type: "address"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "bytes32",
        name: "role",
        type: "bytes32"
      }
    ],
    name: "getRoleMemberCount",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "bytes32",
        name: "role",
        type: "bytes32"
      },
      {
        internalType: "address",
        name: "account",
        type: "address"
      }
    ],
    name: "grantRole",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "bytes32",
        name: "role",
        type: "bytes32"
      },
      {
        internalType: "address",
        name: "account",
        type: "address"
      }
    ],
    name: "hasRole",
    outputs: [
      {
        internalType: "bool",
        name: "",
        type: "bool"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "bytes32",
        name: "role",
        type: "bytes32"
      },
      {
        internalType: "address",
        name: "account",
        type: "address"
      }
    ],
    name: "renounceRole",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "bytes32",
        name: "role",
        type: "bytes32"
      },
      {
        internalType: "address",
        name: "account",
        type: "address"
      }
    ],
    name: "revokeRole",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  }
];

// node_modules/@thirdweb-dev/contracts-js/dist/abis/IPlatformFee.json
var IPlatformFee_default = [
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "platformFeeRecipient",
        type: "address"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "platformFeeBps",
        type: "uint256"
      }
    ],
    name: "PlatformFeeInfoUpdated",
    type: "event"
  },
  {
    inputs: [],
    name: "getPlatformFeeInfo",
    outputs: [
      {
        internalType: "address",
        name: "",
        type: "address"
      },
      {
        internalType: "uint16",
        name: "",
        type: "uint16"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "_platformFeeRecipient",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "_platformFeeBps",
        type: "uint256"
      }
    ],
    name: "setPlatformFeeInfo",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  }
];

// node_modules/@thirdweb-dev/contracts-js/dist/abis/IPrimarySale.json
var IPrimarySale_default = [
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "recipient",
        type: "address"
      }
    ],
    name: "PrimarySaleRecipientUpdated",
    type: "event"
  },
  {
    inputs: [],
    name: "primarySaleRecipient",
    outputs: [
      {
        internalType: "address",
        name: "",
        type: "address"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "_saleRecipient",
        type: "address"
      }
    ],
    name: "setPrimarySaleRecipient",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  }
];

// node_modules/@thirdweb-dev/contracts-js/dist/abis/IRoyalty.json
var IRoyalty_default = [
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "newRoyaltyRecipient",
        type: "address"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "newRoyaltyBps",
        type: "uint256"
      }
    ],
    name: "DefaultRoyalty",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "uint256",
        name: "tokenId",
        type: "uint256"
      },
      {
        indexed: true,
        internalType: "address",
        name: "royaltyRecipient",
        type: "address"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "royaltyBps",
        type: "uint256"
      }
    ],
    name: "RoyaltyForToken",
    type: "event"
  },
  {
    inputs: [],
    name: "getDefaultRoyaltyInfo",
    outputs: [
      {
        internalType: "address",
        name: "",
        type: "address"
      },
      {
        internalType: "uint16",
        name: "",
        type: "uint16"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "tokenId",
        type: "uint256"
      }
    ],
    name: "getRoyaltyInfoForToken",
    outputs: [
      {
        internalType: "address",
        name: "",
        type: "address"
      },
      {
        internalType: "uint16",
        name: "",
        type: "uint16"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "tokenId",
        type: "uint256"
      },
      {
        internalType: "uint256",
        name: "salePrice",
        type: "uint256"
      }
    ],
    name: "royaltyInfo",
    outputs: [
      {
        internalType: "address",
        name: "receiver",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "royaltyAmount",
        type: "uint256"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "_royaltyRecipient",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "_royaltyBps",
        type: "uint256"
      }
    ],
    name: "setDefaultRoyaltyInfo",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "tokenId",
        type: "uint256"
      },
      {
        internalType: "address",
        name: "recipient",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "bps",
        type: "uint256"
      }
    ],
    name: "setRoyaltyInfoForToken",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "bytes4",
        name: "interfaceId",
        type: "bytes4"
      }
    ],
    name: "supportsInterface",
    outputs: [
      {
        internalType: "bool",
        name: "",
        type: "bool"
      }
    ],
    stateMutability: "view",
    type: "function"
  }
];

// node_modules/@thirdweb-dev/contracts-js/dist/abis/Ownable.json
var Ownable_default = [
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "prevOwner",
        type: "address"
      },
      {
        indexed: true,
        internalType: "address",
        name: "newOwner",
        type: "address"
      }
    ],
    name: "OwnerUpdated",
    type: "event"
  },
  {
    inputs: [],
    name: "owner",
    outputs: [
      {
        internalType: "address",
        name: "",
        type: "address"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "_newOwner",
        type: "address"
      }
    ],
    name: "setOwner",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  }
];

// node_modules/@thirdweb-dev/sdk/dist/thirdweb-checkout-607fc720.esm.js
var import_cross_fetch2 = __toESM(require_browser_ponyfill());
var import_bs58 = __toESM(require_bs58());
var import_merkletreejs = __toESM(require_dist());
var import_fast_deep_equal = __toESM(require_fast_deep_equal());
var BigNumberSchema2 = mod.union([mod.string(), mod.number(), mod.bigint(), mod.custom((data) => {
  return BigNumber.isBigNumber(data);
})]).transform((arg) => BigNumber.from(arg));
var BigNumberishSchema = BigNumberSchema2.transform((arg) => arg.toString());
var BigNumberTransformSchema2 = mod.union([mod.bigint(), mod.custom((data) => {
  return BigNumber.isBigNumber(data);
})]).transform((arg) => {
  return BigNumber.from(arg).toString();
});
var AddressSchema = mod.string().refine((arg) => utils_exports.isAddress(arg), (out) => {
  return {
    message: `${out} is not a valid address`
  };
});
var RawDateSchema2 = mod.date().transform((i) => {
  return BigNumber.from(Math.floor(i.getTime() / 1e3));
});
var StartDateSchema = RawDateSchema2.default(new Date(0));
var EndDateSchema = RawDateSchema2.default(new Date(Date.now() + 1e3 * 60 * 60 * 24 * 365 * 10));
var CallOverrideSchema = mod.object({
  gasLimit: BigNumberishSchema.optional(),
  gasPrice: BigNumberishSchema.optional(),
  maxFeePerGas: BigNumberishSchema.optional(),
  maxPriorityFeePerGas: BigNumberishSchema.optional(),
  nonce: BigNumberishSchema.optional(),
  value: BigNumberishSchema.optional(),
  blockTag: mod.union([mod.string(), mod.number()]).optional(),
  from: AddressSchema.optional(),
  type: mod.number().optional()
}).strict();
var ChainId;
(function(ChainId2) {
  ChainId2[ChainId2["Mainnet"] = 1] = "Mainnet";
  ChainId2[ChainId2["Goerli"] = 5] = "Goerli";
  ChainId2[ChainId2["Polygon"] = 137] = "Polygon";
  ChainId2[ChainId2["Mumbai"] = 80001] = "Mumbai";
  ChainId2[ChainId2["Localhost"] = 1337] = "Localhost";
  ChainId2[ChainId2["Hardhat"] = 31337] = "Hardhat";
  ChainId2[ChainId2["Fantom"] = 250] = "Fantom";
  ChainId2[ChainId2["FantomTestnet"] = 4002] = "FantomTestnet";
  ChainId2[ChainId2["Avalanche"] = 43114] = "Avalanche";
  ChainId2[ChainId2["AvalancheFujiTestnet"] = 43113] = "AvalancheFujiTestnet";
  ChainId2[ChainId2["Optimism"] = 10] = "Optimism";
  ChainId2[ChainId2["OptimismGoerli"] = 420] = "OptimismGoerli";
  ChainId2[ChainId2["Arbitrum"] = 42161] = "Arbitrum";
  ChainId2[ChainId2["ArbitrumGoerli"] = 421613] = "ArbitrumGoerli";
  ChainId2[ChainId2["BinanceSmartChainMainnet"] = 56] = "BinanceSmartChainMainnet";
  ChainId2[ChainId2["BinanceSmartChainTestnet"] = 97] = "BinanceSmartChainTestnet";
})(ChainId || (ChainId = {}));
var SUPPORTED_CHAIN_IDS = [ChainId.Mainnet, ChainId.Goerli, ChainId.Polygon, ChainId.Mumbai, ChainId.Fantom, ChainId.FantomTestnet, ChainId.Avalanche, ChainId.AvalancheFujiTestnet, ChainId.Optimism, ChainId.OptimismGoerli, ChainId.Arbitrum, ChainId.ArbitrumGoerli, ChainId.BinanceSmartChainMainnet, ChainId.BinanceSmartChainTestnet];
var NATIVE_TOKEN_ADDRESS = "0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee";
var NATIVE_TOKENS = {
  [ChainId.Mainnet]: {
    name: "Ether",
    symbol: "ETH",
    decimals: 18,
    wrapped: {
      address: "0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2",
      name: "Wrapped Ether",
      symbol: "WETH"
    }
  },
  [ChainId.Goerli]: {
    name: "G\xF6rli Ether",
    symbol: "GOR",
    decimals: 18,
    wrapped: {
      address: "0xb4fbf271143f4fbf7b91a5ded31805e42b2208d6",
      name: "Wrapped Ether",
      symbol: "WETH"
    }
  },
  [ChainId.Polygon]: {
    name: "Matic",
    symbol: "MATIC",
    decimals: 18,
    wrapped: {
      address: "0x0d500B1d8E8eF31E21C99d1Db9A6444d3ADf1270",
      name: "Wrapped Matic",
      symbol: "WMATIC"
    }
  },
  [ChainId.Mumbai]: {
    name: "Matic",
    symbol: "MATIC",
    decimals: 18,
    wrapped: {
      address: "0x9c3C9283D3e44854697Cd22D3Faa240Cfb032889",
      name: "Wrapped Matic",
      symbol: "WMATIC"
    }
  },
  [ChainId.Avalanche]: {
    name: "Avalanche",
    symbol: "AVAX",
    decimals: 18,
    wrapped: {
      address: "0xB31f66AA3C1e785363F0875A1B74E27b85FD66c7",
      name: "Wrapped AVAX",
      symbol: "WAVAX"
    }
  },
  [ChainId.AvalancheFujiTestnet]: {
    name: "Avalanche",
    symbol: "AVAX",
    decimals: 18,
    wrapped: {
      address: "0xd00ae08403B9bbb9124bB305C09058E32C39A48c",
      name: "Wrapped AVAX",
      symbol: "WAVAX"
    }
  },
  [ChainId.Fantom]: {
    name: "Fantom",
    symbol: "FTM",
    decimals: 18,
    wrapped: {
      address: "0x21be370D5312f44cB42ce377BC9b8a0cEF1A4C83",
      name: "Wrapped Fantom",
      symbol: "WFTM"
    }
  },
  [ChainId.FantomTestnet]: {
    name: "Fantom",
    symbol: "FTM",
    decimals: 18,
    wrapped: {
      address: "0xf1277d1Ed8AD466beddF92ef448A132661956621",
      name: "Wrapped Fantom",
      symbol: "WFTM"
    }
  },
  [ChainId.Arbitrum]: {
    name: "Ether",
    symbol: "ETH",
    decimals: 18,
    wrapped: {
      address: "0x82af49447d8a07e3bd95bd0d56f35241523fbab1",
      name: "Wrapped Ether",
      symbol: "WETH"
    }
  },
  [ChainId.ArbitrumGoerli]: {
    name: "Arbitrum Goerli Ether",
    symbol: "AGOR",
    decimals: 18,
    wrapped: {
      address: "0xe39Ab88f8A4777030A534146A9Ca3B52bd5D43A3",
      name: "Wrapped Ether",
      symbol: "WETH"
    }
  },
  [ChainId.Optimism]: {
    name: "Ether",
    symbol: "ETH",
    decimals: 18,
    wrapped: {
      address: "0x4200000000000000000000000000000000000006",
      name: "Wrapped Ether",
      symbol: "WETH"
    }
  },
  [ChainId.OptimismGoerli]: {
    name: "Goerli Ether",
    symbol: "ETH",
    decimals: 18,
    wrapped: {
      address: "0x4200000000000000000000000000000000000006",
      name: "Wrapped Ether",
      symbol: "WETH"
    }
  },
  [ChainId.Hardhat]: {
    name: "Ether",
    symbol: "ETH",
    decimals: 18,
    wrapped: {
      address: "0x5FbDB2315678afecb367f032d93F642f64180aa3",
      name: "Wrapped Ether",
      symbol: "WETH"
    }
  },
  [ChainId.BinanceSmartChainMainnet]: {
    name: "Binance Chain Native Token",
    symbol: "BNB",
    decimals: 18,
    wrapped: {
      address: "0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c",
      name: "Wrapped Binance Chain Token",
      symbol: "WBNB"
    }
  },
  [ChainId.BinanceSmartChainTestnet]: {
    name: "Binance Chain Native Token",
    symbol: "TBNB",
    decimals: 18,
    wrapped: {
      address: "0xae13d989daC2f0dEbFf460aC112a837C89BAa7cd",
      name: "Wrapped Binance Chain Testnet Token",
      symbol: "WBNB"
    }
  }
};
function getNativeTokenByChainId(chainId) {
  return NATIVE_TOKENS[chainId];
}
var CurrencySchema = mod.object({
  name: mod.string(),
  symbol: mod.string(),
  decimals: mod.number()
});
var CurrencyValueSchema = CurrencySchema.extend({
  value: BigNumberSchema2,
  displayValue: mod.string()
});
var MerkleSchema = mod.object({
  merkle: mod.record(mod.string()).default({})
});
var SnapshotEntryInput = mod.object({
  address: AddressSchema,
  maxClaimable: QuantitySchema.default(0),
  price: QuantitySchema.optional(),
  currencyAddress: AddressSchema.default(ethers_exports.constants.AddressZero).optional()
});
var SnapshotInputSchema = mod.union([mod.array(mod.string()).transform((strings) => strings.map((address) => SnapshotEntryInput.parse({
  address
}))), mod.array(SnapshotEntryInput)]);
var SnapshotEntryWithProofSchema = SnapshotEntryInput.extend({
  proof: mod.array(mod.string())
});
var SnapshotSchema = mod.object({
  merkleRoot: mod.string(),
  claims: mod.array(SnapshotEntryWithProofSchema)
});
var SnapshotInfoSchema = mod.object({
  merkleRoot: mod.string(),
  snapshotUri: mod.string()
});
var ClaimConditionMetadataSchema = mod.object({
  name: mod.string().optional()
}).catchall(mod.unknown());
var ClaimConditionInputSchema = mod.object({
  startTime: StartDateSchema,
  currencyAddress: mod.string().default(NATIVE_TOKEN_ADDRESS),
  price: AmountSchema.default(0),
  maxClaimableSupply: QuantitySchema,
  maxClaimablePerWallet: QuantitySchema,
  waitInSeconds: BigNumberishSchema.default(0),
  merkleRootHash: BytesLikeSchema.default(utils_exports.hexZeroPad([0], 32)),
  snapshot: mod.optional(SnapshotInputSchema).nullable(),
  metadata: ClaimConditionMetadataSchema.optional()
});
var ClaimConditionInputArray = mod.array(ClaimConditionInputSchema);
var PartialClaimConditionInputSchema = ClaimConditionInputSchema.partial();
var ClaimConditionOutputSchema = ClaimConditionInputSchema.extend({
  availableSupply: QuantitySchema,
  currentMintSupply: QuantitySchema,
  currencyMetadata: CurrencyValueSchema.default({
    value: BigNumber.from("0"),
    displayValue: "0",
    symbol: "",
    decimals: 18,
    name: ""
  }),
  price: BigNumberSchema2,
  waitInSeconds: BigNumberSchema2,
  startTime: BigNumberSchema2.transform((n) => new Date(n.toNumber() * 1e3)),
  snapshot: SnapshotInputSchema.optional().nullable()
});
function resolveOrGenerateId(requestUId) {
  if (requestUId === void 0) {
    const buffer = Buffer.alloc(16);
    v4_default({}, buffer);
    return utils_exports.hexlify(utils_exports.toUtf8Bytes(buffer.toString("hex")));
  } else {
    return utils_exports.hexlify(requestUId);
  }
}
var BaseSignaturePayloadInput = mod.object({
  to: mod.string().refine((address) => address.toLowerCase() !== lib_exports.AddressZero, {
    message: "Cannot create payload to mint to zero address"
  }),
  price: AmountSchema.default(0),
  currencyAddress: mod.string().default(NATIVE_TOKEN_ADDRESS),
  mintStartTime: StartDateSchema,
  mintEndTime: EndDateSchema,
  uid: mod.string().optional().transform((arg) => resolveOrGenerateId(arg)),
  primarySaleRecipient: mod.string().default(lib_exports.AddressZero)
});
var Signature20PayloadInput = BaseSignaturePayloadInput.extend({
  quantity: AmountSchema
});
var Signature20PayloadOutput = Signature20PayloadInput.extend({
  mintStartTime: BigNumberSchema2,
  mintEndTime: BigNumberSchema2
});
var Signature721PayloadInput = BaseSignaturePayloadInput.extend({
  metadata: NFTInputOrUriSchema,
  royaltyRecipient: mod.string().default(lib_exports.AddressZero),
  royaltyBps: BasisPointsSchema.default(0)
});
var Signature721PayloadOutput = Signature721PayloadInput.extend({
  uri: mod.string(),
  royaltyBps: BigNumberSchema2,
  mintStartTime: BigNumberSchema2,
  mintEndTime: BigNumberSchema2
});
var Signature1155PayloadInput = Signature721PayloadInput.extend({
  metadata: NFTInputOrUriSchema.default(""),
  quantity: BigNumberishSchema
});
var Signature1155PayloadInputWithTokenId = Signature1155PayloadInput.extend({
  tokenId: BigNumberishSchema
});
var Signature1155PayloadOutput = Signature721PayloadOutput.extend({
  tokenId: BigNumberSchema2,
  quantity: BigNumberSchema2
});
var Signature721WithQuantityInput = Signature721PayloadInput.extend({
  metadata: NFTInputOrUriSchema.default(""),
  quantity: BigNumberSchema2.default(1)
});
var Signature721WithQuantityOutput = Signature721PayloadOutput.extend({
  quantity: BigNumberSchema2.default(1)
});
var MintRequest20 = [{
  name: "to",
  type: "address"
}, {
  name: "primarySaleRecipient",
  type: "address"
}, {
  name: "quantity",
  type: "uint256"
}, {
  name: "price",
  type: "uint256"
}, {
  name: "currency",
  type: "address"
}, {
  name: "validityStartTimestamp",
  type: "uint128"
}, {
  name: "validityEndTimestamp",
  type: "uint128"
}, {
  name: "uid",
  type: "bytes32"
}];
var MintRequest721 = [{
  name: "to",
  type: "address"
}, {
  name: "royaltyRecipient",
  type: "address"
}, {
  name: "royaltyBps",
  type: "uint256"
}, {
  name: "primarySaleRecipient",
  type: "address"
}, {
  name: "uri",
  type: "string"
}, {
  name: "price",
  type: "uint256"
}, {
  name: "currency",
  type: "address"
}, {
  name: "validityStartTimestamp",
  type: "uint128"
}, {
  name: "validityEndTimestamp",
  type: "uint128"
}, {
  name: "uid",
  type: "bytes32"
}];
var MintRequest1155 = [{
  name: "to",
  type: "address"
}, {
  name: "royaltyRecipient",
  type: "address"
}, {
  name: "royaltyBps",
  type: "uint256"
}, {
  name: "primarySaleRecipient",
  type: "address"
}, {
  name: "tokenId",
  type: "uint256"
}, {
  name: "uri",
  type: "string"
}, {
  name: "quantity",
  type: "uint256"
}, {
  name: "pricePerToken",
  type: "uint256"
}, {
  name: "currency",
  type: "address"
}, {
  name: "validityStartTimestamp",
  type: "uint128"
}, {
  name: "validityEndTimestamp",
  type: "uint128"
}, {
  name: "uid",
  type: "bytes32"
}];
var MintRequest721withQuantity = [{
  name: "to",
  type: "address"
}, {
  name: "royaltyRecipient",
  type: "address"
}, {
  name: "royaltyBps",
  type: "uint256"
}, {
  name: "primarySaleRecipient",
  type: "address"
}, {
  name: "uri",
  type: "string"
}, {
  name: "quantity",
  type: "uint256"
}, {
  name: "pricePerToken",
  type: "uint256"
}, {
  name: "currency",
  type: "address"
}, {
  name: "validityStartTimestamp",
  type: "uint128"
}, {
  name: "validityEndTimestamp",
  type: "uint128"
}, {
  name: "uid",
  type: "bytes32"
}];
var GenericRequest = [{
  name: "validityStartTimestamp",
  type: "uint128"
}, {
  name: "validityEndTimestamp",
  type: "uint128"
}, {
  name: "uid",
  type: "bytes32"
}, {
  name: "data",
  type: "bytes"
}];
var CommonContractSchema = mod.object({
  name: mod.string(),
  description: mod.string().optional(),
  image: FileOrBufferOrStringSchema.optional(),
  external_link: mod.string().url().optional()
});
var CommonContractOutputSchema = CommonContractSchema.extend({
  image: mod.string().optional()
}).catchall(mod.unknown());
var CommonRoyaltySchema = mod.object({
  seller_fee_basis_points: BasisPointsSchema.default(0),
  fee_recipient: AddressSchema.default(lib_exports.AddressZero)
});
var CommonPrimarySaleSchema = mod.object({
  primary_sale_recipient: AddressSchema
});
var CommonPlatformFeeSchema = mod.object({
  platform_fee_basis_points: BasisPointsSchema.default(0),
  platform_fee_recipient: AddressSchema.default(lib_exports.AddressZero)
});
var CommonTrustedForwarderSchema = mod.object({
  trusted_forwarders: mod.array(AddressSchema).default([])
});
var CommonSymbolSchema = mod.object({
  symbol: mod.string().optional().default("")
});
var PropertiesInput2 = mod.object({}).catchall(mod.union([BigNumberTransformSchema2, mod.unknown()]));
var OptionalPropertiesInput2 = mod.union([mod.array(PropertiesInput2), PropertiesInput2]).optional();
var TokenMintInputSchema = mod.object({
  toAddress: AddressSchema,
  amount: AmountSchema
});
var EditionMetadataOutputSchema = mod.object({
  supply: BigNumberSchema2,
  metadata: CommonNFTOutput
});
var EditionMetadataWithOwnerOutputSchema = EditionMetadataOutputSchema.extend({
  owner: mod.string(),
  quantityOwned: BigNumberSchema2
});
var EditionMetadataInputSchema = mod.object({
  supply: BigNumberishSchema,
  metadata: CommonNFTInput
});
var EditionMetadataInputOrUriSchema = mod.object({
  supply: BigNumberishSchema,
  metadata: NFTInputOrUriSchema
});
var OZ_DEFENDER_FORWARDER_ADDRESS = "0xc82BbE41f2cF04e3a8efA18F7032BDD7f6d98a81";
var TWRegistry_address = "0x7c487845f98938Bb955B1D5AD069d9a30e4131fd";
var TWFactory_address = "0x5DBC7B840baa9daBcBe9D2492E45D7244B54A2A0";
var ContractPublisher_address = "0x664244560eBa21Bf82d7150C791bE1AbcD5B4cd7";
var CONTRACT_ADDRESSES = {
  [ChainId.Mainnet]: {
    openzeppelinForwarder: OZ_DEFENDER_FORWARDER_ADDRESS,
    openzeppelinForwarderEOA: "0x76ce2CB1Ae48Fa067f4fb8c5f803111AE0B24BEA",
    biconomyForwarder: "0x84a0856b038eaAd1cC7E297cF34A7e72685A8693",
    twFactory: TWFactory_address,
    twRegistry: TWRegistry_address,
    twBYOCRegistry: lib_exports.AddressZero
  },
  [ChainId.Goerli]: {
    openzeppelinForwarder: "0x5001A14CA6163143316a7C614e30e6041033Ac20",
    openzeppelinForwarderEOA: "0xe73c50cB9c5B378627ff625BB6e6725A4A5D65d2",
    biconomyForwarder: "0xE041608922d06a4F26C0d4c27d8bCD01daf1f792",
    twFactory: TWFactory_address,
    twRegistry: TWRegistry_address,
    twBYOCRegistry: "0xB1Bd9d7942A250BA2Dce27DD601F2ED4211A60C4"
  },
  [ChainId.Polygon]: {
    openzeppelinForwarder: OZ_DEFENDER_FORWARDER_ADDRESS,
    openzeppelinForwarderEOA: "0x4f247c69184ad61036EC2Bb3213b69F10FbEDe1F",
    biconomyForwarder: "0x86C80a8aa58e0A4fa09A69624c31Ab2a6CAD56b8",
    twFactory: TWFactory_address,
    twRegistry: TWRegistry_address,
    twBYOCRegistry: "0x308473Be900F4185A56587dE54bDFF5E8f7a6AE7"
  },
  [ChainId.Mumbai]: {
    openzeppelinForwarder: OZ_DEFENDER_FORWARDER_ADDRESS,
    openzeppelinForwarderEOA: "0xb1A2883fc4d287d9cB8Dbb96cFF60C76BEf2D250",
    biconomyForwarder: "0x9399BB24DBB5C4b782C70c2969F58716Ebbd6a3b",
    twFactory: TWFactory_address,
    twRegistry: TWRegistry_address,
    twBYOCRegistry: "0x3F17972CB27506eb4a6a3D59659e0B57a43fd16C"
  },
  [ChainId.Avalanche]: {
    openzeppelinForwarder: OZ_DEFENDER_FORWARDER_ADDRESS,
    openzeppelinForwarderEOA: "0xb1A2883fc4d287d9cB8Dbb96cFF60C76BEf2D250",
    biconomyForwarder: "0x64CD353384109423a966dCd3Aa30D884C9b2E057",
    twFactory: TWFactory_address,
    twRegistry: TWRegistry_address,
    twBYOCRegistry: lib_exports.AddressZero
  },
  [ChainId.AvalancheFujiTestnet]: {
    openzeppelinForwarder: OZ_DEFENDER_FORWARDER_ADDRESS,
    openzeppelinForwarderEOA: "0xe73c50cB9c5B378627ff625BB6e6725A4A5D65d2",
    biconomyForwarder: "0x6271Ca63D30507f2Dcbf99B52787032506D75BBF",
    twFactory: TWFactory_address,
    twRegistry: TWRegistry_address,
    twBYOCRegistry: "0x3E6eE864f850F5e5A98bc950B68E181Cf4010F23"
  },
  [ChainId.Fantom]: {
    openzeppelinForwarder: OZ_DEFENDER_FORWARDER_ADDRESS,
    openzeppelinForwarderEOA: "0xb1A2883fc4d287d9cB8Dbb96cFF60C76BEf2D250",
    biconomyForwarder: "0x64CD353384109423a966dCd3Aa30D884C9b2E057",
    twFactory: "0x97EA0Fcc552D5A8Fb5e9101316AAd0D62Ea0876B",
    twRegistry: TWRegistry_address,
    twBYOCRegistry: lib_exports.AddressZero
  },
  [ChainId.FantomTestnet]: {
    openzeppelinForwarder: OZ_DEFENDER_FORWARDER_ADDRESS,
    openzeppelinForwarderEOA: "0x42D3048b595B6e1c28a588d70366CcC2AA4dB47b",
    biconomyForwarder: "0x69FB8Dca8067A5D38703b9e8b39cf2D51473E4b4",
    twFactory: TWFactory_address,
    twRegistry: TWRegistry_address,
    twBYOCRegistry: "0x3E6eE864f850F5e5A98bc950B68E181Cf4010F23"
  },
  [ChainId.Arbitrum]: {
    openzeppelinForwarder: OZ_DEFENDER_FORWARDER_ADDRESS,
    openzeppelinForwarderEOA: "0x4f247c69184ad61036EC2Bb3213b69F10FbEDe1F",
    biconomyForwarder: "0xfe0fa3C06d03bDC7fb49c892BbB39113B534fB57",
    twFactory: "0xd24b3de085CFd8c54b94feAD08a7962D343E6DE0",
    twRegistry: "0x7c487845f98938Bb955B1D5AD069d9a30e4131fd",
    twBYOCRegistry: lib_exports.AddressZero
  },
  [ChainId.ArbitrumGoerli]: {
    openzeppelinForwarder: "0x8cbc8B5d71702032904750A66AEfE8B603eBC538",
    openzeppelinForwarderEOA: "0x119704314Ef304EaAAE4b3c7C9ABd59272A28310",
    biconomyForwarder: lib_exports.AddressZero,
    twFactory: "0xd24b3de085CFd8c54b94feAD08a7962D343E6DE0",
    twRegistry: "0x7c487845f98938Bb955B1D5AD069d9a30e4131fd",
    twBYOCRegistry: lib_exports.AddressZero
  },
  [ChainId.Optimism]: {
    openzeppelinForwarder: OZ_DEFENDER_FORWARDER_ADDRESS,
    openzeppelinForwarderEOA: "0x7e80648EB2071E26937F9D42A513ccf4815fc702",
    biconomyForwarder: "0xefba8a2a82ec1fb1273806174f5e28fbb917cf95",
    twFactory: "0xd24b3de085CFd8c54b94feAD08a7962D343E6DE0",
    twRegistry: "0x7c487845f98938Bb955B1D5AD069d9a30e4131fd",
    twBYOCRegistry: lib_exports.AddressZero
  },
  [ChainId.OptimismGoerli]: {
    openzeppelinForwarder: "0x8cbc8B5d71702032904750A66AEfE8B603eBC538",
    openzeppelinForwarderEOA: "0x119704314Ef304EaAAE4b3c7C9ABd59272A28310",
    biconomyForwarder: lib_exports.AddressZero,
    twFactory: "0xd24b3de085CFd8c54b94feAD08a7962D343E6DE0",
    twRegistry: "0x7c487845f98938Bb955B1D5AD069d9a30e4131fd",
    twBYOCRegistry: lib_exports.AddressZero
  },
  [ChainId.BinanceSmartChainMainnet]: {
    openzeppelinForwarder: "0x8cbc8B5d71702032904750A66AEfE8B603eBC538",
    openzeppelinForwarderEOA: "0xE8dd2Ff0212F86d3197b4AfDC6dAC6ac47eb10aC",
    biconomyForwarder: "0x86C80a8aa58e0A4fa09A69624c31Ab2a6CAD56b8",
    twBYOCRegistry: lib_exports.AddressZero,
    twFactory: "0xd24b3de085CFd8c54b94feAD08a7962D343E6DE0",
    twRegistry: "0x7c487845f98938Bb955B1D5AD069d9a30e4131fd"
  },
  [ChainId.BinanceSmartChainTestnet]: {
    openzeppelinForwarder: "0x8cbc8B5d71702032904750A66AEfE8B603eBC538",
    openzeppelinForwarderEOA: "0x7e80648EB2071E26937F9D42A513ccf4815fc702",
    biconomyForwarder: "0x61456BF1715C1415730076BB79ae118E806E74d2",
    twBYOCRegistry: lib_exports.AddressZero,
    twFactory: "0xd24b3de085CFd8c54b94feAD08a7962D343E6DE0",
    twRegistry: "0x7c487845f98938Bb955B1D5AD069d9a30e4131fd"
  }
};
var APPROVED_IMPLEMENTATIONS = {
  [ChainId.Mainnet]: {
    "nft-drop": "0x60fF9952e0084A6DEac44203838cDC91ABeC8736",
    "edition-drop": "0x74af262d0671F378F97a1EDC3d0970Dbe8A1C550",
    "token-drop": "0xE1eE43D23f247b6A9aF81fcE2766E76709482728",
    "signature-drop": "0x6fD690EB509BdE4C50028C5D9C0dE3750C2Fad6A"
  },
  [ChainId.Polygon]: {
    "nft-drop": "0xB96508050Ba0925256184103560EBADA912Fcc69",
    "edition-drop": "0x74af262d0671F378F97a1EDC3d0970Dbe8A1C550",
    "token-drop": "0x5A8eA4Adad8289746D073947BA06D69A62499aaf",
    "signature-drop": "0xBE2fDc35410E268e41Bec62DBb01AEb43245c7d5"
  },
  [ChainId.Fantom]: {
    "nft-drop": "0x2A396b2D90BAcEF19cDa973586B2633d22710fC2",
    "edition-drop": "0x06395FCF9AC6ED827f9dD6e776809cEF1Be0d21B",
    "token-drop": "0x0148b28a38efaaC31b6aa0a6D9FEb70FE7C91FFa",
    "signature-drop": "0xe135Ef65C2B2213C3fD56d0Bd6500A2cA147aC10"
  },
  [ChainId.Avalanche]: {
    "nft-drop": "0x9cF91118C8ee2913F0588e0F10e36B3d63F68bF6",
    "edition-drop": "0x135fC9D26E5eC51260ece1DF4ED424E2f55c7766",
    "token-drop": "0xca0B071899E575BA86495D46c5066971b6f3A901",
    "signature-drop": "0x1d47526C3292B0130ef0afD5F02c1DA052A017B3"
  },
  [ChainId.Optimism]: {
    "nft-drop": "0xFBd7D24d80ee005671E731a7287DEB6073264dD1",
    "edition-drop": "0xe135Ef65C2B2213C3fD56d0Bd6500A2cA147aC10",
    "token-drop": "0x902Dd246e66d8C3CE652375a723F2a52b43b9AAE",
    "signature-drop": "0x8a4cd3549e548bbEEb38C16E041FFf040a5acabD"
  },
  [ChainId.Arbitrum]: {
    "nft-drop": "0xC4903c1Ff5367b9ac2c349B63DC2409421AaEE2a",
    "edition-drop": "0xCcddcec1831646Beff2753249f1B9C580327E89F",
    "token-drop": "0x1b5947e1a2d5a29D0df20931DeAB0B87818209B9",
    "signature-drop": "0x2dF9851af45dd41C8584ac55D983C604da985Bc7"
  },
  [ChainId.BinanceSmartChainMainnet]: {
    "nft-drop": "0x902Dd246e66d8C3CE652375a723F2a52b43b9AAE",
    "edition-drop": "0x2A396b2D90BAcEF19cDa973586B2633d22710fC2",
    "token-drop": "0xe135Ef65C2B2213C3fD56d0Bd6500A2cA147aC10",
    "signature-drop": "0xFBd7D24d80ee005671E731a7287DEB6073264dD1"
  },
  [ChainId.Goerli]: {
    "nft-drop": "0xD11c97DD5F5546B5bBd630D7D1d7327481B0b92C",
    "edition-drop": "0x5A8eA4Adad8289746D073947BA06D69A62499aaf",
    "token-drop": "0x5680933221B752EB443654a014f88B101F868d50",
    "signature-drop": "0x1b5947e1a2d5a29D0df20931DeAB0B87818209B9"
  },
  [ChainId.Mumbai]: {
    "nft-drop": "0xC4903c1Ff5367b9ac2c349B63DC2409421AaEE2a",
    "edition-drop": "0xCcddcec1831646Beff2753249f1B9C580327E89F",
    "token-drop": "0x1b5947e1a2d5a29D0df20931DeAB0B87818209B9",
    "signature-drop": "0x2dF9851af45dd41C8584ac55D983C604da985Bc7"
  },
  [ChainId.FantomTestnet]: {
    "nft-drop": "0x8a4cd3549e548bbEEb38C16E041FFf040a5acabD",
    "edition-drop": "0x902Dd246e66d8C3CE652375a723F2a52b43b9AAE",
    "token-drop": "0xFBd7D24d80ee005671E731a7287DEB6073264dD1",
    "signature-drop": "0x5A8eA4Adad8289746D073947BA06D69A62499aaf"
  },
  [ChainId.AvalancheFujiTestnet]: {
    "nft-drop": "0xD11c97DD5F5546B5bBd630D7D1d7327481B0b92C",
    "edition-drop": "0xE1eE43D23f247b6A9aF81fcE2766E76709482728",
    "token-drop": "0x6fD690EB509BdE4C50028C5D9C0dE3750C2Fad6A",
    "signature-drop": "0xCcddcec1831646Beff2753249f1B9C580327E89F"
  },
  [ChainId.OptimismGoerli]: {
    "nft-drop": "0xCcddcec1831646Beff2753249f1B9C580327E89F",
    "edition-drop": "0x6fD690EB509BdE4C50028C5D9C0dE3750C2Fad6A",
    "token-drop": "0xD11c97DD5F5546B5bBd630D7D1d7327481B0b92C",
    "signature-drop": "0x1b5947e1a2d5a29D0df20931DeAB0B87818209B9"
  },
  [ChainId.ArbitrumGoerli]: {
    "nft-drop": "0x9CfE807a5b124b962064Fa8F7FD823Cc701255b6",
    "edition-drop": "0x9cF91118C8ee2913F0588e0F10e36B3d63F68bF6",
    "token-drop": "0x1d47526C3292B0130ef0afD5F02c1DA052A017B3",
    "signature-drop": "0xE1eE43D23f247b6A9aF81fcE2766E76709482728"
  },
  [ChainId.BinanceSmartChainTestnet]: {
    "nft-drop": "",
    "edition-drop": "",
    "token-drop": "",
    "signature-drop": ""
  }
};
function getApprovedImplementation(chainId, contractType) {
  if (chainId in APPROVED_IMPLEMENTATIONS) {
    const approvedImpls = APPROVED_IMPLEMENTATIONS[chainId];
    if (contractType in approvedImpls) {
      return approvedImpls[contractType];
    }
  }
  return null;
}
function getContractAddressByChainId(chainId, contractName) {
  if (chainId === ChainId.Hardhat) {
    if (contractName === "twFactory") {
      return process.env.factoryAddress;
    } else if (contractName === "twRegistry") {
      return process.env.registryAddress;
    } else {
      return lib_exports.AddressZero;
    }
  }
  return CONTRACT_ADDRESSES[chainId][contractName];
}
function getContractPublisherAddress() {
  if (process.env.contractPublisherAddress) {
    return process.env.contractPublisherAddress;
  } else {
    return ContractPublisher_address;
  }
}
function getDefaultTrustedForwarders(chainId) {
  const chainEnum = SUPPORTED_CHAIN_IDS.find((c) => c === chainId);
  const biconomyForwarder = chainEnum ? CONTRACT_ADDRESSES[chainEnum].biconomyForwarder : lib_exports.AddressZero;
  const openzeppelinForwarder = chainEnum ? CONTRACT_ADDRESSES[chainEnum].openzeppelinForwarder : lib_exports.AddressZero;
  return biconomyForwarder !== lib_exports.AddressZero ? [openzeppelinForwarder, biconomyForwarder] : [openzeppelinForwarder];
}
var InterfaceId_IERC721 = utils_exports.arrayify("0x80ac58cd");
var InterfaceId_IERC1155 = utils_exports.arrayify("0xd9b67a26");
var EventType;
(function(EventType2) {
  EventType2["Transaction"] = "transaction";
  EventType2["Signature"] = "signature";
})(EventType || (EventType = {}));
var DEFAULT_BATCH_TIME_LIMIT_MS = 50;
var DEFAULT_BATCH_SIZE_LIMIT = 250;
var DEFAULT_BATCH_OPTIONS = {
  timeLimitMs: DEFAULT_BATCH_TIME_LIMIT_MS,
  sizeLimit: DEFAULT_BATCH_SIZE_LIMIT
};
var StaticJsonRpcBatchProvider = class extends lib_exports2.StaticJsonRpcProvider {
  constructor(url, network) {
    let batchOptions = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : DEFAULT_BATCH_OPTIONS;
    super(url, network);
    _defineProperty(this, "_timeLimitMs", void 0);
    _defineProperty(this, "_sizeLimit", void 0);
    _defineProperty(this, "_pendingBatchAggregator", void 0);
    _defineProperty(this, "_pendingBatch", void 0);
    this._timeLimitMs = batchOptions.timeLimitMs || DEFAULT_BATCH_SIZE_LIMIT;
    this._sizeLimit = batchOptions.sizeLimit || DEFAULT_BATCH_TIME_LIMIT_MS;
    this._pendingBatchAggregator = null;
    this._pendingBatch = null;
  }
  sendCurrentBatch(request) {
    if (this._pendingBatchAggregator) {
      clearTimeout(this._pendingBatchAggregator);
    }
    const batch = this._pendingBatch || [];
    this._pendingBatch = null;
    this._pendingBatchAggregator = null;
    const request_ = batch.map((inflight) => inflight.request);
    this.emit("debug", {
      action: "requestBatch",
      request: utils_exports.deepCopy(request),
      provider: this
    });
    return utils_exports.fetchJson(this.connection, JSON.stringify(request_)).then((result) => {
      this.emit("debug", {
        action: "response",
        request: request_,
        response: result,
        provider: this
      });
      batch.forEach((inflightRequest_, index) => {
        const payload = result[index];
        if (payload.error) {
          const error = new Error(payload.error.message);
          error.code = payload.error.code;
          error.data = payload.error.data;
          inflightRequest_.reject(error);
        } else {
          inflightRequest_.resolve(payload.result);
        }
      });
    }, (error) => {
      this.emit("debug", {
        action: "response",
        error,
        request: request_,
        provider: this
      });
      batch.forEach((inflightRequest_) => {
        inflightRequest_.reject(error);
      });
    });
  }
  send(method, params) {
    const request = {
      method,
      params,
      id: this._nextId++,
      jsonrpc: "2.0"
    };
    if (this._pendingBatch === null) {
      this._pendingBatch = [];
    }
    const inflightRequest = {
      request,
      resolve: null,
      reject: null
    };
    const promise = new Promise((resolve, reject) => {
      inflightRequest.resolve = resolve;
      inflightRequest.reject = reject;
    });
    if (this._pendingBatch.length === this._sizeLimit) {
      this.sendCurrentBatch(request);
    }
    this._pendingBatch.push(inflightRequest);
    if (!this._pendingBatchAggregator) {
      this._pendingBatchAggregator = setTimeout(() => {
        this.sendCurrentBatch(request);
      }, this._timeLimitMs);
    }
    return promise;
  }
};
var CHAIN_NAME_TO_ID = {
  "avalanche-fuji": ChainId.AvalancheFujiTestnet,
  "avalanche-testnet": ChainId.AvalancheFujiTestnet,
  "fantom-testnet": ChainId.FantomTestnet,
  ethereum: ChainId.Mainnet,
  matic: ChainId.Polygon,
  mumbai: ChainId.Mumbai,
  goerli: ChainId.Goerli,
  polygon: ChainId.Polygon,
  mainnet: ChainId.Mainnet,
  optimism: ChainId.Optimism,
  "optimism-goerli": ChainId.OptimismGoerli,
  arbitrum: ChainId.Arbitrum,
  "arbitrum-goerli": ChainId.ArbitrumGoerli,
  fantom: ChainId.Fantom,
  avalanche: ChainId.Avalanche,
  binance: ChainId.BinanceSmartChainMainnet,
  "binance-testnet": ChainId.BinanceSmartChainTestnet
};
var CHAIN_ID_TO_NAME = Object.fromEntries(Object.entries(CHAIN_NAME_TO_ID).map((_ref) => {
  let [name, id] = _ref;
  return [id, name];
}));
function buildDefaultMap() {
  return SUPPORTED_CHAIN_IDS.reduce((previousValue, currentValue) => {
    previousValue[currentValue] = getProviderForNetwork(CHAIN_ID_TO_NAME[currentValue]);
    return previousValue;
  }, {});
}
var DEFAULT_RPC_URLS = buildDefaultMap();
function getProviderForNetwork(network) {
  if (typeof network !== "string") {
    return network;
  }
  switch (network) {
    case "mainnet":
    case "ethereum":
      return getRpcUrl("ethereum");
    case "goerli":
      return getRpcUrl("goerli");
    case "polygon":
    case "matic":
      return getRpcUrl("polygon");
    case "mumbai":
      return getRpcUrl("mumbai");
    case "optimism":
      return getRpcUrl("optimism");
    case "optimism-goerli":
      return getRpcUrl("optimism-goerli");
    case "arbitrum":
      return getRpcUrl("arbitrum");
    case "arbitrum-goerli":
      return getRpcUrl("arbitrum-goerli");
    case "fantom":
      return getRpcUrl("fantom");
    case "fantom-testnet":
      return getRpcUrl("fantom-testnet");
    case "avalanche":
      return getRpcUrl("avalanche");
    case "avalanche-testnet":
    case "avalanche-fuji":
      return getRpcUrl("avalanche-fuji");
    case "binance":
      return getRpcUrl("binance");
    case "binance-testnet":
      return getRpcUrl("binance-testnet");
    default:
      if (network.startsWith("http") || network.startsWith("ws")) {
        return network;
      } else {
        throw new Error(`Unrecognized chain name or RPC url: ${network}`);
      }
  }
}
var READONLY_PROVIDER_MAP = /* @__PURE__ */ new Map();
function getReadOnlyProvider(network, chainId) {
  try {
    const match = network.match(/^(ws|http)s?:/i);
    if (match) {
      switch (match[1]) {
        case "http":
          const seralizedOpts = `${network}-${chainId || -1}`;
          const existingProvider = READONLY_PROVIDER_MAP.get(seralizedOpts);
          if (existingProvider) {
            return existingProvider;
          }
          const newProvider = chainId ? new StaticJsonRpcBatchProvider(network, chainId) : new lib_exports2.JsonRpcBatchProvider(network, chainId);
          READONLY_PROVIDER_MAP.set(seralizedOpts, newProvider);
          return newProvider;
        case "ws":
          return new lib_exports2.WebSocketProvider(network, chainId);
        default:
          return ethers_exports.getDefaultProvider(network);
      }
    } else {
      return ethers_exports.getDefaultProvider(network);
    }
  } catch (e) {
    return ethers_exports.getDefaultProvider(network);
  }
}
var NotFoundError = class extends Error {
  constructor(identifier) {
    super(identifier ? `Object with id ${identifier} NOT FOUND` : "NOT_FOUND");
  }
};
var MissingRoleError = class extends Error {
  constructor(address, role) {
    super(`MISSING ROLE: ${address} does not have the '${role}' role`);
  }
};
var DuplicateLeafsError = class extends Error {
  constructor(message) {
    super(`DUPLICATE_LEAFS${message ? ` : ${message}` : ""}`);
  }
};
var AuctionAlreadyStartedError = class extends Error {
  constructor(id) {
    super(`Auction already started with existing bid${id ? `, id: ${id}` : ""}`);
  }
};
var ListingNotFoundError = class extends Error {
  constructor(marketplaceContractAddress, listingId) {
    super(`Could not find listing.${marketplaceContractAddress ? ` marketplace address: ${marketplaceContractAddress}` : ""}${listingId ? ` listing id: ${listingId}` : ""}`);
  }
};
var WrongListingTypeError = class extends Error {
  constructor(marketplaceContractAddress, listingId, actualType, expectedType) {
    super(`Incorrect listing type. Are you sure you're using the right method?.${marketplaceContractAddress ? ` marketplace address: ${marketplaceContractAddress}` : ""}${listingId ? ` listing id: ${listingId}` : ""}${expectedType ? ` expected type: ${expectedType}` : ""}${actualType ? ` actual type: ${actualType}` : ""}`);
  }
};
var AuctionHasNotEndedError = class extends Error {
  constructor(id, endTime) {
    super(`Auction has not ended yet${id ? `, id: ${id}` : ""}${endTime ? `, end time: ${endTime.toString()}` : ""}`);
  }
};
var ExtensionNotImplementedError = class extends Error {
  constructor(feature) {
    super(`This functionality is not available because the contract does not implement the '${feature.docLinks.contracts}' Extension. Learn how to unlock this functionality at https://portal.thirdweb.com/extensions `);
  }
};
var TransactionError = class extends Error {
  constructor(reason, from, to, data, network, rpcUrl, raw, functionInfo) {
    var _a;
    let builtErrorMsg = "Contract transaction failed\n\n";
    builtErrorMsg += `Message: ${reason}`;
    builtErrorMsg += "\n\n| Transaction info |\n";
    builtErrorMsg += withSpaces("from", from);
    builtErrorMsg += withSpaces("to", to);
    builtErrorMsg += withSpaces(`chain`, `${network.name} (${network.chainId})`);
    if (functionInfo) {
      builtErrorMsg += "\n\n| Failed contract call info |\n";
      builtErrorMsg += withSpaces("function", functionInfo.signature);
      builtErrorMsg += withSpaces(`arguments`, JSON.stringify(functionInfo.inputs, null, 2));
      if (functionInfo.value.gt(0)) {
        builtErrorMsg += withSpaces("value", `${ethers_exports.utils.formatEther(functionInfo.value)} ${(_a = NATIVE_TOKENS[network.chainId]) == null ? void 0 : _a.symbol}`);
      }
    }
    try {
      const url = new URL(rpcUrl);
      builtErrorMsg += withSpaces(`RPC`, url.hostname);
    } catch (e2) {
    }
    builtErrorMsg += "\n\n";
    builtErrorMsg += "Need help with this error? Join our community: https://discord.gg/thirdweb";
    builtErrorMsg += "\n\n\n\n";
    builtErrorMsg += "| Raw error |";
    builtErrorMsg += "\n\n";
    builtErrorMsg += raw;
    super(builtErrorMsg);
    _defineProperty(this, "reason", void 0);
    _defineProperty(this, "from", void 0);
    _defineProperty(this, "to", void 0);
    _defineProperty(this, "data", void 0);
    _defineProperty(this, "chain", void 0);
    _defineProperty(this, "rpcUrl", void 0);
    _defineProperty(this, "functionInfo", void 0);
    this.reason = reason;
    this.from = from;
    this.to = to;
    this.data = data;
    this.chain = network;
    this.rpcUrl = rpcUrl;
    this.functionInfo = functionInfo;
  }
};
function parseFunctionInfo(data, contractInterface) {
  try {
    const fnFragment = contractInterface.parseTransaction({
      data
    });
    const results = {};
    const args = fnFragment.args;
    fnFragment.functionFragment.inputs.forEach((param, index) => {
      if (Array.isArray(args[index])) {
        const obj = {};
        const components = param.components;
        if (components) {
          const arr = args[index];
          for (let i = 0; i < components.length; i++) {
            const name = components[i].name;
            obj[name] = arr[i];
          }
          results[param.name] = obj;
        }
      } else {
        results[param.name] = args[index];
      }
    });
    return {
      signature: fnFragment.signature,
      inputs: results,
      value: fnFragment.value
    };
  } catch (e) {
    return void 0;
  }
}
async function convertToTWError(error, network, signerAddress, contractAddress, contractInterface) {
  let raw;
  if (typeof error === "object") {
    raw = JSON.stringify(error);
  } else {
    raw = error.toString();
  }
  const reason = parseMessageParts(/.*?"message[^a-zA-Z0-9]*([^"\\]*).*?/, raw) || parseMessageParts(/.*?"reason[^a-zA-Z0-9]*([^"\\]*).*?/, raw);
  const data = parseMessageParts(/.*?"data[^a-zA-Z0-9]*([^"\\]*).*?/, raw);
  const rpcUrl = parseMessageParts(/.*?"url[^a-zA-Z0-9]*([^"\\]*).*?/, raw);
  let from = parseMessageParts(/.*?"from[^a-zA-Z0-9]*([^"\\]*).*?/, raw);
  let to = parseMessageParts(/.*?"to[^a-zA-Z0-9]*([^"\\]*).*?/, raw);
  if (to === "") {
    to = contractAddress;
  }
  if (from === "") {
    from = signerAddress;
  }
  const functionInfo = data.length > 0 ? parseFunctionInfo(data, contractInterface) : void 0;
  return new TransactionError(reason, from, to, data, network, rpcUrl, raw, functionInfo);
}
function withSpaces(label, content) {
  if (content === "") {
    return content;
  }
  const spaces = Array(10 - label.length).fill(" ").join("");
  return `
${label}:${spaces}${content}`;
}
function parseMessageParts(regex, raw) {
  const msgMatches = raw.match(regex) || [];
  let extracted = "";
  if ((msgMatches == null ? void 0 : msgMatches.length) > 0) {
    extracted += msgMatches[1];
  }
  return extracted;
}
function includesErrorMessage(err, message) {
  if (!err) {
    return false;
  }
  return err && err.toString().includes(message) || err && err.message && err.message.toString().includes(message) || err && err.error && err.error.toString().includes(message);
}
var DropErc721ContractInput = CommonContractSchema.merge(CommonRoyaltySchema).merge(MerkleSchema).merge(CommonSymbolSchema);
var DropErc721ContractOutput = CommonContractOutputSchema.merge(CommonRoyaltySchema).merge(MerkleSchema).merge(CommonSymbolSchema);
var DropErc721ContractDeploy = DropErc721ContractInput.merge(CommonPlatformFeeSchema).merge(CommonPrimarySaleSchema).merge(CommonTrustedForwarderSchema);
var DropErc721ContractSchema = {
  deploy: DropErc721ContractDeploy,
  output: DropErc721ContractOutput,
  input: DropErc721ContractInput
};
var DropErc1155ContractInput = CommonContractSchema.merge(CommonRoyaltySchema).merge(MerkleSchema).merge(CommonSymbolSchema);
var DropErc1155ContractOutput = CommonContractOutputSchema.merge(CommonRoyaltySchema).merge(MerkleSchema).merge(CommonSymbolSchema);
var DropErc1155ContractDeploy = DropErc1155ContractInput.merge(CommonPlatformFeeSchema).merge(CommonPrimarySaleSchema).merge(CommonTrustedForwarderSchema);
var DropErc1155ContractSchema = {
  deploy: DropErc1155ContractDeploy,
  output: DropErc1155ContractOutput,
  input: DropErc1155ContractInput
};
var MarketplaceContractInput = CommonContractSchema;
var MarketplaceContractOutput = CommonContractOutputSchema;
var MarketplaceContractDeploy = MarketplaceContractInput.merge(CommonPlatformFeeSchema).merge(CommonTrustedForwarderSchema);
var MarketplaceContractSchema = {
  deploy: MarketplaceContractDeploy,
  output: MarketplaceContractOutput,
  input: MarketplaceContractInput
};
var PackContractInput = CommonContractSchema.merge(CommonRoyaltySchema).merge(CommonSymbolSchema);
var PackContractOutput = CommonContractOutputSchema.merge(CommonRoyaltySchema).merge(CommonSymbolSchema);
var PackContractDeploy = PackContractInput.merge(CommonPlatformFeeSchema).merge(CommonTrustedForwarderSchema);
var PackContractSchema = {
  deploy: PackContractDeploy,
  output: PackContractOutput,
  input: PackContractInput
};
var SplitRecipientInputSchema = mod.object({
  address: AddressSchema,
  sharesBps: BasisPointsSchema.gt(0, "Shares must be greater than 0")
});
var SplitRecipientOuputSchema = SplitRecipientInputSchema.extend({
  address: AddressSchema,
  sharesBps: BasisPointsSchema
});
var SplitsContractInput = CommonContractSchema.extend({
  recipients: mod.array(SplitRecipientInputSchema).default([]).superRefine((val, context) => {
    const addressMap = {};
    let totalShares = 0;
    for (let index = 0; index < val.length; index++) {
      const entry = val[index];
      if (addressMap[entry.address]) {
        context.addIssue({
          code: mod.ZodIssueCode.custom,
          message: `Duplicate address.`,
          path: [index, `address`]
        });
      }
      addressMap[entry.address] = true;
      totalShares += entry.sharesBps;
      if (totalShares > 1e4) {
        context.addIssue({
          code: mod.ZodIssueCode.custom,
          message: `Total shares cannot go over 100%.`,
          path: [index, `sharesBps`]
        });
      }
    }
    if (totalShares !== 1e4) {
      context.addIssue({
        code: mod.ZodIssueCode.custom,
        message: `Total shares need to add up to 100%. Total shares are currently ${totalShares / 100}%`,
        path: []
      });
    }
  })
});
var SplitsContractOutput = CommonContractOutputSchema.extend({
  recipients: mod.array(SplitRecipientOuputSchema)
});
var SplitsContractDeploy = SplitsContractInput.merge(SplitsContractInput).merge(CommonTrustedForwarderSchema);
var SplitsContractSchema = {
  deploy: SplitsContractDeploy,
  output: SplitsContractOutput,
  input: SplitsContractInput
};
var TokenErc20ContractInput = CommonContractSchema.merge(CommonSymbolSchema);
var TokenErc20ContractOutput = CommonContractOutputSchema.merge(CommonSymbolSchema);
var TokenErc20ContractDeploy = TokenErc20ContractInput.merge(CommonPlatformFeeSchema).merge(CommonPrimarySaleSchema).merge(CommonTrustedForwarderSchema);
var TokenErc20ContractSchema = {
  deploy: TokenErc20ContractDeploy,
  output: TokenErc20ContractOutput,
  input: TokenErc20ContractInput
};
var TokenErc721ContractInput = CommonContractSchema.merge(CommonRoyaltySchema).merge(CommonSymbolSchema);
var TokenErc721ContractOutput = CommonContractOutputSchema.merge(CommonRoyaltySchema).merge(CommonSymbolSchema);
var TokenErc721ContractDeploy = TokenErc721ContractInput.merge(CommonPlatformFeeSchema).merge(CommonPrimarySaleSchema).merge(CommonTrustedForwarderSchema);
var TokenErc721ContractSchema = {
  deploy: TokenErc721ContractDeploy,
  output: TokenErc721ContractOutput,
  input: TokenErc721ContractInput
};
var TokenErc1155ContractInput = CommonContractSchema.merge(CommonRoyaltySchema).merge(CommonSymbolSchema);
var TokenErc1155ContractOutput = CommonContractOutputSchema.merge(CommonRoyaltySchema).merge(CommonSymbolSchema);
var TokenErc1155ContractDeploy = TokenErc1155ContractInput.merge(CommonPlatformFeeSchema).merge(CommonPrimarySaleSchema).merge(CommonTrustedForwarderSchema);
var TokenErc1155ContractSchema = {
  deploy: TokenErc1155ContractDeploy,
  output: TokenErc1155ContractOutput,
  input: TokenErc1155ContractInput
};
var VoteSettingsInputSchema = mod.object({
  voting_delay_in_blocks: mod.number().min(0).default(0),
  voting_period_in_blocks: mod.number().min(1).default(1),
  voting_token_address: AddressSchema,
  voting_quorum_fraction: PercentSchema.default(0),
  proposal_token_threshold: BigNumberishSchema.default(1)
});
var VoteSettingsOuputSchema = VoteSettingsInputSchema.extend({
  proposal_token_threshold: BigNumberSchema2
});
var VoteContractInput = CommonContractSchema.merge(VoteSettingsInputSchema);
var VoteContractOutput = CommonContractOutputSchema.merge(VoteSettingsOuputSchema);
var VoteContractDeploy = VoteContractInput.merge(CommonTrustedForwarderSchema);
var VoteContractSchema = {
  deploy: VoteContractDeploy,
  output: VoteContractOutput,
  input: VoteContractInput
};
mod.object({
  proposalId: BigNumberSchema2,
  proposer: mod.string(),
  targets: mod.array(mod.string()),
  values: mod.array(BigNumberSchema2),
  signatures: mod.array(mod.string()),
  calldatas: mod.array(mod.string()),
  startBlock: BigNumberSchema2,
  endBlock: BigNumberSchema2,
  description: mod.string()
});
var SDKOptionsSchema = mod.object({
  readonlySettings: mod.object({
    rpcUrl: mod.string().url(),
    chainId: mod.number().optional()
  }).optional(),
  gasSettings: mod.object({
    maxPriceInGwei: mod.number().min(1, "gas price cannot be less than 1").default(300),
    speed: mod.enum(["standard", "fast", "fastest"]).default("fastest")
  }).default({
    maxPriceInGwei: 300,
    speed: "fastest"
  }),
  gasless: mod.union([mod.object({
    openzeppelin: mod.object({
      relayerUrl: mod.string().url(),
      relayerForwarderAddress: mod.string().optional(),
      useEOAForwarder: mod.boolean().default(false)
    }),
    experimentalChainlessSupport: mod.boolean().default(false)
  }), mod.object({
    biconomy: mod.object({
      apiId: mod.string(),
      apiKey: mod.string(),
      deadlineSeconds: mod.number().min(1, "deadlineSeconds cannot be les than 1").default(3600)
    })
  })]).optional()
}).default({
  gasSettings: {
    maxPriceInGwei: 300,
    speed: "fastest"
  }
});
var LoginOptionsSchema = mod.object({
  nonce: mod.string().optional(),
  expirationTime: mod.date().optional(),
  chainId: mod.number().optional()
}).optional();
var LoginPayloadDataSchema = mod.object({
  domain: mod.string(),
  address: AddressSchema,
  nonce: mod.string().default(v4_default()),
  expiration_time: mod.date().transform((d) => d.toISOString()),
  chain_id: mod.number().optional()
});
var LoginPayloadSchema = mod.object({
  payload: LoginPayloadDataSchema,
  signature: mod.string()
});
var VerifyOptionsSchema = mod.object({
  chainId: mod.number().optional()
}).optional();
var AuthenticationOptionsSchema = mod.object({
  invalidBefore: mod.date().optional(),
  expirationTime: mod.date().optional()
}).optional();
var AuthenticationPayloadDataSchema = mod.object({
  iss: mod.string(),
  sub: mod.string(),
  aud: mod.string(),
  exp: RawDateSchema2.transform((b) => b.toNumber()),
  nbf: RawDateSchema2.transform((b) => b.toNumber()),
  iat: RawDateSchema2.transform((b) => b.toNumber()),
  jti: mod.string().default(v4_default())
});
var AuthenticationPayloadSchema = mod.object({
  payload: AuthenticationPayloadDataSchema,
  signature: mod.string()
});
var ForwardRequest = [{
  name: "from",
  type: "address"
}, {
  name: "to",
  type: "address"
}, {
  name: "value",
  type: "uint256"
}, {
  name: "gas",
  type: "uint256"
}, {
  name: "nonce",
  type: "uint256"
}, {
  name: "data",
  type: "bytes"
}];
var ChainAwareForwardRequest = [{
  name: "from",
  type: "address"
}, {
  name: "to",
  type: "address"
}, {
  name: "value",
  type: "uint256"
}, {
  name: "gas",
  type: "uint256"
}, {
  name: "nonce",
  type: "uint256"
}, {
  name: "data",
  type: "bytes"
}, {
  name: "chainid",
  type: "uint256"
}];
var BiconomyForwarderAbi = [{
  inputs: [{
    internalType: "address",
    name: "from",
    type: "address"
  }, {
    internalType: "uint256",
    name: "batchId",
    type: "uint256"
  }],
  name: "getNonce",
  outputs: [{
    internalType: "uint256",
    name: "",
    type: "uint256"
  }],
  stateMutability: "view",
  type: "function"
}];
var _nonces = {};
var _noncesSyncTimestamp = {};
async function getAndIncrementNonce(forwarder, forwarderFunction, forwarderArgs) {
  const address = forwarderArgs.join("|");
  const timestamp = _noncesSyncTimestamp[address];
  const shouldSync = Date.now() - timestamp >= 2e3;
  if (!(address in _nonces) || shouldSync) {
    const nonceResult = await forwarder.functions[forwarderFunction](...forwarderArgs);
    if (Array.isArray(nonceResult) && nonceResult.length > 0) {
      _nonces[address] = BigNumber.from(nonceResult[0]);
    } else {
      _nonces[address] = BigNumber.from(nonceResult);
    }
    _noncesSyncTimestamp[address] = Date.now();
  }
  const nonce = _nonces[address];
  _nonces[address] = BigNumber.from(_nonces[address]).add(1);
  return nonce;
}
function getGasStationUrl(chainId) {
  switch (chainId) {
    case ChainId.Polygon:
      return "https://gasstation-mainnet.matic.network/v2";
    case ChainId.Mumbai:
      return "https://gasstation-mumbai.matic.today/v2";
  }
}
var MIN_POLYGON_GAS_PRICE = ethers_exports.utils.parseUnits("31", "gwei");
var MIN_MUMBAI_GAS_PRICE = ethers_exports.utils.parseUnits("1", "gwei");
function getDefaultGasFee(chainId) {
  switch (chainId) {
    case ChainId.Polygon:
      return MIN_POLYGON_GAS_PRICE;
    case ChainId.Mumbai:
      return MIN_MUMBAI_GAS_PRICE;
  }
}
async function getPolygonGasPriorityFee(chainId) {
  const gasStationUrl = getGasStationUrl(chainId);
  try {
    const data = await (await (0, import_cross_fetch2.default)(gasStationUrl)).json();
    const priorityFee = data["standard"]["maxPriorityFee"];
    if (priorityFee > 0) {
      const fixedFee = parseFloat(priorityFee).toFixed(9);
      return ethers_exports.utils.parseUnits(fixedFee, "gwei");
    }
  } catch (e) {
    console.error("failed to fetch gas", e);
  }
  return getDefaultGasFee(chainId);
}
async function signTypedDataInternal(signer, domain, types, message) {
  var _a, _b;
  const provider = signer == null ? void 0 : signer.provider;
  if (!provider) {
    throw new Error("missing provider");
  }
  const payload = ethers_exports.utils._TypedDataEncoder.getPayload(domain, types, message);
  let signature = "";
  if ((_a = provider == null ? void 0 : provider.provider) == null ? void 0 : _a.isWalletConnect) {
    signature = await provider.send("eth_signTypedData", [(await signer.getAddress()).toLowerCase(), JSON.stringify(payload)]);
  } else {
    try {
      signature = await signer._signTypedData(domain, types, message);
    } catch (err) {
      if ((_b = err == null ? void 0 : err.message) == null ? void 0 : _b.includes("Method eth_signTypedData_v4 not supported")) {
        signature = await provider.send("eth_signTypedData", [(await signer.getAddress()).toLowerCase(), JSON.stringify(payload)]);
      } else {
        throw err;
      }
    }
  }
  return {
    payload,
    signature: ethers_exports.utils.joinSignature(ethers_exports.utils.splitSignature(signature))
  };
}
var NAME_ABI = [{
  inputs: [],
  name: "name",
  outputs: [{
    internalType: "string",
    name: "",
    type: "string"
  }],
  stateMutability: "view",
  type: "function"
}];
var DOMAIN_SEPARATOR_ABI = [{
  constant: true,
  inputs: [],
  name: "DOMAIN_SEPARATOR",
  outputs: [{
    internalType: "bytes32",
    name: "",
    type: "bytes32"
  }],
  payable: false,
  stateMutability: "view",
  type: "function"
}, {
  inputs: [],
  name: "getDomainSeperator",
  outputs: [{
    internalType: "bytes32",
    name: "",
    type: "bytes32"
  }],
  stateMutability: "view",
  type: "function"
}];
var NONCES_ABI = [{
  inputs: [{
    internalType: "address",
    name: "owner",
    type: "address"
  }],
  name: "nonces",
  outputs: [{
    internalType: "uint256",
    name: "",
    type: "uint256"
  }],
  stateMutability: "view",
  type: "function"
}, {
  inputs: [{
    internalType: "address",
    name: "user",
    type: "address"
  }],
  name: "getNonce",
  outputs: [{
    internalType: "uint256",
    name: "nonce",
    type: "uint256"
  }],
  stateMutability: "view",
  type: "function"
}];
async function getSignerNonce(signer, contractAddress) {
  const contract = new Contract(contractAddress, NONCES_ABI, signer);
  try {
    return await contract.nonces(await signer.getAddress());
  } catch (err) {
    return await contract.getNonce(await signer.getAddress());
  }
}
async function getDomainSeperator(signer, contractAddress) {
  const contract = new Contract(contractAddress, DOMAIN_SEPARATOR_ABI, signer);
  try {
    return await contract.DOMAIN_SEPARATOR();
  } catch (err) {
    return await contract.getDomainSeperator();
  }
}
async function getTokenName(signer, contractAddress) {
  return new Contract(contractAddress, NAME_ABI, signer).name();
}
async function getChainDomainSeperator(signer, domain) {
  const contractDomainSeparator = await getDomainSeperator(signer, domain.verifyingContract);
  const polygonDomain = {
    name: domain.name,
    version: domain.version,
    verifyingContract: domain.verifyingContract,
    salt: ethers_exports.utils.hexZeroPad(BigNumber.from(domain.chainId).toHexString(), 32)
  };
  if (ethers_exports.utils._TypedDataEncoder.hashDomain(polygonDomain) === contractDomainSeparator) {
    return polygonDomain;
  }
  return domain;
}
async function signEIP2612Permit(signer, currencyAddress, owner, spender, value, deadline, nonce) {
  const domain = await getChainDomainSeperator(signer, {
    name: await getTokenName(signer, currencyAddress),
    version: "1",
    chainId: await signer.getChainId(),
    verifyingContract: currencyAddress
  });
  nonce = nonce || (await getSignerNonce(signer, currencyAddress)).toString();
  deadline = deadline || ethers_exports.constants.MaxUint256;
  const message = {
    owner,
    spender,
    value,
    nonce,
    deadline
  };
  const types = {
    Permit: [{
      name: "owner",
      type: "address"
    }, {
      name: "spender",
      type: "address"
    }, {
      name: "value",
      type: "uint256"
    }, {
      name: "nonce",
      type: "uint256"
    }, {
      name: "deadline",
      type: "uint256"
    }]
  };
  const {
    signature
  } = await signTypedDataInternal(signer, domain, types, message);
  return {
    message,
    signature
  };
}
var isBrowser3 = () => typeof window !== "undefined";
var isNode = () => !isBrowser3();
var RPCConnectionHandler = class extends eventemitter3_default {
  constructor(network, options) {
    super();
    _defineProperty(this, "provider", void 0);
    _defineProperty(this, "signer", void 0);
    _defineProperty(this, "options", void 0);
    const [signer, provider] = getSignerAndProvider(network, options);
    this.signer = signer;
    this.provider = provider;
    try {
      this.options = SDKOptionsSchema.parse(options);
    } catch (optionParseError) {
      console.error("invalid sdk options object passed, falling back to default options", optionParseError);
      this.options = SDKOptionsSchema.parse({});
    }
  }
  updateSignerOrProvider(network) {
    const [signer, provider] = getSignerAndProvider(network, this.options);
    this.signer = signer;
    this.provider = provider;
  }
  isReadOnly() {
    return !Signer.isSigner(this.signer);
  }
  getSigner() {
    return this.signer;
  }
  getProvider() {
    return this.provider;
  }
  getSignerOrProvider() {
    return this.getSigner() || this.getProvider();
  }
};
function getSignerAndProvider(network, options) {
  var _a;
  let signer;
  let provider;
  if (Signer.isSigner(network)) {
    signer = network;
    if (network.provider) {
      provider = network.provider;
    }
  }
  if (options == null ? void 0 : options.readonlySettings) {
    provider = getReadOnlyProvider(options.readonlySettings.rpcUrl, options.readonlySettings.chainId);
  }
  if (!provider) {
    if (lib_exports2.Provider.isProvider(network)) {
      provider = network;
    } else if (!Signer.isSigner(network)) {
      if (typeof network === "string") {
        provider = getReadOnlyProvider(network, (_a = options == null ? void 0 : options.readonlySettings) == null ? void 0 : _a.chainId);
      } else {
        provider = ethers_exports.getDefaultProvider(network);
      }
    }
  }
  if (!provider) {
    provider = ethers_exports.getDefaultProvider();
    console.error("No provider found, using default provider on default chain!");
  }
  return [signer, provider];
}
var ContractWrapper = class extends RPCConnectionHandler {
  constructor(network, contractAddress, contractAbi, options) {
    super(network, options);
    _defineProperty(this, "isValidContract", false);
    _defineProperty(this, "customOverrides", () => ({}));
    _defineProperty(this, "writeContract", void 0);
    _defineProperty(this, "readContract", void 0);
    _defineProperty(this, "abi", void 0);
    this.abi = contractAbi;
    this.writeContract = new Contract(contractAddress, contractAbi, this.getSignerOrProvider());
    this.readContract = this.writeContract.connect(this.getProvider());
  }
  updateSignerOrProvider(network) {
    super.updateSignerOrProvider(network);
    this.writeContract = this.writeContract.connect(this.getSignerOrProvider());
    this.readContract = this.writeContract.connect(this.getProvider());
  }
  async getChainID() {
    const provider = this.getProvider();
    const {
      chainId
    } = await provider.getNetwork();
    return chainId;
  }
  async getSignerAddress() {
    const signer = this.getSigner();
    if (!signer) {
      throw new Error("This action requires a connected wallet to sign the transaction. Please pass a valid signer to the SDK.");
    }
    return await signer.getAddress();
  }
  callStatic() {
    return this.writeContract.callStatic;
  }
  async getCallOverrides() {
    if (isBrowser3()) {
      return {};
    }
    const feeData = await this.getProvider().getFeeData();
    const supports1559 = feeData.maxFeePerGas && feeData.maxPriorityFeePerGas;
    if (supports1559) {
      const chainId = await this.getChainID();
      const block = await this.getProvider().getBlock("latest");
      const baseBlockFee = block && block.baseFeePerGas ? block.baseFeePerGas : ethers_exports.utils.parseUnits("1", "gwei");
      let defaultPriorityFee;
      if (chainId === ChainId.Mumbai || chainId === ChainId.Polygon) {
        defaultPriorityFee = await getPolygonGasPriorityFee(chainId);
      } else {
        defaultPriorityFee = BigNumber.from(feeData.maxPriorityFeePerGas);
      }
      const maxPriorityFeePerGas = this.getPreferredPriorityFee(defaultPriorityFee);
      const baseMaxFeePerGas = baseBlockFee.mul(2);
      const maxFeePerGas = baseMaxFeePerGas.add(maxPriorityFeePerGas);
      return {
        maxFeePerGas,
        maxPriorityFeePerGas
      };
    } else {
      return {
        gasPrice: await this.getPreferredGasPrice()
      };
    }
  }
  getPreferredPriorityFee(defaultPriorityFeePerGas) {
    const speed = this.options.gasSettings.speed;
    const maxGasPrice = this.options.gasSettings.maxPriceInGwei;
    let extraTip;
    switch (speed) {
      case "standard":
        extraTip = BigNumber.from(0);
        break;
      case "fast":
        extraTip = defaultPriorityFeePerGas.div(100).mul(5);
        break;
      case "fastest":
        extraTip = defaultPriorityFeePerGas.div(100).mul(10);
        break;
    }
    let txGasPrice = defaultPriorityFeePerGas.add(extraTip);
    const max = ethers_exports.utils.parseUnits(maxGasPrice.toString(), "gwei");
    const min = ethers_exports.utils.parseUnits("2.5", "gwei");
    if (txGasPrice.gt(max)) {
      txGasPrice = max;
    }
    if (txGasPrice.lt(min)) {
      txGasPrice = min;
    }
    return txGasPrice;
  }
  async getPreferredGasPrice() {
    const gasPrice = await this.getProvider().getGasPrice();
    const speed = this.options.gasSettings.speed;
    const maxGasPrice = this.options.gasSettings.maxPriceInGwei;
    let txGasPrice = gasPrice;
    let extraTip;
    switch (speed) {
      case "standard":
        extraTip = BigNumber.from(1);
        break;
      case "fast":
        extraTip = gasPrice.div(100).mul(5);
        break;
      case "fastest":
        extraTip = gasPrice.div(100).mul(10);
        break;
    }
    txGasPrice = txGasPrice.add(extraTip);
    const max = ethers_exports.utils.parseUnits(maxGasPrice.toString(), "gwei");
    if (txGasPrice.gt(max)) {
      txGasPrice = max;
    }
    return txGasPrice;
  }
  emitTransactionEvent(status, transactionHash) {
    this.emit(EventType.Transaction, {
      status,
      transactionHash
    });
  }
  async multiCall(encoded) {
    return this.sendTransaction("multicall", [encoded]);
  }
  async estimateGas(fn, args) {
    return this.writeContract.estimateGas[fn](...args);
  }
  withTransactionOverride(hook) {
    this.customOverrides = hook;
  }
  async call(functionName) {
    for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      args[_key - 1] = arguments[_key];
    }
    let txOptions;
    try {
      if (args.length > 0 && typeof args[args.length - 1] === "object") {
        const last = args[args.length - 1];
        txOptions = CallOverrideSchema.parse(last);
        args = args.slice(0, args.length - 1);
      }
    } catch (e) {
    }
    const functions = extractFunctionsFromAbi(AbiSchema.parse(this.abi)).filter((f3) => f3.name === functionName);
    if (!functions.length) {
      throw new Error(`Function "${functionName}" not found in contract. Check your dashboard for the list of functions available`);
    }
    const fn = functions.find((f3) => f3.name === functionName && f3.inputs.length === args.length);
    if (!fn) {
      throw new Error(`Function "${functionName}" requires ${functions[0].inputs.length} arguments, but ${args.length} were provided.
Expected function signature: ${functions[0].signature}`);
    }
    const ethersFnName = `${functionName}(${fn.inputs.map((i) => i.type).join()})`;
    const fnName = ethersFnName in this.readContract.functions ? ethersFnName : functionName;
    if (fn.stateMutability === "view" || fn.stateMutability === "pure") {
      return this.readContract[fnName](...args);
    } else {
      const receipt = await this.sendTransaction(fnName, args, txOptions);
      return {
        receipt
      };
    }
  }
  async sendTransaction(fn, args, callOverrides) {
    var _a;
    if (!callOverrides) {
      callOverrides = await this.getCallOverrides();
    }
    callOverrides = {
      ...callOverrides,
      ...this.customOverrides()
    };
    this.customOverrides = () => ({});
    if (((_a = this.options) == null ? void 0 : _a.gasless) && ("openzeppelin" in this.options.gasless || "biconomy" in this.options.gasless)) {
      if (fn === "multicall" && Array.isArray(args[0]) && args[0].length > 0) {
        const from = await this.getSignerAddress();
        args[0] = args[0].map((tx) => ethers_exports.utils.solidityPack(["bytes", "address"], [tx, from]));
      }
      const provider = this.getProvider();
      const txHash = await this.sendGaslessTransaction(fn, args, callOverrides);
      this.emitTransactionEvent("submitted", txHash);
      const receipt = await provider.waitForTransaction(txHash);
      this.emitTransactionEvent("completed", txHash);
      return receipt;
    } else {
      if (!this.isValidContract) {
        const code = await this.getProvider().getCode(this.readContract.address);
        this.isValidContract = code !== "0x";
        if (!this.isValidContract) {
          throw new Error("The address you're trying to send a transaction to is not a smart contract. Make sure you are on the correct network and the contract address is correct");
        }
      }
      const tx = await this.sendTransactionByFunction(fn, args, callOverrides);
      this.emitTransactionEvent("submitted", tx.hash);
      const receipt = tx.wait();
      this.emitTransactionEvent("completed", tx.hash);
      return receipt;
    }
  }
  async sendTransactionByFunction(fn, args, callOverrides) {
    const func = this.writeContract.functions[fn];
    if (!func) {
      throw new Error(`invalid function: "${fn.toString()}"`);
    }
    try {
      return await func(...args, callOverrides);
    } catch (e) {
      const network = await this.getProvider().getNetwork();
      const signerAddress = await this.getSignerAddress();
      const contractAddress = await this.readContract.address;
      throw await convertToTWError(e, network, signerAddress, contractAddress, this.readContract.interface);
    }
  }
  async sendGaslessTransaction(fn) {
    let args = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];
    let callOverrides = arguments.length > 2 ? arguments[2] : void 0;
    const signer = this.getSigner();
    invariant(signer, "Cannot execute gasless transaction without valid signer");
    const chainId = await this.getChainID();
    const from = await this.getSignerAddress();
    const to = this.writeContract.address;
    const value = (callOverrides == null ? void 0 : callOverrides.value) || 0;
    if (BigNumber.from(value).gt(0)) {
      throw new Error("Cannot send native token value with gasless transaction");
    }
    const data = this.writeContract.interface.encodeFunctionData(fn, args);
    let gas = BigNumber.from(0);
    try {
      const gasEstimate = await this.readContract.estimateGas[fn](...args);
      gas = gasEstimate.mul(2);
    } catch (e) {
    }
    if (gas.lt(1e5)) {
      gas = BigNumber.from(5e5);
    }
    if (callOverrides.gasLimit && BigNumber.from(callOverrides.gasLimit).gt(gas)) {
      gas = BigNumber.from(callOverrides.gasLimit);
    }
    const tx = {
      from,
      to,
      data,
      chainId,
      gasLimit: gas,
      functionName: fn.toString(),
      functionArgs: args,
      callOverrides
    };
    return await this.defaultGaslessSendFunction(tx);
  }
  async signTypedData(signer, domain, types, message) {
    this.emit(EventType.Signature, {
      status: "submitted",
      message,
      signature: ""
    });
    const {
      signature: sig
    } = await signTypedDataInternal(signer, domain, types, message);
    this.emit(EventType.Signature, {
      status: "completed",
      message,
      signature: sig
    });
    return sig;
  }
  parseLogs(eventName, logs) {
    if (!logs || logs.length === 0) {
      return [];
    }
    const topic = this.writeContract.interface.getEventTopic(eventName);
    const parsedLogs = logs.filter((x) => x.topics.indexOf(topic) >= 0);
    return parsedLogs.map((l) => this.writeContract.interface.parseLog(l));
  }
  async defaultGaslessSendFunction(transaction) {
    if (this.options.gasless && "biconomy" in this.options.gasless) {
      return this.biconomySendFunction(transaction);
    }
    return this.defenderSendFunction(transaction);
  }
  async biconomySendFunction(transaction) {
    var _a, _b;
    invariant(this.options.gasless && "biconomy" in this.options.gasless, "calling biconomySendFunction without biconomy");
    const signer = this.getSigner();
    const provider = this.getProvider();
    invariant(signer && provider, "signer and provider must be set");
    const forwarder = new ethers_exports.Contract(getContractAddressByChainId(transaction.chainId, "biconomyForwarder"), BiconomyForwarderAbi, provider);
    const batchId = 0;
    const batchNonce = await getAndIncrementNonce(forwarder, "getNonce", [transaction.from, batchId]);
    const request = {
      from: transaction.from,
      to: transaction.to,
      token: ethers_exports.constants.AddressZero,
      txGas: transaction.gasLimit.toNumber(),
      tokenGasPrice: "0",
      batchId,
      batchNonce: batchNonce.toNumber(),
      deadline: Math.floor(Date.now() / 1e3 + (((_a = this.options) == null ? void 0 : _a.gasless) && "biconomy" in this.options.gasless && ((_b = this.options.gasless.biconomy) == null ? void 0 : _b.deadlineSeconds) || 3600)),
      data: transaction.data
    };
    const hashToSign = ethers_exports.utils.arrayify(ethers_exports.utils.solidityKeccak256(["address", "address", "address", "uint256", "uint256", "uint256", "uint256", "uint256", "bytes32"], [request.from, request.to, request.token, request.txGas, request.tokenGasPrice, request.batchId, request.batchNonce, request.deadline, ethers_exports.utils.keccak256(request.data)]));
    this.emit(EventType.Signature, {
      status: "submitted",
      message: hashToSign,
      signature: ""
    });
    const signature = await signer.signMessage(hashToSign);
    this.emit(EventType.Signature, {
      status: "completed",
      message: hashToSign,
      signature
    });
    const response = await (0, import_cross_fetch2.default)("https://api.biconomy.io/api/v2/meta-tx/native", {
      method: "POST",
      body: JSON.stringify({
        from: transaction.from,
        apiId: this.options.gasless.biconomy.apiId,
        params: [request, signature],
        to: transaction.to,
        gasLimit: transaction.gasLimit.toHexString()
      }),
      headers: {
        "x-api-key": this.options.gasless.biconomy.apiKey,
        "Content-Type": "application/json;charset=utf-8"
      }
    });
    if (response.ok) {
      const resp = await response.json();
      if (!resp.txHash) {
        throw new Error(`relay transaction failed: ${resp.log}`);
      }
      return resp.txHash;
    }
    throw new Error(`relay transaction failed with status: ${response.status} (${response.statusText})`);
  }
  async defenderSendFunction(transaction) {
    invariant(this.options.gasless && "openzeppelin" in this.options.gasless, "calling openzeppelin gasless transaction without openzeppelin config in the SDK options");
    const signer = this.getSigner();
    const provider = this.getProvider();
    invariant(signer, "provider is not set");
    invariant(provider, "provider is not set");
    const forwarderAddress = this.options.gasless.openzeppelin.relayerForwarderAddress || (this.options.gasless.openzeppelin.useEOAForwarder ? CONTRACT_ADDRESSES[transaction.chainId].openzeppelinForwarderEOA : CONTRACT_ADDRESSES[transaction.chainId].openzeppelinForwarder);
    const forwarder = new Contract(forwarderAddress, Forwarder_default, provider);
    const nonce = await getAndIncrementNonce(forwarder, "getNonce", [transaction.from]);
    let domain;
    let types;
    let message;
    if (this.options.gasless.experimentalChainlessSupport) {
      domain = {
        name: "GSNv2 Forwarder",
        version: "0.0.1",
        verifyingContract: forwarderAddress
      };
      types = {
        ForwardRequest: ChainAwareForwardRequest
      };
      message = {
        from: transaction.from,
        to: transaction.to,
        value: BigNumber.from(0).toString(),
        gas: BigNumber.from(transaction.gasLimit).toString(),
        nonce: BigNumber.from(nonce).toString(),
        data: transaction.data,
        chainid: BigNumber.from(transaction.chainId).toString()
      };
    } else {
      domain = {
        name: "GSNv2 Forwarder",
        version: "0.0.1",
        chainId: transaction.chainId,
        verifyingContract: forwarderAddress
      };
      types = {
        ForwardRequest
      };
      message = {
        from: transaction.from,
        to: transaction.to,
        value: BigNumber.from(0).toString(),
        gas: BigNumber.from(transaction.gasLimit).toString(),
        nonce: BigNumber.from(nonce).toString(),
        data: transaction.data
      };
    }
    let signature;
    this.emit(EventType.Signature, {
      status: "submitted",
      message,
      signature: ""
    });
    if (transaction.functionName === "approve" && transaction.functionArgs.length === 2) {
      const spender = transaction.functionArgs[0];
      const amount = transaction.functionArgs[1];
      const {
        message: permit,
        signature: sig
      } = await signEIP2612Permit(signer, this.writeContract.address, transaction.from, spender, amount);
      const {
        r,
        s,
        v
      } = ethers_exports.utils.splitSignature(sig);
      message = {
        to: this.readContract.address,
        owner: permit.owner,
        spender: permit.spender,
        value: BigNumber.from(permit.value).toString(),
        nonce: BigNumber.from(permit.nonce).toString(),
        deadline: BigNumber.from(permit.deadline).toString(),
        r,
        s,
        v
      };
      signature = sig;
    } else {
      const {
        signature: sig
      } = await signTypedDataInternal(signer, domain, types, message);
      signature = sig;
    }
    let messageType = "forward";
    if (message == null ? void 0 : message.owner) {
      messageType = "permit";
    }
    const body = JSON.stringify({
      request: message,
      signature,
      forwarderAddress,
      type: messageType
    });
    this.emit(EventType.Signature, {
      status: "completed",
      message,
      signature
    });
    const response = await (0, import_cross_fetch2.default)(this.options.gasless.openzeppelin.relayerUrl, {
      method: "POST",
      body
    });
    if (response.ok) {
      const resp = await response.json();
      if (!resp.result) {
        throw new Error(`Relay transaction failed: ${resp.message}`);
      }
      const result = JSON.parse(resp.result);
      return result.txHash;
    }
    throw new Error(`relay transaction failed with status: ${response.status} (${response.statusText})`);
  }
};
function isNativeToken(tokenAddress) {
  return tokenAddress.toLowerCase() === NATIVE_TOKEN_ADDRESS || tokenAddress.toLowerCase() === lib_exports.AddressZero;
}
function cleanCurrencyAddress(currencyAddress) {
  if (isNativeToken(currencyAddress)) {
    return NATIVE_TOKEN_ADDRESS;
  }
  return currencyAddress;
}
async function normalizePriceValue(provider, inputPrice, currencyAddress) {
  const metadata = await fetchCurrencyMetadata(provider, currencyAddress);
  return utils_exports.parseUnits(AmountSchema.parse(inputPrice), metadata.decimals);
}
async function fetchCurrencyMetadata(provider, asset) {
  if (isNativeToken(asset)) {
    const network = await provider.getNetwork();
    const nativeToken = getNativeTokenByChainId(network.chainId);
    return {
      name: nativeToken.name,
      symbol: nativeToken.symbol,
      decimals: nativeToken.decimals
    };
  } else {
    const erc20 = new Contract(asset, IERC20Metadata_default, provider);
    const [name, symbol, decimals] = await Promise.all([erc20.name(), erc20.symbol(), erc20.decimals()]);
    return {
      name,
      symbol,
      decimals
    };
  }
}
async function fetchCurrencyValue(providerOrSigner, asset, price) {
  const metadata = await fetchCurrencyMetadata(providerOrSigner, asset);
  return {
    ...metadata,
    value: BigNumber.from(price),
    displayValue: utils_exports.formatUnits(price, metadata.decimals)
  };
}
async function setErc20Allowance(contractToApprove, value, currencyAddress, overrides) {
  if (isNativeToken(currencyAddress)) {
    overrides["value"] = value;
  } else {
    const signer = contractToApprove.getSigner();
    const provider = contractToApprove.getProvider();
    const erc20 = new ContractWrapper(signer || provider, currencyAddress, IERC20_default, contractToApprove.options);
    const owner = await contractToApprove.getSignerAddress();
    const spender = contractToApprove.readContract.address;
    const allowance = await erc20.readContract.allowance(owner, spender);
    if (allowance.lt(value)) {
      await erc20.sendTransaction("approve", [spender, value]);
    }
    return overrides;
  }
}
async function approveErc20Allowance(contractToApprove, currencyAddress, price, quantity, tokenDecimals) {
  const signer = contractToApprove.getSigner();
  const provider = contractToApprove.getProvider();
  const erc20 = new ContractWrapper(signer || provider, currencyAddress, IERC20_default, contractToApprove.options);
  const owner = await contractToApprove.getSignerAddress();
  const spender = contractToApprove.readContract.address;
  const allowance = await erc20.readContract.allowance(owner, spender);
  const totalPrice = BigNumber.from(price).mul(BigNumber.from(quantity)).div(ethers_exports.utils.parseUnits("1", tokenDecimals));
  if (allowance.lt(totalPrice)) {
    await erc20.sendTransaction("approve", [spender, allowance.add(totalPrice)]);
  }
}
async function hasERC20Allowance(contractToApprove, currencyAddress, value) {
  const provider = contractToApprove.getProvider();
  const erc20 = new ContractWrapper(provider, currencyAddress, IERC20_default, {});
  const owner = await contractToApprove.getSignerAddress();
  const spender = contractToApprove.readContract.address;
  const allowance = await erc20.readContract.allowance(owner, spender);
  return allowance.gte(value);
}
async function prepareClaim(addressToClaim, quantity, activeClaimCondition, merkleMetadataFetcher, tokenDecimals, contractWrapper, storage, checkERC20Allowance, snapshotFormatVersion) {
  let maxClaimable = convertQuantityToBigNumber(activeClaimCondition.maxClaimablePerWallet, tokenDecimals);
  let proofs = [utils_exports.hexZeroPad([0], 32)];
  let priceInProof = activeClaimCondition.price;
  let currencyAddressInProof = activeClaimCondition.currencyAddress;
  try {
    if (!activeClaimCondition.merkleRootHash.toString().startsWith(lib_exports.AddressZero)) {
      const snapshotEntry = await fetchSnapshotEntryForAddress(addressToClaim, activeClaimCondition.merkleRootHash.toString(), await merkleMetadataFetcher(), contractWrapper.getProvider(), storage, snapshotFormatVersion);
      if (snapshotEntry) {
        proofs = snapshotEntry.proof;
        maxClaimable = snapshotEntry.maxClaimable === "unlimited" ? ethers_exports.constants.MaxUint256 : ethers_exports.utils.parseUnits(snapshotEntry.maxClaimable, tokenDecimals);
        priceInProof = snapshotEntry.price === void 0 || snapshotEntry.price === "unlimited" ? ethers_exports.constants.MaxUint256 : await normalizePriceValue(contractWrapper.getProvider(), snapshotEntry.price, snapshotEntry.currencyAddress || ethers_exports.constants.AddressZero);
        currencyAddressInProof = snapshotEntry.currencyAddress || ethers_exports.constants.AddressZero;
      } else {
        if (snapshotFormatVersion === SnapshotFormatVersion.V1) {
          throw new Error("No claim found for this address");
        }
      }
    }
  } catch (e) {
    if ((e == null ? void 0 : e.message) === "No claim found for this address") {
      throw e;
    }
    console.warn("failed to check claim condition merkle root hash, continuing anyways", e);
  }
  const overrides = await contractWrapper.getCallOverrides() || {};
  const pricePerToken = priceInProof.toString() !== ethers_exports.constants.MaxUint256.toString() ? priceInProof : activeClaimCondition.price;
  const currencyAddress = currencyAddressInProof !== ethers_exports.constants.AddressZero ? currencyAddressInProof : activeClaimCondition.currencyAddress;
  if (pricePerToken.gt(0)) {
    if (isNativeToken(currencyAddress)) {
      overrides["value"] = BigNumber.from(pricePerToken).mul(quantity).div(ethers_exports.utils.parseUnits("1", tokenDecimals));
    } else if (checkERC20Allowance) {
      await approveErc20Allowance(contractWrapper, currencyAddress, pricePerToken, quantity, tokenDecimals);
    }
  }
  return {
    overrides,
    proofs,
    maxClaimable,
    price: pricePerToken,
    currencyAddress,
    priceInProof,
    currencyAddressInProof
  };
}
async function fetchSnapshot(merkleRoot, merkleMetadata, storage) {
  if (!merkleMetadata) {
    return null;
  }
  const snapshotUri = merkleMetadata[merkleRoot];
  if (snapshotUri) {
    const raw = await storage.downloadJSON(snapshotUri);
    if (raw.isShardedMerkleTree && raw.merkleRoot === merkleRoot) {
      const smt = await ShardedMerkleTree.fromUri(snapshotUri, storage);
      return (smt == null ? void 0 : smt.getAllEntries()) || null;
    } else {
      const snapshotData = SnapshotSchema.parse(raw);
      if (merkleRoot === snapshotData.merkleRoot) {
        return snapshotData.claims.map((claim) => ({
          address: claim.address,
          maxClaimable: claim.maxClaimable,
          price: claim.price,
          currencyAddress: claim.currencyAddress
        }));
      }
    }
  }
  return null;
}
async function fetchSnapshotEntryForAddress(address, merkleRoot, merkleMetadata, provider, storage, snapshotFormatVersion) {
  if (!merkleMetadata) {
    return null;
  }
  const snapshotUri = merkleMetadata[merkleRoot];
  if (snapshotUri) {
    const raw = await storage.downloadJSON(snapshotUri);
    if (raw.isShardedMerkleTree && raw.merkleRoot === merkleRoot) {
      const merkleTree = await ShardedMerkleTree.fromShardedMerkleTreeInfo(raw, storage);
      return await merkleTree.getProof(address, provider, snapshotFormatVersion);
    }
    const snapshotData = SnapshotSchema.parse(raw);
    if (merkleRoot === snapshotData.merkleRoot) {
      return snapshotData.claims.find((c) => c.address.toLowerCase() === address.toLowerCase()) || null;
    }
  }
  return null;
}
async function updateExistingClaimConditions(index, claimConditionInput, existingConditions) {
  if (index >= existingConditions.length) {
    throw Error(`Index out of bounds - got index: ${index} with ${existingConditions.length} conditions`);
  }
  const priceDecimals = existingConditions[index].currencyMetadata.decimals;
  const priceInWei = existingConditions[index].price;
  const priceInTokens = ethers_exports.utils.formatUnits(priceInWei, priceDecimals);
  const newConditionParsed = ClaimConditionInputSchema.parse({
    ...existingConditions[index],
    price: priceInTokens,
    ...claimConditionInput
  });
  const mergedConditionOutput = ClaimConditionOutputSchema.parse({
    ...newConditionParsed,
    price: priceInWei
  });
  return existingConditions.map((existingOutput, i) => {
    let newConditionAtIndex;
    if (i === index) {
      newConditionAtIndex = mergedConditionOutput;
    } else {
      newConditionAtIndex = existingOutput;
    }
    const formattedPrice = ethers_exports.utils.formatUnits(newConditionAtIndex.price, priceDecimals);
    return {
      ...newConditionAtIndex,
      price: formattedPrice
    };
  });
}
async function processSnapshotData(claimConditionInputs, tokenDecimals, provider, storage, snapshotFormatVersion) {
  const snapshotInfos = [];
  const inputsWithSnapshots = await Promise.all(claimConditionInputs.map(async (conditionInput) => {
    if (conditionInput.snapshot && conditionInput.snapshot.length > 0) {
      const snapshotInfo = await createSnapshot(conditionInput.snapshot, tokenDecimals, provider, storage, snapshotFormatVersion);
      snapshotInfos.push(snapshotInfo);
      conditionInput.merkleRootHash = snapshotInfo.merkleRoot;
    } else {
      conditionInput.merkleRootHash = utils_exports.hexZeroPad([0], 32);
    }
    return conditionInput;
  }));
  return {
    inputsWithSnapshots,
    snapshotInfos
  };
}
function compare(a, b) {
  const left = BigNumber.from(a);
  const right = BigNumber.from(b);
  if (left.eq(right)) {
    return 0;
  } else if (left.gt(right)) {
    return 1;
  } else {
    return -1;
  }
}
async function processClaimConditionInputs(claimConditionInputs, tokenDecimals, provider, storage, snapshotFormatVersion) {
  const {
    inputsWithSnapshots,
    snapshotInfos
  } = await processSnapshotData(claimConditionInputs, tokenDecimals, provider, storage, snapshotFormatVersion);
  const parsedInputs = ClaimConditionInputArray.parse(inputsWithSnapshots);
  const sortedConditions = (await Promise.all(parsedInputs.map((c) => convertToContractModel(c, tokenDecimals, provider, storage)))).sort((a, b) => {
    return compare(a.startTimestamp, b.startTimestamp);
  });
  return {
    snapshotInfos,
    sortedConditions
  };
}
async function convertToContractModel(c, tokenDecimals, provider, storage) {
  const currency = c.currencyAddress === lib_exports.AddressZero ? NATIVE_TOKEN_ADDRESS : c.currencyAddress;
  const maxClaimableSupply = convertQuantityToBigNumber(c.maxClaimableSupply, tokenDecimals);
  const maxClaimablePerWallet = convertQuantityToBigNumber(c.maxClaimablePerWallet, tokenDecimals);
  let metadataOrUri;
  if (c.metadata) {
    if (typeof c.metadata === "string") {
      metadataOrUri = c.metadata;
    } else {
      metadataOrUri = await storage.upload(c.metadata);
    }
  }
  return {
    startTimestamp: c.startTime,
    maxClaimableSupply,
    supplyClaimed: 0,
    maxClaimablePerWallet,
    pricePerToken: await normalizePriceValue(provider, c.price, currency),
    currency,
    merkleRoot: c.merkleRootHash.toString(),
    waitTimeInSecondsBetweenClaims: c.waitInSeconds || 0,
    metadata: metadataOrUri
  };
}
function abstractContractModelToLegacy(model) {
  return {
    startTimestamp: model.startTimestamp,
    maxClaimableSupply: model.maxClaimableSupply,
    supplyClaimed: model.supplyClaimed,
    merkleRoot: model.merkleRoot,
    pricePerToken: model.pricePerToken,
    currency: model.currency,
    quantityLimitPerTransaction: model.maxClaimablePerWallet,
    waitTimeInSecondsBetweenClaims: model.waitTimeInSecondsBetweenClaims || 0
  };
}
function abstractContractModelToNew(model) {
  return {
    startTimestamp: model.startTimestamp,
    maxClaimableSupply: model.maxClaimableSupply,
    supplyClaimed: model.supplyClaimed,
    merkleRoot: model.merkleRoot,
    pricePerToken: model.pricePerToken,
    currency: model.currency,
    quantityLimitPerWallet: model.maxClaimablePerWallet,
    metadata: model.metadata || ""
  };
}
function legacyContractModelToAbstract(model) {
  return {
    startTimestamp: model.startTimestamp,
    maxClaimableSupply: model.maxClaimableSupply,
    supplyClaimed: model.supplyClaimed,
    merkleRoot: model.merkleRoot.toString(),
    pricePerToken: model.pricePerToken,
    currency: model.currency,
    maxClaimablePerWallet: model.quantityLimitPerTransaction,
    waitTimeInSecondsBetweenClaims: model.waitTimeInSecondsBetweenClaims
  };
}
function newContractModelToAbstract(model) {
  return {
    startTimestamp: model.startTimestamp,
    maxClaimableSupply: model.maxClaimableSupply,
    supplyClaimed: model.supplyClaimed,
    merkleRoot: model.merkleRoot.toString(),
    pricePerToken: model.pricePerToken,
    currency: model.currency,
    maxClaimablePerWallet: model.quantityLimitPerWallet,
    waitTimeInSecondsBetweenClaims: 0,
    metadata: model.metadata
  };
}
async function transformResultToClaimCondition(pm, tokenDecimals, provider, merkleMetadata, storage, shouldDownloadSnapshot) {
  var _a;
  const cv = await fetchCurrencyValue(provider, pm.currency, pm.pricePerToken);
  const maxClaimableSupply = convertToReadableQuantity(pm.maxClaimableSupply, tokenDecimals);
  const maxClaimablePerWallet = convertToReadableQuantity(pm.maxClaimablePerWallet, tokenDecimals);
  const availableSupply = convertToReadableQuantity(BigNumber.from(pm.maxClaimableSupply).sub(pm.supplyClaimed), tokenDecimals);
  const currentMintSupply = convertToReadableQuantity(pm.supplyClaimed, tokenDecimals);
  let resolvedMetadata;
  if (pm.metadata) {
    resolvedMetadata = await storage.downloadJSON(pm.metadata);
  }
  return ClaimConditionOutputSchema.parse({
    startTime: pm.startTimestamp,
    maxClaimableSupply,
    maxClaimablePerWallet,
    currentMintSupply,
    availableSupply,
    waitInSeconds: (_a = pm.waitTimeInSecondsBetweenClaims) == null ? void 0 : _a.toString(),
    price: BigNumber.from(pm.pricePerToken),
    currency: pm.currency,
    currencyAddress: pm.currency,
    currencyMetadata: cv,
    merkleRootHash: pm.merkleRoot,
    snapshot: shouldDownloadSnapshot ? await fetchSnapshot(pm.merkleRoot, merkleMetadata, storage) : void 0,
    metadata: resolvedMetadata
  });
}
function convertToReadableQuantity(bn, tokenDecimals) {
  if (bn.toString() === ethers_exports.constants.MaxUint256.toString()) {
    return "unlimited";
  } else {
    return ethers_exports.utils.formatUnits(bn, tokenDecimals);
  }
}
function convertQuantityToBigNumber(quantity, tokenDecimals) {
  if (quantity === "unlimited") {
    return ethers_exports.constants.MaxUint256;
  } else {
    return ethers_exports.utils.parseUnits(quantity, tokenDecimals);
  }
}
async function calculateClaimCost(contractWrapper, pricePerToken, quantity, currencyAddress, checkERC20Allowance) {
  let overrides = {};
  const currency = currencyAddress || NATIVE_TOKEN_ADDRESS;
  const normalizedPrice = await normalizePriceValue(contractWrapper.getProvider(), pricePerToken, currency);
  const totalCost = normalizedPrice.mul(quantity);
  if (totalCost.gt(0)) {
    if (currency === NATIVE_TOKEN_ADDRESS) {
      overrides = {
        value: totalCost
      };
    } else if (currency !== NATIVE_TOKEN_ADDRESS && checkERC20Allowance) {
      await approveErc20Allowance(contractWrapper, currency, totalCost, quantity, 0);
    }
  }
  return overrides;
}
var SHARD_NYBBLES = 2;
var SnapshotFormatVersion;
(function(SnapshotFormatVersion2) {
  SnapshotFormatVersion2[SnapshotFormatVersion2["V1"] = 1] = "V1";
  SnapshotFormatVersion2[SnapshotFormatVersion2["V2"] = 2] = "V2";
})(SnapshotFormatVersion || (SnapshotFormatVersion = {}));
var ShardedMerkleTree = class {
  constructor(storage, baseUri, originalEntriesUri, shardNybbles, tokenDecimals) {
    _defineProperty(this, "shardNybbles", void 0);
    _defineProperty(this, "shards", void 0);
    _defineProperty(this, "trees", void 0);
    _defineProperty(this, "storage", void 0);
    _defineProperty(this, "baseUri", void 0);
    _defineProperty(this, "originalEntriesUri", void 0);
    _defineProperty(this, "tokenDecimals", void 0);
    this.storage = storage;
    this.shardNybbles = shardNybbles;
    this.baseUri = baseUri;
    this.originalEntriesUri = originalEntriesUri;
    this.tokenDecimals = tokenDecimals;
    this.shards = {};
    this.trees = {};
  }
  static async fromUri(uri, storage) {
    try {
      const shardedMerkleTreeInfo = await storage.downloadJSON(uri);
      if (shardedMerkleTreeInfo.isShardedMerkleTree) {
        return ShardedMerkleTree.fromShardedMerkleTreeInfo(shardedMerkleTreeInfo, storage);
      }
    } catch (e) {
      return void 0;
    }
  }
  static async fromShardedMerkleTreeInfo(info, storage) {
    return new ShardedMerkleTree(storage, info.baseUri, info.originalEntriesUri, info.shardNybbles, info.tokenDecimals);
  }
  static hashEntry(entry, tokenDecimals, currencyDecimals, snapshotFormatVersion) {
    switch (snapshotFormatVersion) {
      case SnapshotFormatVersion.V1:
        return utils_exports.solidityKeccak256(["address", "uint256"], [entry.address, convertQuantityToBigNumber(entry.maxClaimable, tokenDecimals)]);
      case SnapshotFormatVersion.V2:
        return utils_exports.solidityKeccak256(["address", "uint256", "uint256", "address"], [entry.address, convertQuantityToBigNumber(entry.maxClaimable, tokenDecimals), convertQuantityToBigNumber(entry.price || "unlimited", currencyDecimals), entry.currencyAddress || ethers_exports.constants.AddressZero]);
    }
  }
  static async fetchAndCacheDecimals(cache, provider, currencyAddress) {
    if (!currencyAddress) {
      return 18;
    }
    let currencyDecimals = cache[currencyAddress];
    if (currencyDecimals === void 0) {
      const currencyMetadata = await fetchCurrencyMetadata(provider, currencyAddress);
      currencyDecimals = currencyMetadata.decimals;
      cache[currencyAddress] = currencyDecimals;
    }
    return currencyDecimals;
  }
  static async buildAndUpload(snapshotInput, tokenDecimals, provider, storage, snapshotFormatVersion) {
    let shardNybbles = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : SHARD_NYBBLES;
    const inputs = SnapshotInputSchema.parse(snapshotInput);
    const shards = {};
    for (const snapshotEntry of inputs) {
      const shard = snapshotEntry.address.slice(2, 2 + shardNybbles).toLowerCase();
      if (shards[shard] === void 0) {
        shards[shard] = [];
      }
      shards[shard].push(snapshotEntry);
    }
    const currencyDecimalMap = {};
    const subTrees = await Promise.all(Object.entries(shards).map(async (_ref) => {
      let [shard, entries] = _ref;
      return [shard, new import_merkletreejs.MerkleTree(await Promise.all(entries.map(async (entry) => {
        const currencyDecimals = await ShardedMerkleTree.fetchAndCacheDecimals(currencyDecimalMap, provider, entry.currencyAddress);
        return ShardedMerkleTree.hashEntry(entry, tokenDecimals, currencyDecimals, snapshotFormatVersion);
      })), utils_exports.keccak256, {
        sort: true
      }).getHexRoot()];
    }));
    const roots = Object.fromEntries(subTrees);
    const tree = new import_merkletreejs.MerkleTree(Object.values(roots), utils_exports.keccak256, {
      sort: true
    });
    const shardsToUpload = [];
    for (const [shardId, entries] of Object.entries(shards)) {
      const data = {
        proofs: tree.getProof(roots[shardId]).map((value) => "0x" + value.data.toString("hex")),
        entries
      };
      shardsToUpload.push({
        data: JSON.stringify(data),
        name: `${shardId}.json`
      });
    }
    const uris = await storage.uploadBatch(shardsToUpload);
    const baseUri = uris[0].slice(0, uris[0].lastIndexOf("/"));
    const originalEntriesUri = await storage.upload(inputs);
    const shardedMerkleInfo = {
      merkleRoot: tree.getHexRoot(),
      baseUri,
      originalEntriesUri,
      shardNybbles,
      tokenDecimals,
      isShardedMerkleTree: true
    };
    const masterUri = await storage.upload(shardedMerkleInfo);
    return {
      shardedMerkleInfo,
      uri: masterUri
    };
  }
  async getProof(address, provider, snapshotFormatVersion) {
    const shardId = address.slice(2, 2 + this.shardNybbles).toLowerCase();
    let shard = this.shards[shardId];
    const currencyDecimalMap = {};
    if (shard === void 0) {
      try {
        shard = this.shards[shardId] = await this.storage.downloadJSON(`${this.baseUri}/${shardId}.json`);
        const hashedEntries = await Promise.all(shard.entries.map(async (entry2) => {
          const currencyDecimals2 = await ShardedMerkleTree.fetchAndCacheDecimals(currencyDecimalMap, provider, entry2.currencyAddress);
          return ShardedMerkleTree.hashEntry(entry2, this.tokenDecimals, currencyDecimals2, snapshotFormatVersion);
        }));
        this.trees[shardId] = new import_merkletreejs.MerkleTree(hashedEntries, utils_exports.keccak256, {
          sort: true
        });
      } catch (e) {
        console.warn("No merkle entry found for address", address);
        return null;
      }
    }
    const entry = shard.entries.find((i) => i.address.toLowerCase() === address.toLowerCase());
    if (!entry) {
      return null;
    }
    const currencyDecimals = await ShardedMerkleTree.fetchAndCacheDecimals(currencyDecimalMap, provider, entry.currencyAddress);
    const leaf = ShardedMerkleTree.hashEntry(entry, this.tokenDecimals, currencyDecimals, snapshotFormatVersion);
    const proof = this.trees[shardId].getProof(leaf).map((i) => "0x" + i.data.toString("hex"));
    return SnapshotEntryWithProofSchema.parse({
      ...entry,
      proof: proof.concat(shard.proofs)
    });
  }
  async getAllEntries() {
    try {
      return await this.storage.downloadJSON(this.originalEntriesUri);
    } catch (e) {
      console.warn("Could not fetch original snapshot entries", e);
      return [];
    }
  }
};
async function createSnapshot(snapshotInput, tokenDecimals, provider, storage, snapshotFormatVersion) {
  const input = SnapshotInputSchema.parse(snapshotInput);
  const addresses = input.map((i) => i.address);
  const hasDuplicates = new Set(addresses).size < addresses.length;
  if (hasDuplicates) {
    throw new DuplicateLeafsError();
  }
  const tree = await ShardedMerkleTree.buildAndUpload(input, tokenDecimals, provider, storage, snapshotFormatVersion);
  return {
    merkleRoot: tree.shardedMerkleInfo.merkleRoot,
    snapshotUri: tree.uri
  };
}
var roleMap = {
  admin: "",
  transfer: "TRANSFER_ROLE",
  minter: "MINTER_ROLE",
  pauser: "PAUSER_ROLE",
  lister: "LISTER_ROLE",
  asset: "ASSET_ROLE",
  unwrap: "UNWRAP_ROLE",
  factory: "FACTORY_ROLE"
};
var ALL_ROLES = Object.keys(roleMap);
function getRoleHash(role) {
  if (role === "admin") {
    return ethers_exports.utils.hexZeroPad([0], 32);
  }
  return ethers_exports.utils.id(roleMap[role]);
}
var FEATURE_TOKEN_CLAIM_CONDITIONS_V1 = {
  name: "ERC20ClaimConditionsV1",
  namespace: "token.drop.claim",
  docLinks: {
    sdk: "sdk.erc20dclaimable",
    contracts: "DropSinglePhase_V1"
  },
  abis: [IERC20_default, IDropSinglePhase_V1_default],
  features: {}
};
var FEATURE_TOKEN_CLAIM_CONDITIONS_V2 = {
  name: "ERC20ClaimConditionsV2",
  namespace: "token.drop.claim",
  docLinks: {
    sdk: "sdk.erc20dclaimable",
    contracts: "DropSinglePhase"
  },
  abis: [IERC20_default, IDropSinglePhase_default],
  features: {}
};
var FEATURE_TOKEN_CLAIM_PHASES_V2 = {
  name: "ERC20ClaimPhasesV2",
  namespace: "token.drop.claim",
  docLinks: {
    sdk: "sdk.erc20dclaimable",
    contracts: "Drop"
  },
  abis: [IERC20_default, IDrop_default],
  features: {}
};
var FEATURE_TOKEN_CLAIM_PHASES_V1 = {
  name: "ERC20ClaimPhasesV1",
  namespace: "token.drop.claim",
  docLinks: {
    sdk: "sdk.erc20dclaimable",
    contracts: "Drop"
  },
  abis: [DropERC20_V2_default],
  features: {}
};
var FEATURE_TOKEN_BURNABLE = {
  name: "ERC20Burnable",
  namespace: "token.burn",
  docLinks: {
    sdk: "sdk.erc20burnable",
    contracts: "IBurnableERC20"
  },
  abis: [IERC20_default, IBurnableERC20_default],
  features: {}
};
var FEATURE_TOKEN_SIGNATURE_MINTABLE = {
  name: "ERC20SignatureMintable",
  namespace: "token.signature",
  docLinks: {
    sdk: "sdk.erc20signaturemintable",
    contracts: "ISignatureMintERC20"
  },
  abis: [IERC20_default, ISignatureMintERC20_default],
  features: {}
};
var FEATURE_TOKEN_BATCH_MINTABLE = {
  name: "ERC20BatchMintable",
  namespace: "token.mint.batch",
  docLinks: {
    sdk: "sdk.erc20batchmintable",
    contracts: "IMulticall"
  },
  abis: [IERC20_default, IMintableERC20_default, IMulticall_default],
  features: {}
};
var FEATURE_TOKEN_MINTABLE = {
  name: "ERC20Mintable",
  namespace: "token.mint",
  docLinks: {
    sdk: "sdk.erc20mintable",
    contracts: "IMintableERC20"
  },
  abis: [IERC20_default, IMintableERC20_default],
  features: {
    [FEATURE_TOKEN_BATCH_MINTABLE.name]: FEATURE_TOKEN_BATCH_MINTABLE
  }
};
var FEATURE_TOKEN = {
  name: "ERC20",
  namespace: "token",
  docLinks: {
    sdk: "sdk.erc20",
    contracts: "IERC20"
  },
  abis: [IERC20_default],
  features: {
    [FEATURE_TOKEN_BURNABLE.name]: FEATURE_TOKEN_BURNABLE,
    [FEATURE_TOKEN_MINTABLE.name]: FEATURE_TOKEN_MINTABLE,
    [FEATURE_TOKEN_CLAIM_CONDITIONS_V1.name]: FEATURE_TOKEN_CLAIM_CONDITIONS_V1,
    [FEATURE_TOKEN_CLAIM_CONDITIONS_V2.name]: FEATURE_TOKEN_CLAIM_CONDITIONS_V2,
    [FEATURE_TOKEN_CLAIM_PHASES_V1.name]: FEATURE_TOKEN_CLAIM_PHASES_V1,
    [FEATURE_TOKEN_CLAIM_PHASES_V2.name]: FEATURE_TOKEN_CLAIM_PHASES_V2,
    [FEATURE_TOKEN_SIGNATURE_MINTABLE.name]: FEATURE_TOKEN_SIGNATURE_MINTABLE
  }
};
var FEATURE_NFT_BURNABLE = {
  name: "ERC721Burnable",
  namespace: "nft.burn",
  docLinks: {
    sdk: "sdk.erc721burnable",
    contracts: "IBurnableERC721"
  },
  abis: [IERC721_default, IBurnableERC721_default],
  features: {}
};
var FEATURE_NFT_REVEALABLE = {
  name: "ERC721Revealable",
  namespace: "nft.drop.revealer",
  docLinks: {
    sdk: "sdk.delayedreveal",
    contracts: "DelayedReveal"
  },
  abis: [IERC721_default, ILazyMint_default, IDelayedReveal_default],
  features: {}
};
var FEATURE_NFT_TIERED_DROP = {
  name: "ERC721TieredDrop",
  namespace: "nft.tieredDrop",
  docLinks: {
    sdk: "sdk.erc721tiereddrop",
    contracts: "TieredDrop"
  },
  abis: [IERC721_default, LazyMintWithTier_default],
  features: {}
};
var FEATURE_NFT_CLAIM_CONDITIONS_V1 = {
  name: "ERC721ClaimConditionsV1",
  namespace: "nft.drop.claim",
  docLinks: {
    sdk: "sdk.erc721claimable",
    contracts: "DropSinglePhase_V1"
  },
  abis: [IERC721_default, ILazyMint_default, IDropSinglePhase_V1_default],
  features: {}
};
var FEATURE_NFT_CLAIM_CONDITIONS_V2 = {
  name: "ERC721ClaimConditionsV2",
  namespace: "nft.drop.claim",
  docLinks: {
    sdk: "sdk.erc721claimable",
    contracts: "DropSinglePhase"
  },
  abis: [IERC721_default, ILazyMint_default, IDropSinglePhase_default],
  features: {}
};
var FEATURE_NFT_CLAIM_PHASES_V1 = {
  name: "ERC721ClaimPhasesV1",
  namespace: "nft.drop.claim",
  docLinks: {
    sdk: "sdk.erc721claimable",
    contracts: "Drop"
  },
  abis: [DropERC721_V3_default],
  features: {}
};
var FEATURE_NFT_CLAIM_PHASES_V2 = {
  name: "ERC721ClaimPhasesV2",
  namespace: "nft.drop.claim",
  docLinks: {
    sdk: "sdk.erc721claimable",
    contracts: "Drop"
  },
  abis: [IERC721_default, ILazyMint_default, IDrop_default],
  features: {}
};
var FEATURE_NFT_CLAIM_CUSTOM = {
  name: "ERC721ClaimCustom",
  namespace: "nft.drop.claim",
  docLinks: {
    sdk: "sdk.erc721claimable",
    contracts: "IClaimableERC721"
  },
  abis: [IERC721_default, ILazyMint_default, IClaimableERC721_default],
  features: {}
};
var FEATURE_NFT_LAZY_MINTABLE = {
  name: "ERC721LazyMintable",
  namespace: "nft.drop",
  docLinks: {
    sdk: "sdk.erc721lazymintable",
    contracts: "LazyMint"
  },
  abis: [IERC721_default, ILazyMint_default],
  features: {
    [FEATURE_NFT_REVEALABLE.name]: FEATURE_NFT_REVEALABLE,
    [FEATURE_NFT_CLAIM_CUSTOM.name]: FEATURE_NFT_CLAIM_CUSTOM,
    [FEATURE_NFT_CLAIM_CONDITIONS_V1.name]: FEATURE_NFT_CLAIM_CONDITIONS_V1,
    [FEATURE_NFT_CLAIM_CONDITIONS_V2.name]: FEATURE_NFT_CLAIM_CONDITIONS_V2,
    [FEATURE_NFT_CLAIM_PHASES_V1.name]: FEATURE_NFT_CLAIM_PHASES_V1,
    [FEATURE_NFT_CLAIM_PHASES_V2.name]: FEATURE_NFT_CLAIM_PHASES_V2
  }
};
var FEATURE_NFT_BATCH_MINTABLE = {
  name: "ERC721BatchMintable",
  namespace: "nft.mint.batch",
  docLinks: {
    sdk: "sdk.erc721batchmintable",
    contracts: "IMulticall"
  },
  abis: [IERC721_default, IMintableERC721_default, IMulticall_default],
  features: {}
};
var FEATURE_NFT_MINTABLE = {
  name: "ERC721Mintable",
  namespace: "nft.mint",
  docLinks: {
    sdk: "sdk.erc721mintable",
    contracts: "IMintableERC721"
  },
  abis: [IERC721_default, IMintableERC721_default],
  features: {
    [FEATURE_NFT_BATCH_MINTABLE.name]: FEATURE_NFT_BATCH_MINTABLE
  }
};
var FEATURE_NFT_SIGNATURE_MINTABLE_V2 = {
  name: "ERC721SignatureMintV2",
  namespace: "nft.signature",
  docLinks: {
    sdk: "sdk.erc721signaturemint",
    contracts: "ISignatureMintERC721"
  },
  abis: [IERC721_default, ISignatureMintERC721_default],
  features: {}
};
var FEATURE_NFT_SIGNATURE_MINTABLE_V1 = {
  name: "ERC721SignatureMintV1",
  namespace: "nft.signature",
  docLinks: {
    sdk: "sdk.erc721signaturemint",
    contracts: "ISignatureMintERC721"
  },
  abis: [ISignatureMintERC721_V1_default],
  features: {}
};
var FEATURE_NFT_ENUMERABLE = {
  name: "ERC721Enumerable",
  namespace: "nft.query.owned",
  docLinks: {
    sdk: "sdk.erc721enumerable",
    contracts: "IERC721Enumerable"
  },
  abis: [IERC721_default, IERC721Enumerable_default],
  features: {}
};
var FEATURE_NFT_SUPPLY = {
  name: "ERC721Supply",
  namespace: "nft.query",
  docLinks: {
    sdk: "sdk.erc721supply",
    contracts: "IERC721Supply"
  },
  abis: [IERC721_default, IERC721Supply_default],
  features: {
    [FEATURE_NFT_ENUMERABLE.name]: FEATURE_NFT_ENUMERABLE
  }
};
var FEATURE_NFT = {
  name: "ERC721",
  namespace: "nft",
  docLinks: {
    sdk: "sdk.erc721",
    contracts: "IERC721"
  },
  abis: [IERC721_default],
  features: {
    [FEATURE_NFT_BURNABLE.name]: FEATURE_NFT_BURNABLE,
    [FEATURE_NFT_SUPPLY.name]: FEATURE_NFT_SUPPLY,
    [FEATURE_NFT_MINTABLE.name]: FEATURE_NFT_MINTABLE,
    [FEATURE_NFT_LAZY_MINTABLE.name]: FEATURE_NFT_LAZY_MINTABLE,
    [FEATURE_NFT_SIGNATURE_MINTABLE_V1.name]: FEATURE_NFT_SIGNATURE_MINTABLE_V1,
    [FEATURE_NFT_SIGNATURE_MINTABLE_V2.name]: FEATURE_NFT_SIGNATURE_MINTABLE_V2,
    [FEATURE_NFT_TIERED_DROP.name]: FEATURE_NFT_TIERED_DROP
  }
};
var FEATURE_EDITION_BURNABLE = {
  name: "ERC1155Burnable",
  namespace: "edition.burn",
  docLinks: {
    sdk: "sdk.erc1155burnable",
    contracts: "IBurnableERC1155"
  },
  abis: [IERC1155_default, IBurnableERC1155_default],
  features: {}
};
var FEATURE_EDITION_CLAIM_CONDITIONS_V1 = {
  name: "ERC1155ClaimConditionsV1",
  namespace: "edition.drop.claim",
  docLinks: {
    sdk: "sdk.erc1155claimable",
    contracts: "DropSinglePhase1155"
  },
  abis: [IERC1155_default, ILazyMint_default, IDropSinglePhase1155_V1_default],
  features: {}
};
var FEATURE_EDITION_CLAIM_CONDITIONS_V2 = {
  name: "ERC1155ClaimConditionsV2",
  namespace: "edition.drop.claim",
  docLinks: {
    sdk: "sdk.erc1155claimable",
    contracts: "DropSinglePhase1155"
  },
  abis: [IERC1155_default, ILazyMint_default, IDropSinglePhase1155_default],
  features: {}
};
var FEATURE_EDITION_CLAIM_PHASES_V2 = {
  name: "ERC1155ClaimPhasesV2",
  namespace: "edition.drop.claim",
  docLinks: {
    sdk: "sdk.erc1155claimable",
    contracts: "Drop1155"
  },
  abis: [IERC1155_default, ILazyMint_default, IDrop1155_default],
  features: {}
};
var FEATURE_EDITION_CLAIM_PHASES_V1 = {
  name: "ERC1155ClaimPhasesV1",
  namespace: "edition.drop.claim",
  docLinks: {
    sdk: "sdk.erc1155claimable",
    contracts: "Drop1155"
  },
  abis: [DropERC1155_V2_default],
  features: {}
};
var FEATURE_EDITION_CLAIM_CUSTOM = {
  name: "ERC1155ClaimCustom",
  namespace: "edition.drop.claim",
  docLinks: {
    sdk: "sdk.erc1155claimable",
    contracts: "IClaimableERC1155"
  },
  abis: [IERC1155_default, ILazyMint_default, IClaimableERC1155_default],
  features: {}
};
var FEATURE_EDITION_REVEALABLE = {
  name: "ERC1155Revealable",
  namespace: "edition.drop.revealer",
  docLinks: {
    sdk: "sdk.drop.delayedreveal",
    contracts: "DelayedReveal"
  },
  abis: [IERC1155_default, ILazyMint_default, IDelayedReveal_default],
  features: {}
};
var FEATURE_EDITION_LAZY_MINTABLE_V2 = {
  name: "ERC1155LazyMintableV2",
  namespace: "edition.drop",
  docLinks: {
    sdk: "sdk.erc1155droppable",
    contracts: "LazyMint"
  },
  abis: [IERC1155_default, ILazyMint_default],
  features: {
    [FEATURE_EDITION_REVEALABLE.name]: FEATURE_EDITION_REVEALABLE,
    [FEATURE_EDITION_CLAIM_CUSTOM.name]: FEATURE_EDITION_CLAIM_CUSTOM,
    [FEATURE_EDITION_CLAIM_CONDITIONS_V1.name]: FEATURE_EDITION_CLAIM_CONDITIONS_V1,
    [FEATURE_EDITION_CLAIM_CONDITIONS_V2.name]: FEATURE_EDITION_CLAIM_CONDITIONS_V2,
    [FEATURE_EDITION_CLAIM_PHASES_V2.name]: FEATURE_EDITION_CLAIM_PHASES_V2
  }
};
var FEATURE_EDITION_LAZY_MINTABLE_V1 = {
  name: "ERC1155LazyMintableV1",
  namespace: "edition.drop",
  docLinks: {
    sdk: "sdk.erc1155droppable",
    contracts: "LazyMint"
  },
  abis: [DropERC1155_V2_default],
  features: {
    [FEATURE_EDITION_CLAIM_PHASES_V1.name]: FEATURE_EDITION_CLAIM_PHASES_V1
  }
};
var FEATURE_EDITION_SIGNATURE_MINTABLE = {
  name: "ERC1155SignatureMintable",
  namespace: "edition.signature",
  docLinks: {
    sdk: "sdk.erc1155signaturemintable",
    contracts: "ISignatureMintERC1155"
  },
  abis: [IERC1155_default, ISignatureMintERC1155_default],
  features: {}
};
var FEATURE_EDITION_BATCH_MINTABLE = {
  name: "ERC1155BatchMintable",
  namespace: "edition.mint.batch",
  docLinks: {
    sdk: "sdk.erc1155batchmintable",
    contracts: "IMulticall"
  },
  abis: [IERC1155_default, IMintableERC1155_default, IMulticall_default],
  features: {}
};
var FEATURE_EDITION_MINTABLE = {
  name: "ERC1155Mintable",
  namespace: "edition.mint",
  docLinks: {
    sdk: "sdk.erc1155mintable",
    contracts: "IMintableERC1155"
  },
  abis: [IERC1155_default, IMintableERC1155_default],
  features: {
    [FEATURE_EDITION_BATCH_MINTABLE.name]: FEATURE_EDITION_BATCH_MINTABLE
  }
};
var FEATURE_EDITION_ENUMERABLE = {
  name: "ERC1155Enumerable",
  namespace: "edition.query",
  docLinks: {
    sdk: "sdk.erc1155",
    contracts: "IERC1155"
  },
  abis: [IERC1155_default, IERC1155Enumerable_default],
  features: {}
};
var FEATURE_EDITION = {
  name: "ERC1155",
  namespace: "edition",
  docLinks: {
    sdk: "sdk.erc1155enumerable",
    contracts: "IERC1155Enumerable"
  },
  abis: [IERC1155_default],
  features: {
    [FEATURE_EDITION_BURNABLE.name]: FEATURE_EDITION_BURNABLE,
    [FEATURE_EDITION_ENUMERABLE.name]: FEATURE_EDITION_ENUMERABLE,
    [FEATURE_EDITION_MINTABLE.name]: FEATURE_EDITION_MINTABLE,
    [FEATURE_EDITION_LAZY_MINTABLE_V1.name]: FEATURE_EDITION_LAZY_MINTABLE_V1,
    [FEATURE_EDITION_LAZY_MINTABLE_V2.name]: FEATURE_EDITION_LAZY_MINTABLE_V2,
    [FEATURE_EDITION_REVEALABLE.name]: FEATURE_EDITION_REVEALABLE,
    [FEATURE_EDITION_SIGNATURE_MINTABLE.name]: FEATURE_EDITION_SIGNATURE_MINTABLE
  }
};
var FEATURE_ROYALTY = {
  name: "Royalty",
  namespace: "royalty",
  docLinks: {
    sdk: "sdk.contractroyalty",
    contracts: "Royalty"
  },
  abis: [IRoyalty_default],
  features: {}
};
var FEATURE_PRIMARY_SALE = {
  name: "PrimarySale",
  namespace: "sales",
  docLinks: {
    sdk: "sdk.contractprimarysale",
    contracts: "PrimarySale"
  },
  abis: [IPrimarySale_default],
  features: {}
};
var FEATURE_PLATFORM_FEE = {
  name: "PlatformFee",
  namespace: "platformFee",
  docLinks: {
    sdk: "sdk.platformfee",
    contracts: "PlatformFee"
  },
  abis: [IPlatformFee_default],
  features: {}
};
var FEATURE_PERMISSIONS_ENUMERABLE = {
  name: "PermissionsEnumerable",
  namespace: "roles",
  docLinks: {
    sdk: "sdk.contractroles",
    contracts: "PermissionsEnumerable"
  },
  abis: [IPermissionsEnumerable_default],
  features: {}
};
var FEATURE_PERMISSIONS = {
  name: "Permissions",
  namespace: "roles",
  docLinks: {
    sdk: "sdk.contractroles",
    contracts: "Permissions"
  },
  abis: [IPermissions_default],
  features: {
    [FEATURE_PERMISSIONS_ENUMERABLE.name]: FEATURE_PERMISSIONS_ENUMERABLE
  }
};
var FEATURE_METADATA = {
  name: "ContractMetadata",
  namespace: "metadata",
  docLinks: {
    sdk: "sdk.contractmetadata",
    contracts: "ContractMetadata"
  },
  abis: [IContractMetadata_default],
  features: {}
};
var FEATURE_APPURI = {
  name: "AppURI",
  namespace: "appURI",
  docLinks: {
    sdk: "sdk.appURI",
    contracts: "AppURI"
  },
  abis: [IAppURI_default],
  features: {}
};
var FEATURE_OWNER = {
  name: "Ownable",
  namespace: "owner",
  docLinks: {
    sdk: "sdk.owner",
    contracts: "Ownable"
  },
  abis: [Ownable_default],
  features: {}
};
var FEATURE_GASLESS = {
  name: "Gasless",
  namespace: "gasless",
  docLinks: {
    sdk: "sdk.gaslesstransaction",
    contracts: ""
  },
  abis: [ERC2771Context_default],
  features: {}
};
var SUPPORTED_FEATURES = {
  [FEATURE_TOKEN.name]: FEATURE_TOKEN,
  [FEATURE_NFT.name]: FEATURE_NFT,
  [FEATURE_EDITION.name]: FEATURE_EDITION,
  [FEATURE_ROYALTY.name]: FEATURE_ROYALTY,
  [FEATURE_PLATFORM_FEE.name]: FEATURE_PLATFORM_FEE,
  [FEATURE_PRIMARY_SALE.name]: FEATURE_PRIMARY_SALE,
  [FEATURE_PERMISSIONS.name]: FEATURE_PERMISSIONS,
  [FEATURE_METADATA.name]: FEATURE_METADATA,
  [FEATURE_APPURI.name]: FEATURE_APPURI,
  [FEATURE_OWNER.name]: FEATURE_OWNER,
  [FEATURE_GASLESS.name]: FEATURE_GASLESS
};
var decoder;
try {
  decoder = new TextDecoder();
} catch (error) {
}
var src;
var srcEnd;
var position = 0;
var LEGACY_RECORD_INLINE_ID = 105;
var RECORD_DEFINITIONS_ID = 57342;
var RECORD_INLINE_ID = 57343;
var BUNDLED_STRINGS_ID = 57337;
var PACKED_REFERENCE_TAG_ID = 6;
var STOP_CODE = {};
var currentDecoder = {};
var currentStructures;
var srcString;
var srcStringStart = 0;
var srcStringEnd = 0;
var bundledStrings;
var referenceMap;
var currentExtensions = [];
var currentExtensionRanges = [];
var packedValues;
var dataView;
var restoreMapsAsObject;
var defaultOptions = {
  useRecords: false,
  mapsAsObjects: true
};
var sequentialMode = false;
var Decoder = class {
  constructor(options) {
    if (options) {
      if ((options.keyMap || options._keyMap) && !options.useRecords) {
        options.useRecords = false;
        options.mapsAsObjects = true;
      }
      if (options.useRecords === false && options.mapsAsObjects === void 0) {
        options.mapsAsObjects = true;
      }
      if (options.getStructures) {
        options.getShared = options.getStructures;
      }
      if (options.getShared && !options.structures) {
        (options.structures = []).uninitialized = true;
      }
      if (options.keyMap) {
        this.mapKey = /* @__PURE__ */ new Map();
        for (let [k, v] of Object.entries(options.keyMap)) {
          this.mapKey.set(v, k);
        }
      }
    }
    Object.assign(this, options);
  }
  decodeKey(key) {
    return this.keyMap ? this.mapKey.get(key) || key : key;
  }
  decode(source, end) {
    if (src) {
      return saveState(() => {
        clearSource();
        return this ? this.decode(source, end) : Decoder.prototype.decode.call(defaultOptions, source, end);
      });
    }
    srcEnd = end > -1 ? end : source.length;
    position = 0;
    srcStringEnd = 0;
    srcString = null;
    bundledStrings = null;
    src = source;
    try {
      dataView = source.dataView || (source.dataView = new DataView(source.buffer, source.byteOffset, source.byteLength));
    } catch (error) {
      src = null;
      if (source instanceof Uint8Array) {
        throw error;
      }
      throw new Error("Source must be a Uint8Array or Buffer but was a " + (source && typeof source === "object" ? source.constructor.name : typeof source));
    }
    if (this instanceof Decoder) {
      currentDecoder = this;
      packedValues = this.sharedValues && (this.pack ? new Array(this.maxPrivatePackedValues || 16).concat(this.sharedValues) : this.sharedValues);
      if (this.structures) {
        currentStructures = this.structures;
        return checkedRead();
      } else if (!currentStructures || currentStructures.length > 0) {
        currentStructures = [];
      }
    } else {
      currentDecoder = defaultOptions;
      if (!currentStructures || currentStructures.length > 0) {
        currentStructures = [];
      }
      packedValues = null;
    }
    return checkedRead();
  }
};
function checkedRead() {
  try {
    let result = read();
    if (bundledStrings) {
      if (position >= bundledStrings.postBundlePosition) {
        let error = new Error("Unexpected bundle position");
        error.incomplete = true;
        throw error;
      }
      position = bundledStrings.postBundlePosition;
      bundledStrings = null;
    }
    if (position == srcEnd) {
      currentStructures = null;
      src = null;
      if (referenceMap) {
        referenceMap = null;
      }
    } else if (position > srcEnd) {
      let error = new Error("Unexpected end of CBOR data");
      error.incomplete = true;
      throw error;
    } else if (!sequentialMode) {
      throw new Error("Data read, but end of buffer not reached");
    }
    return result;
  } catch (error) {
    clearSource();
    if (error instanceof RangeError || error.message.startsWith("Unexpected end of buffer")) {
      error.incomplete = true;
    }
    throw error;
  }
}
function read() {
  let token = src[position++];
  let majorType = token >> 5;
  token = token & 31;
  if (token > 23) {
    switch (token) {
      case 24:
        token = src[position++];
        break;
      case 25:
        if (majorType == 7) {
          return getFloat16();
        }
        token = dataView.getUint16(position);
        position += 2;
        break;
      case 26:
        if (majorType == 7) {
          let value = dataView.getFloat32(position);
          if (currentDecoder.useFloat32 > 2) {
            let multiplier = mult10[(src[position] & 127) << 1 | src[position + 1] >> 7];
            position += 4;
            return (multiplier * value + (value > 0 ? 0.5 : -0.5) >> 0) / multiplier;
          }
          position += 4;
          return value;
        }
        token = dataView.getUint32(position);
        position += 4;
        break;
      case 27:
        if (majorType == 7) {
          let value = dataView.getFloat64(position);
          position += 8;
          return value;
        }
        if (majorType > 1) {
          if (dataView.getUint32(position) > 0) {
            throw new Error("JavaScript does not support arrays, maps, or strings with length over 4294967295");
          }
          token = dataView.getUint32(position + 4);
        } else if (currentDecoder.int64AsNumber) {
          token = dataView.getUint32(position) * 4294967296;
          token += dataView.getUint32(position + 4);
        } else {
          token = dataView.getBigUint64(position);
        }
        position += 8;
        break;
      case 31:
        switch (majorType) {
          case 2:
          case 3:
            throw new Error("Indefinite length not supported for byte or text strings");
          case 4:
            let array = [];
            let value, i = 0;
            while ((value = read()) != STOP_CODE) {
              array[i++] = value;
            }
            return majorType == 4 ? array : majorType == 3 ? array.join("") : Buffer.concat(array);
          case 5:
            let key;
            if (currentDecoder.mapsAsObjects) {
              let object = {};
              if (currentDecoder.keyMap) {
                while ((key = read()) != STOP_CODE) {
                  object[safeKey(currentDecoder.decodeKey(key))] = read();
                }
              } else {
                while ((key = read()) != STOP_CODE) {
                  object[safeKey(key)] = read();
                }
              }
              return object;
            } else {
              if (restoreMapsAsObject) {
                currentDecoder.mapsAsObjects = true;
                restoreMapsAsObject = false;
              }
              let map = /* @__PURE__ */ new Map();
              if (currentDecoder.keyMap) {
                while ((key = read()) != STOP_CODE) {
                  map.set(currentDecoder.decodeKey(key), read());
                }
              } else {
                while ((key = read()) != STOP_CODE) {
                  map.set(key, read());
                }
              }
              return map;
            }
          case 7:
            return STOP_CODE;
          default:
            throw new Error("Invalid major type for indefinite length " + majorType);
        }
      default:
        throw new Error("Unknown token " + token);
    }
  }
  switch (majorType) {
    case 0:
      return token;
    case 1:
      return ~token;
    case 2:
      return readBin(token);
    case 3:
      if (srcStringEnd >= position) {
        return srcString.slice(position - srcStringStart, (position += token) - srcStringStart);
      }
      if (srcStringEnd == 0 && srcEnd < 140 && token < 32) {
        let string = token < 16 ? shortStringInJS(token) : longStringInJS(token);
        if (string != null) {
          return string;
        }
      }
      return readFixedString(token);
    case 4:
      let array = new Array(token);
      for (let i = 0; i < token; i++) {
        array[i] = read();
      }
      return array;
    case 5:
      if (currentDecoder.mapsAsObjects) {
        let object = {};
        if (currentDecoder.keyMap) {
          for (let i = 0; i < token; i++) {
            object[safeKey(currentDecoder.decodeKey(read()))] = read();
          }
        } else {
          for (let i = 0; i < token; i++) {
            object[safeKey(read())] = read();
          }
        }
        return object;
      } else {
        if (restoreMapsAsObject) {
          currentDecoder.mapsAsObjects = true;
          restoreMapsAsObject = false;
        }
        let map = /* @__PURE__ */ new Map();
        if (currentDecoder.keyMap) {
          for (let i = 0; i < token; i++) {
            map.set(currentDecoder.decodeKey(read()), read());
          }
        } else {
          for (let i = 0; i < token; i++) {
            map.set(read(), read());
          }
        }
        return map;
      }
    case 6:
      if (token >= BUNDLED_STRINGS_ID) {
        let structure = currentStructures[token & 8191];
        if (structure) {
          if (!structure.read) {
            structure.read = createStructureReader(structure);
          }
          return structure.read();
        }
        if (token < 65536) {
          if (token == RECORD_INLINE_ID) {
            return recordDefinition(read());
          } else if (token == RECORD_DEFINITIONS_ID) {
            let length = readJustLength();
            let id = read();
            for (let i = 2; i < length; i++) {
              recordDefinition([id++, read()]);
            }
            return read();
          } else if (token == BUNDLED_STRINGS_ID) {
            return readBundleExt();
          }
          if (currentDecoder.getShared) {
            loadShared();
            structure = currentStructures[token & 8191];
            if (structure) {
              if (!structure.read) {
                structure.read = createStructureReader(structure);
              }
              return structure.read();
            }
          }
        }
      }
      let extension = currentExtensions[token];
      if (extension) {
        if (extension.handlesRead) {
          return extension(read);
        } else {
          return extension(read());
        }
      } else {
        let input = read();
        for (let i = 0; i < currentExtensionRanges.length; i++) {
          let value = currentExtensionRanges[i](token, input);
          if (value !== void 0) {
            return value;
          }
        }
        return new Tag(input, token);
      }
    case 7:
      switch (token) {
        case 20:
          return false;
        case 21:
          return true;
        case 22:
          return null;
        case 23:
          return;
        case 31:
        default:
          let packedValue = (packedValues || getPackedValues())[token];
          if (packedValue !== void 0) {
            return packedValue;
          }
          throw new Error("Unknown token " + token);
      }
    default:
      if (isNaN(token)) {
        let error = new Error("Unexpected end of CBOR data");
        error.incomplete = true;
        throw error;
      }
      throw new Error("Unknown CBOR token " + token);
  }
}
var validName = /^[a-zA-Z_$][a-zA-Z\d_$]*$/;
function createStructureReader(structure) {
  function readObject() {
    let length = src[position++];
    length = length & 31;
    if (length > 23) {
      switch (length) {
        case 24:
          length = src[position++];
          break;
        case 25:
          length = dataView.getUint16(position);
          position += 2;
          break;
        case 26:
          length = dataView.getUint32(position);
          position += 4;
          break;
        default:
          throw new Error("Expected array header, but got " + src[position - 1]);
      }
    }
    let compiledReader = this.compiledReader;
    while (compiledReader) {
      if (compiledReader.propertyCount === length) {
        return compiledReader(read);
      }
      compiledReader = compiledReader.next;
    }
    if (this.slowReads++ >= 3) {
      let array = this.length == length ? this : this.slice(0, length);
      compiledReader = currentDecoder.keyMap ? new Function("r", "return {" + array.map((k) => currentDecoder.decodeKey(k)).map((k) => validName.test(k) ? safeKey(k) + ":r()" : "[" + JSON.stringify(k) + "]:r()").join(",") + "}") : new Function("r", "return {" + array.map((key) => validName.test(key) ? safeKey(key) + ":r()" : "[" + JSON.stringify(key) + "]:r()").join(",") + "}");
      if (this.compiledReader) {
        compiledReader.next = this.compiledReader;
      }
      compiledReader.propertyCount = length;
      this.compiledReader = compiledReader;
      return compiledReader(read);
    }
    let object = {};
    if (currentDecoder.keyMap) {
      for (let i = 0; i < length; i++) {
        object[safeKey(currentDecoder.decodeKey(this[i]))] = read();
      }
    } else {
      for (let i = 0; i < length; i++) {
        object[safeKey(this[i])] = read();
      }
    }
    return object;
  }
  structure.slowReads = 0;
  return readObject;
}
function safeKey(key) {
  return key === "__proto__" ? "__proto_" : key;
}
var readFixedString = readStringJS;
function readStringJS(length) {
  let result;
  if (length < 16) {
    if (result = shortStringInJS(length)) {
      return result;
    }
  }
  if (length > 64 && decoder) {
    return decoder.decode(src.subarray(position, position += length));
  }
  const end = position + length;
  const units = [];
  result = "";
  while (position < end) {
    const byte1 = src[position++];
    if ((byte1 & 128) === 0) {
      units.push(byte1);
    } else if ((byte1 & 224) === 192) {
      const byte2 = src[position++] & 63;
      units.push((byte1 & 31) << 6 | byte2);
    } else if ((byte1 & 240) === 224) {
      const byte2 = src[position++] & 63;
      const byte3 = src[position++] & 63;
      units.push((byte1 & 31) << 12 | byte2 << 6 | byte3);
    } else if ((byte1 & 248) === 240) {
      const byte2 = src[position++] & 63;
      const byte3 = src[position++] & 63;
      const byte4 = src[position++] & 63;
      let unit = (byte1 & 7) << 18 | byte2 << 12 | byte3 << 6 | byte4;
      if (unit > 65535) {
        unit -= 65536;
        units.push(unit >>> 10 & 1023 | 55296);
        unit = 56320 | unit & 1023;
      }
      units.push(unit);
    } else {
      units.push(byte1);
    }
    if (units.length >= 4096) {
      result += fromCharCode.apply(String, units);
      units.length = 0;
    }
  }
  if (units.length > 0) {
    result += fromCharCode.apply(String, units);
  }
  return result;
}
var fromCharCode = String.fromCharCode;
function longStringInJS(length) {
  let start = position;
  let bytes = new Array(length);
  for (let i = 0; i < length; i++) {
    const byte = src[position++];
    if ((byte & 128) > 0) {
      position = start;
      return;
    }
    bytes[i] = byte;
  }
  return fromCharCode.apply(String, bytes);
}
function shortStringInJS(length) {
  if (length < 4) {
    if (length < 2) {
      if (length === 0) {
        return "";
      } else {
        let a = src[position++];
        if ((a & 128) > 1) {
          position -= 1;
          return;
        }
        return fromCharCode(a);
      }
    } else {
      let a = src[position++];
      let b = src[position++];
      if ((a & 128) > 0 || (b & 128) > 0) {
        position -= 2;
        return;
      }
      if (length < 3) {
        return fromCharCode(a, b);
      }
      let c = src[position++];
      if ((c & 128) > 0) {
        position -= 3;
        return;
      }
      return fromCharCode(a, b, c);
    }
  } else {
    let a = src[position++];
    let b = src[position++];
    let c = src[position++];
    let d = src[position++];
    if ((a & 128) > 0 || (b & 128) > 0 || (c & 128) > 0 || (d & 128) > 0) {
      position -= 4;
      return;
    }
    if (length < 6) {
      if (length === 4) {
        return fromCharCode(a, b, c, d);
      } else {
        let e = src[position++];
        if ((e & 128) > 0) {
          position -= 5;
          return;
        }
        return fromCharCode(a, b, c, d, e);
      }
    } else if (length < 8) {
      let e = src[position++];
      let f3 = src[position++];
      if ((e & 128) > 0 || (f3 & 128) > 0) {
        position -= 6;
        return;
      }
      if (length < 7) {
        return fromCharCode(a, b, c, d, e, f3);
      }
      let g = src[position++];
      if ((g & 128) > 0) {
        position -= 7;
        return;
      }
      return fromCharCode(a, b, c, d, e, f3, g);
    } else {
      let e = src[position++];
      let f3 = src[position++];
      let g = src[position++];
      let h = src[position++];
      if ((e & 128) > 0 || (f3 & 128) > 0 || (g & 128) > 0 || (h & 128) > 0) {
        position -= 8;
        return;
      }
      if (length < 10) {
        if (length === 8) {
          return fromCharCode(a, b, c, d, e, f3, g, h);
        } else {
          let i = src[position++];
          if ((i & 128) > 0) {
            position -= 9;
            return;
          }
          return fromCharCode(a, b, c, d, e, f3, g, h, i);
        }
      } else if (length < 12) {
        let i = src[position++];
        let j = src[position++];
        if ((i & 128) > 0 || (j & 128) > 0) {
          position -= 10;
          return;
        }
        if (length < 11) {
          return fromCharCode(a, b, c, d, e, f3, g, h, i, j);
        }
        let k = src[position++];
        if ((k & 128) > 0) {
          position -= 11;
          return;
        }
        return fromCharCode(a, b, c, d, e, f3, g, h, i, j, k);
      } else {
        let i = src[position++];
        let j = src[position++];
        let k = src[position++];
        let l = src[position++];
        if ((i & 128) > 0 || (j & 128) > 0 || (k & 128) > 0 || (l & 128) > 0) {
          position -= 12;
          return;
        }
        if (length < 14) {
          if (length === 12) {
            return fromCharCode(a, b, c, d, e, f3, g, h, i, j, k, l);
          } else {
            let m = src[position++];
            if ((m & 128) > 0) {
              position -= 13;
              return;
            }
            return fromCharCode(a, b, c, d, e, f3, g, h, i, j, k, l, m);
          }
        } else {
          let m = src[position++];
          let n = src[position++];
          if ((m & 128) > 0 || (n & 128) > 0) {
            position -= 14;
            return;
          }
          if (length < 15) {
            return fromCharCode(a, b, c, d, e, f3, g, h, i, j, k, l, m, n);
          }
          let o = src[position++];
          if ((o & 128) > 0) {
            position -= 15;
            return;
          }
          return fromCharCode(a, b, c, d, e, f3, g, h, i, j, k, l, m, n, o);
        }
      }
    }
  }
}
function readBin(length) {
  return currentDecoder.copyBuffers ? Uint8Array.prototype.slice.call(src, position, position += length) : src.subarray(position, position += length);
}
var f32Array = new Float32Array(1);
var u8Array = new Uint8Array(f32Array.buffer, 0, 4);
function getFloat16() {
  let byte0 = src[position++];
  let byte1 = src[position++];
  let exponent = (byte0 & 127) >> 2;
  if (exponent === 31) {
    if (byte1 || byte0 & 3) {
      return NaN;
    }
    return byte0 & 128 ? -Infinity : Infinity;
  }
  if (exponent === 0) {
    let abs = ((byte0 & 3) << 8 | byte1) / (1 << 24);
    return byte0 & 128 ? -abs : abs;
  }
  u8Array[3] = byte0 & 128 | (exponent >> 1) + 56;
  u8Array[2] = (byte0 & 7) << 5 | byte1 >> 3;
  u8Array[1] = byte1 << 5;
  u8Array[0] = 0;
  return f32Array[0];
}
var Tag = class {
  constructor(value, tag) {
    this.value = value;
    this.tag = tag;
  }
};
currentExtensions[0] = (dateString) => {
  return new Date(dateString);
};
currentExtensions[1] = (epochSec) => {
  return new Date(Math.round(epochSec * 1e3));
};
currentExtensions[2] = (buffer) => {
  let value = BigInt(0);
  for (let i = 0, l = buffer.byteLength; i < l; i++) {
    value = BigInt(buffer[i]) + value << BigInt(8);
  }
  return value;
};
currentExtensions[3] = (buffer) => {
  return BigInt(-1) - currentExtensions[2](buffer);
};
currentExtensions[4] = (fraction) => {
  return Number(fraction[1] + "e" + fraction[0]);
};
currentExtensions[5] = (fraction) => {
  return fraction[1] * Math.exp(fraction[0] * Math.log(2));
};
var recordDefinition = (definition) => {
  let id = definition[0] - 57344;
  let structure = definition[1];
  let existingStructure = currentStructures[id];
  if (existingStructure && existingStructure.isShared) {
    (currentStructures.restoreStructures || (currentStructures.restoreStructures = []))[id] = existingStructure;
  }
  currentStructures[id] = structure;
  structure.read = createStructureReader(structure);
  let object = {};
  if (currentDecoder.keyMap) {
    for (let i = 2, l = definition.length; i < l; i++) {
      let key = currentDecoder.decodeKey(structure[i - 2]);
      object[safeKey(key)] = definition[i];
    }
  } else {
    for (let i = 2, l = definition.length; i < l; i++) {
      let key = structure[i - 2];
      object[safeKey(key)] = definition[i];
    }
  }
  return object;
};
currentExtensions[LEGACY_RECORD_INLINE_ID] = recordDefinition;
currentExtensions[14] = (value) => {
  if (bundledStrings) {
    return bundledStrings[0].slice(bundledStrings.position0, bundledStrings.position0 += value);
  }
  return new Tag(value, 14);
};
currentExtensions[15] = (value) => {
  if (bundledStrings) {
    return bundledStrings[1].slice(bundledStrings.position1, bundledStrings.position1 += value);
  }
  return new Tag(value, 15);
};
var glbl = {
  Error,
  RegExp
};
currentExtensions[27] = (data) => {
  return (glbl[data[0]] || Error)(data[1], data[2]);
};
var packedTable = (_read) => {
  if (src[position++] != 132) {
    throw new Error("Packed values structure must be followed by a 4 element array");
  }
  let newPackedValues = _read();
  packedValues = packedValues ? newPackedValues.concat(packedValues.slice(newPackedValues.length)) : newPackedValues;
  packedValues.prefixes = _read();
  packedValues.suffixes = _read();
  return _read();
};
packedTable.handlesRead = true;
currentExtensions[51] = packedTable;
currentExtensions[PACKED_REFERENCE_TAG_ID] = (data) => {
  if (!packedValues) {
    if (currentDecoder.getShared) {
      loadShared();
    } else {
      return new Tag(data, PACKED_REFERENCE_TAG_ID);
    }
  }
  if (typeof data === "number") {
    return packedValues[16 + (data >= 0 ? 2 * data : -2 * data - 1)];
  }
  throw new Error("No support for non-integer packed references yet");
};
currentExtensions[25] = (id) => {
  return stringRefs[id];
};
currentExtensions[256] = (_read) => {
  stringRefs = [];
  try {
    return _read();
  } finally {
    stringRefs = null;
  }
};
currentExtensions[256].handlesRead = true;
currentExtensions[28] = (_read) => {
  if (!referenceMap) {
    referenceMap = /* @__PURE__ */ new Map();
    referenceMap.id = 0;
  }
  let id = referenceMap.id++;
  let token = src[position];
  let target;
  if (token >> 5 == 4) {
    target = [];
  } else {
    target = {};
  }
  let refEntry = {
    target
  };
  referenceMap.set(id, refEntry);
  let targetProperties = _read();
  if (refEntry.used) {
    return Object.assign(target, targetProperties);
  }
  refEntry.target = targetProperties;
  return targetProperties;
};
currentExtensions[28].handlesRead = true;
currentExtensions[29] = (id) => {
  let refEntry = referenceMap.get(id);
  refEntry.used = true;
  return refEntry.target;
};
currentExtensions[258] = (array) => new Set(array);
(currentExtensions[259] = (_read) => {
  if (currentDecoder.mapsAsObjects) {
    currentDecoder.mapsAsObjects = false;
    restoreMapsAsObject = true;
  }
  return _read();
}).handlesRead = true;
function combine(a, b) {
  if (typeof a === "string") {
    return a + b;
  }
  if (a instanceof Array) {
    return a.concat(b);
  }
  return Object.assign({}, a, b);
}
function getPackedValues() {
  if (!packedValues) {
    if (currentDecoder.getShared) {
      loadShared();
    } else {
      throw new Error("No packed values available");
    }
  }
  return packedValues;
}
var SHARED_DATA_TAG_ID = 1399353956;
currentExtensionRanges.push((tag, input) => {
  if (tag >= 225 && tag <= 255) {
    return combine(getPackedValues().prefixes[tag - 224], input);
  }
  if (tag >= 28704 && tag <= 32767) {
    return combine(getPackedValues().prefixes[tag - 28672], input);
  }
  if (tag >= 1879052288 && tag <= 2147483647) {
    return combine(getPackedValues().prefixes[tag - 1879048192], input);
  }
  if (tag >= 216 && tag <= 223) {
    return combine(input, getPackedValues().suffixes[tag - 216]);
  }
  if (tag >= 27647 && tag <= 28671) {
    return combine(input, getPackedValues().suffixes[tag - 27639]);
  }
  if (tag >= 1811940352 && tag <= 1879048191) {
    return combine(input, getPackedValues().suffixes[tag - 1811939328]);
  }
  if (tag == SHARED_DATA_TAG_ID) {
    return {
      packedValues,
      structures: currentStructures.slice(0),
      version: input
    };
  }
  if (tag == 55799) {
    return input;
  }
});
var isLittleEndianMachine = new Uint8Array(new Uint16Array([1]).buffer)[0] == 1;
var typedArrays = [Uint8Array];
var typedArrayTags = [64];
for (let i = 0; i < typedArrays.length; i++) {
  registerTypedArray(typedArrays[i], typedArrayTags[i]);
}
function registerTypedArray(TypedArray, tag) {
  let dvMethod = "get" + TypedArray.name.slice(0, -5);
  if (typeof TypedArray !== "function") {
    TypedArray = null;
  }
  let bytesPerElement = TypedArray.BYTES_PER_ELEMENT;
  for (let littleEndian = 0; littleEndian < 2; littleEndian++) {
    if (!littleEndian && bytesPerElement == 1) {
      continue;
    }
    let sizeShift = bytesPerElement == 2 ? 1 : bytesPerElement == 4 ? 2 : 3;
    currentExtensions[littleEndian ? tag : tag - 4] = bytesPerElement == 1 || littleEndian == isLittleEndianMachine ? (buffer) => {
      if (!TypedArray) {
        throw new Error("Could not find typed array for code " + tag);
      }
      return new TypedArray(Uint8Array.prototype.slice.call(buffer, 0).buffer);
    } : (buffer) => {
      if (!TypedArray) {
        throw new Error("Could not find typed array for code " + tag);
      }
      let dv = new DataView(buffer.buffer, buffer.byteOffset, buffer.byteLength);
      let elements = buffer.length >> sizeShift;
      let ta = new TypedArray(elements);
      let method = dv[dvMethod];
      for (let i = 0; i < elements; i++) {
        ta[i] = method.call(dv, i << sizeShift, littleEndian);
      }
      return ta;
    };
  }
}
function readBundleExt() {
  let length = readJustLength();
  let bundlePosition = position + read();
  for (let i = 2; i < length; i++) {
    let bundleLength = readJustLength();
    position += bundleLength;
  }
  let dataPosition = position;
  position = bundlePosition;
  bundledStrings = [readStringJS(readJustLength()), readStringJS(readJustLength())];
  bundledStrings.position0 = 0;
  bundledStrings.position1 = 0;
  bundledStrings.postBundlePosition = position;
  position = dataPosition;
  return read();
}
function readJustLength() {
  let token = src[position++] & 31;
  if (token > 23) {
    switch (token) {
      case 24:
        token = src[position++];
        break;
      case 25:
        token = dataView.getUint16(position);
        position += 2;
        break;
      case 26:
        token = dataView.getUint32(position);
        position += 4;
        break;
    }
  }
  return token;
}
function loadShared() {
  if (currentDecoder.getShared) {
    let sharedData = saveState(() => {
      src = null;
      return currentDecoder.getShared();
    }) || {};
    let updatedStructures = sharedData.structures || [];
    currentDecoder.sharedVersion = sharedData.version;
    packedValues = currentDecoder.sharedValues = sharedData.packedValues;
    if (currentStructures === true) {
      currentDecoder.structures = currentStructures = updatedStructures;
    } else {
      currentStructures.splice.apply(currentStructures, [0, updatedStructures.length].concat(updatedStructures));
    }
  }
}
function saveState(callback) {
  let savedSrcEnd = srcEnd;
  let savedPosition = position;
  let savedSrcStringStart = srcStringStart;
  let savedSrcStringEnd = srcStringEnd;
  let savedSrcString = srcString;
  let savedReferenceMap = referenceMap;
  let savedBundledStrings = bundledStrings;
  let savedSrc = new Uint8Array(src.slice(0, srcEnd));
  let savedStructures = currentStructures;
  let savedDecoder = currentDecoder;
  let savedSequentialMode = sequentialMode;
  let value = callback();
  srcEnd = savedSrcEnd;
  position = savedPosition;
  srcStringStart = savedSrcStringStart;
  srcStringEnd = savedSrcStringEnd;
  srcString = savedSrcString;
  referenceMap = savedReferenceMap;
  bundledStrings = savedBundledStrings;
  src = savedSrc;
  sequentialMode = savedSequentialMode;
  currentStructures = savedStructures;
  currentDecoder = savedDecoder;
  dataView = new DataView(src.buffer, src.byteOffset, src.byteLength);
  return value;
}
function clearSource() {
  src = null;
  referenceMap = null;
  currentStructures = null;
}
var mult10 = new Array(147);
for (let i = 0; i < 256; i++) {
  mult10[i] = Number("1e" + Math.floor(45.15 - i * 0.30103));
}
var defaultDecoder = new Decoder({
  useRecords: false
});
var decode = defaultDecoder.decode;
function matchesAbiInterface(abi, feature) {
  return hasMatchingAbi(abi, feature.abis);
}
function hasMatchingAbi(contractAbi, featureAbis) {
  const contractFn = extractFunctionsFromAbi(contractAbi);
  const interfaceFn = featureAbis.flatMap((i) => extractFunctionsFromAbi(i));
  const intersection = contractFn.filter((fn) => {
    const match = interfaceFn.find((iFn) => iFn.name === fn.name && iFn.inputs.length === fn.inputs.length && iFn.inputs.every((i, index) => {
      var _a;
      if (i.type === "tuple" || i.type === "tuple[]") {
        return i.type === fn.inputs[index].type && ((_a = i.components) == null ? void 0 : _a.every((c, cIndex) => {
          var _a2, _b;
          return c.type === ((_b = (_a2 = fn.inputs[index].components) == null ? void 0 : _a2[cIndex]) == null ? void 0 : _b.type);
        }));
      }
      return i.type === fn.inputs[index].type;
    }));
    return match !== void 0;
  });
  return intersection.length === interfaceFn.length;
}
async function extractConstructorParams(predeployMetadataUri, storage) {
  const meta = await fetchPreDeployMetadata(predeployMetadataUri, storage);
  return extractConstructorParamsFromAbi(meta.abi);
}
async function extractFunctions(predeployMetadataUri, storage) {
  const metadata = await fetchPreDeployMetadata(predeployMetadataUri, storage);
  return extractFunctionsFromAbi(metadata.abi, metadata.metadata);
}
function extractCommentFromMetadata(name, metadata, type) {
  var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j;
  return ((_e = (_d = (_b = (_a = metadata == null ? void 0 : metadata.output) == null ? void 0 : _a.userdoc) == null ? void 0 : _b[type]) == null ? void 0 : _d[Object.keys(((_c = metadata == null ? void 0 : metadata.output) == null ? void 0 : _c.userdoc[type]) || {}).find((fn) => fn.includes(name || "unknown")) || ""]) == null ? void 0 : _e.notice) || ((_j = (_i = (_g = (_f = metadata == null ? void 0 : metadata.output) == null ? void 0 : _f.devdoc) == null ? void 0 : _g[type]) == null ? void 0 : _i[Object.keys(((_h = metadata == null ? void 0 : metadata.output) == null ? void 0 : _h.devdoc[type]) || {}).find((fn) => fn.includes(name || "unknown")) || ""]) == null ? void 0 : _j.details);
}
function extractConstructorParamsFromAbi(abi) {
  for (const input of abi) {
    if (input.type === "constructor") {
      return input.inputs || [];
    }
  }
  return [];
}
function extractFunctionParamsFromAbi(abi, functionName) {
  for (const input of abi) {
    if (input.type === "function" && input.name === functionName) {
      return input.inputs || [];
    }
  }
  return [];
}
function extractFunctionsFromAbi(abi, metadata) {
  var _a, _b, _c, _d;
  const functions = (abi || []).filter((el) => el.type === "function");
  const parsed = [];
  for (const f3 of functions) {
    const doc = extractCommentFromMetadata(f3.name, metadata, "methods");
    const args = ((_b = (_a = f3.inputs) == null ? void 0 : _a.map((i) => `${i.name || "key"}: ${toJSType(i)}`)) == null ? void 0 : _b.join(", ")) || "";
    const fargs = args ? `, ${args}` : "";
    const out = (_d = (_c = f3.outputs) == null ? void 0 : _c.map((o) => toJSType(o, true))) == null ? void 0 : _d.join(", ");
    const promise = out ? `: Promise<${out}>` : `: Promise<TransactionResult>`;
    const signature = `contract.call("${f3.name}"${fargs})${promise}`;
    parsed.push({
      inputs: f3.inputs || [],
      outputs: f3.outputs || [],
      name: f3.name || "unknown",
      signature,
      stateMutability: f3.stateMutability || "",
      comment: doc
    });
  }
  return parsed;
}
function extractEventsFromAbi(abi, metadata) {
  const events = (abi || []).filter((el) => el.type === "event");
  const parsed = [];
  for (const e of events) {
    const doc = extractCommentFromMetadata(e.name, metadata, "events");
    parsed.push({
      inputs: e.inputs || [],
      outputs: e.outputs || [],
      name: e.name || "unknown",
      comment: doc
    });
  }
  return parsed;
}
function toJSType(contractType) {
  let isReturnType = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
  let withName = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
  let jsType = contractType.type;
  let isArray = false;
  if (jsType.endsWith("[]")) {
    isArray = true;
    jsType = jsType.slice(0, -2);
  }
  if (jsType.startsWith("bytes")) {
    jsType = "BytesLike";
  }
  if (jsType.startsWith("uint") || jsType.startsWith("int")) {
    jsType = isReturnType ? "BigNumber" : "BigNumberish";
  }
  if (jsType.startsWith("bool")) {
    jsType = "boolean";
  }
  if (jsType === "address") {
    jsType = "string";
  }
  if (jsType === "tuple") {
    if (contractType.components) {
      jsType = `{ ${contractType.components.map((a) => toJSType(a, false, true)).join(", ")} }`;
    }
  }
  if (isArray) {
    jsType += "[]";
  }
  if (withName) {
    jsType = `${contractType.name}: ${jsType}`;
  }
  return jsType;
}
function extractMinimalProxyImplementationAddress(bytecode) {
  if (bytecode.startsWith("0x363d3d373d3d3d363d73")) {
    const implementationAddress = bytecode.slice(22, 62);
    return `0x${implementationAddress}`;
  }
  if (bytecode.startsWith("0x36603057343d5230")) {
    const implementationAddress = bytecode.slice(122, 122 + 40);
    return `0x${implementationAddress}`;
  }
  if (bytecode.startsWith("0x3d3d3d3d363d3d37363d73")) {
    const implementationAddress = bytecode.slice(24, 24 + 40);
    return `0x${implementationAddress}`;
  }
  if (bytecode.startsWith("0x366000600037611000600036600073")) {
    const implementationAddress = bytecode.slice(32, 32 + 40);
    return `0x${implementationAddress}`;
  }
  return void 0;
}
async function resolveContractUriFromAddress(address, provider) {
  const bytecode = await provider.getCode(address);
  if (bytecode === "0x") {
    const chain = await provider.getNetwork();
    throw new Error(`Contract at ${address} does not exist on chain '${chain.name}' (chainId: ${chain.chainId})`);
  }
  try {
    const implementationAddress = extractMinimalProxyImplementationAddress(bytecode);
    if (implementationAddress) {
      return await resolveContractUriFromAddress(implementationAddress, provider);
    }
  } catch (e) {
  }
  try {
    const proxyStorage = await provider.getStorageAt(address, BigNumber.from("0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc"));
    const implementationAddress = ethers_exports.utils.hexStripZeros(proxyStorage);
    if (implementationAddress !== "0x") {
      return await resolveContractUriFromAddress(implementationAddress, provider);
    }
  } catch (e) {
  }
  return await extractIPFSHashFromBytecode(bytecode);
}
function extractIPFSHashFromBytecode(bytecode) {
  const numericBytecode = hexToBytes(bytecode);
  const cborLength = numericBytecode[numericBytecode.length - 2] * 256 + numericBytecode[numericBytecode.length - 1];
  const bytecodeBuffer = Uint8Array.from(numericBytecode.slice(numericBytecode.length - 2 - cborLength, -2));
  const cborData = decode(bytecodeBuffer);
  if ("ipfs" in cborData && cborData["ipfs"]) {
    try {
      return `ipfs://${import_bs58.default.encode(cborData["ipfs"])}`;
    } catch (e) {
      console.warn("feature-detection ipfs cbor failed", e);
    }
  }
  return void 0;
}
function hexToBytes(hex) {
  hex = hex.toString(16);
  if (!hex.startsWith("0x")) {
    hex = `0x${hex}`;
  }
  if (!isHexStrict(hex)) {
    throw new Error(`Given value "${hex}" is not a valid hex string.`);
  }
  hex = hex.replace(/^0x/i, "");
  const bytes = [];
  for (let c = 0; c < hex.length; c += 2) {
    bytes.push(parseInt(hex.slice(c, c + 2), 16));
  }
  return bytes;
}
function isHexStrict(hex) {
  return (typeof hex === "string" || typeof hex === "number") && /^(-)?0x[0-9a-f]*$/i.test(hex.toString());
}
async function fetchContractMetadataFromAddress(address, provider, storage) {
  const compilerMetadataUri = await resolveContractUriFromAddress(address, provider);
  if (!compilerMetadataUri) {
    throw new Error(`Could not resolve metadata for contract at ${address}`);
  }
  return await fetchContractMetadata(compilerMetadataUri, storage);
}
async function fetchContractMetadata(compilerMetadataUri, storage) {
  const metadata = await storage.downloadJSON(compilerMetadataUri);
  if (!metadata || !metadata.output) {
    throw new Error(`Could not resolve metadata for contract at ${compilerMetadataUri}`);
  }
  const abi = AbiSchema.parse(metadata.output.abi);
  const compilationTarget = metadata.settings.compilationTarget;
  const targets = Object.keys(compilationTarget);
  const name = compilationTarget[targets[0]];
  const info = ContractInfoSchema.parse({
    title: metadata.output.devdoc.title,
    author: metadata.output.devdoc.author,
    details: metadata.output.devdoc.detail,
    notice: metadata.output.userdoc.notice
  });
  const licenses = [...new Set(Object.entries(metadata.sources).map((_ref) => {
    let [, src2] = _ref;
    return src2.license;
  }))];
  return {
    name,
    abi,
    metadata,
    info,
    licenses
  };
}
async function fetchSourceFilesFromMetadata(publishedMetadata, storage) {
  return await Promise.all(Object.entries(publishedMetadata.metadata.sources).map(async (_ref2) => {
    let [path, info] = _ref2;
    const urls = info.urls;
    const ipfsLink = urls ? urls.find((url) => url.includes("ipfs")) : void 0;
    if (ipfsLink) {
      const ipfsHash = ipfsLink.split("ipfs/")[1];
      const timeout = new Promise((_r, rej) => setTimeout(() => rej("timeout"), 5e3));
      const source = await Promise.race([(await storage.download(`ipfs://${ipfsHash}`)).text(), timeout]);
      return {
        filename: path,
        source
      };
    } else {
      return {
        filename: path,
        source: info.content || "Could not find source for this contract"
      };
    }
  }));
}
async function fetchRawPredeployMetadata(publishMetadataUri, storage) {
  return PreDeployMetadata.parse(JSON.parse(await (await storage.download(publishMetadataUri)).text()));
}
async function fetchPreDeployMetadata(publishMetadataUri, storage) {
  const rawMeta = await fetchRawPredeployMetadata(publishMetadataUri, storage);
  const deployBytecode = await (await storage.download(rawMeta.bytecodeUri)).text();
  const parsedMeta = await fetchContractMetadata(rawMeta.metadataUri, storage);
  return PreDeployMetadataFetchedSchema.parse({
    ...rawMeta,
    ...parsedMeta,
    bytecode: deployBytecode
  });
}
async function fetchExtendedReleaseMetadata(publishMetadataUri, storage) {
  const meta = await (await storage.download(publishMetadataUri)).text();
  return FullPublishMetadataSchemaOutput.parse(JSON.parse(meta));
}
function detectFeatures(abi) {
  let features = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : SUPPORTED_FEATURES;
  const results = {};
  for (const featureKey in features) {
    const feature = features[featureKey];
    const enabled = matchesAbiInterface(abi, feature);
    const childResults = detectFeatures(abi, feature.features);
    results[featureKey] = {
      ...feature,
      features: childResults,
      enabled
    };
  }
  return results;
}
function isFeatureEnabled(abi, featureName) {
  const features = detectFeatures(abi);
  return _featureEnabled(features, featureName);
}
function assertEnabled(namespace, feature) {
  if (!namespace) {
    throw new ExtensionNotImplementedError(feature);
  }
  return namespace;
}
function detectContractFeature(contractWrapper, featureName) {
  return isFeatureEnabled(AbiSchema.parse(contractWrapper.abi), featureName);
}
function _featureEnabled(features, featureName) {
  const keys = Object.keys(features);
  if (!keys.includes(featureName)) {
    let found = false;
    for (const key of keys) {
      const f3 = features[key];
      found = _featureEnabled(f3.features, featureName);
      if (found) {
        break;
      }
    }
    return found;
  }
  const feature = features[featureName];
  return feature.enabled;
}
function hasFunction(functionName, contractWrapper) {
  return functionName in contractWrapper.readContract.functions;
}
var MAX_LENGTH = 256;
var NUMERIC_IDENTIFIER = "0|[1-9]\\d*";
var MAIN_VERSION_IDENTIFIER = `(${NUMERIC_IDENTIFIER})\\.(${NUMERIC_IDENTIFIER})\\.(${NUMERIC_IDENTIFIER})`;
var REGEX_MAIN_VERSION = new RegExp(MAIN_VERSION_IDENTIFIER);
function toSemver(version) {
  if (version.length > MAX_LENGTH) {
    throw new Error(`version is longer than ${MAX_LENGTH} characters`);
  }
  const matches = version.trim().match(REGEX_MAIN_VERSION);
  if (!matches || (matches == null ? void 0 : matches.length) !== 4) {
    throw new Error(`${version} is not a valid semantic version. Should be in the format of major.minor.patch. Ex: 0.4.1`);
  }
  const major = Number(matches[1]);
  const minor = Number(matches[2]);
  const patch = Number(matches[3]);
  const versionString = [major, minor, patch].join(".");
  return {
    major,
    minor,
    patch,
    versionString
  };
}
function isIncrementalVersion(current, next) {
  const currentSemver = toSemver(current);
  const nextSemver = toSemver(next);
  if (nextSemver.major > currentSemver.major) {
    return true;
  }
  const eqMajor = nextSemver.major === currentSemver.major;
  if (eqMajor && nextSemver.minor > currentSemver.minor) {
    return true;
  }
  const eqMinor = nextSemver.minor === currentSemver.minor;
  return eqMajor && eqMinor && nextSemver.patch > currentSemver.patch;
}
var BYOCContractMetadataSchema = CommonContractSchema.catchall(mod.union([BigNumberTransformSchema2, mod.unknown()]));
var CustomContractInput = BYOCContractMetadataSchema.merge(CommonRoyaltySchema.merge(MerkleSchema).merge(CommonSymbolSchema).partial());
var CustomContractOutput = CommonContractOutputSchema.merge(CommonRoyaltySchema.merge(MerkleSchema).merge(CommonSymbolSchema).partial());
var CustomContractDeploy = CustomContractInput.merge(CommonPlatformFeeSchema.merge(CommonPrimarySaleSchema).merge(CommonTrustedForwarderSchema).partial());
var CustomContractSchema = {
  deploy: CustomContractDeploy,
  output: CustomContractOutput,
  input: CustomContractInput
};
var AbiTypeBaseSchema = mod.object({
  type: mod.string(),
  name: mod.string()
}).catchall(mod.any());
var AbiTypeSchema = AbiTypeBaseSchema.extend({
  stateMutability: mod.string().optional(),
  components: mod.array(AbiTypeBaseSchema).optional()
}).catchall(mod.any());
var AbiObjectSchema = mod.object({
  type: mod.string(),
  name: mod.string().default(""),
  inputs: mod.array(AbiTypeSchema).default([]),
  outputs: mod.array(AbiTypeSchema).default([])
}).catchall(mod.any());
var AbiSchema = mod.array(AbiObjectSchema);
var PreDeployMetadata = mod.object({
  name: mod.string(),
  metadataUri: mod.string(),
  bytecodeUri: mod.string(),
  analytics: mod.any().optional()
}).catchall(mod.any());
var ChainIdToAddressSchema = mod.record(mod.string(), mod.string());
var FactoryDeploymentSchema = mod.object({
  implementationAddresses: ChainIdToAddressSchema,
  implementationInitializerFunction: mod.string().default("initialize"),
  factoryAddresses: ChainIdToAddressSchema.optional()
});
var ExtraPublishMetadataSchemaInput = mod.object({
  version: mod.string().refine((v) => {
    try {
      toSemver(v);
      return true;
    } catch (e) {
      return false;
    }
  }, (out) => {
    return {
      message: `'${out}' is not a valid semantic version. Should be in the format of major.minor.patch. Ex: 0.4.1`
    };
  }),
  displayName: mod.string().optional(),
  description: mod.string().optional(),
  readme: mod.string().optional(),
  license: mod.string().optional(),
  changelog: mod.string().optional(),
  tags: mod.array(mod.string()).optional(),
  audit: FileOrBufferOrStringSchema.nullable().optional(),
  logo: FileOrBufferOrStringSchema.nullable().optional(),
  isDeployableViaFactory: mod.boolean().optional(),
  isDeployableViaProxy: mod.boolean().optional(),
  factoryDeploymentData: FactoryDeploymentSchema.optional(),
  constructorParams: mod.record(mod.string(), mod.object({
    displayName: mod.string().optional(),
    description: mod.string().optional(),
    defaultValue: mod.string().optional()
  }).catchall(mod.any())).optional()
}).catchall(mod.any());
var ExtraPublishMetadataSchemaOutput = ExtraPublishMetadataSchemaInput.extend({
  audit: mod.string().nullable().optional(),
  logo: mod.string().nullable().optional()
});
var FullPublishMetadataSchemaInput = PreDeployMetadata.merge(ExtraPublishMetadataSchemaInput).extend({
  publisher: AddressSchema.optional()
});
var FullPublishMetadataSchemaOutput = PreDeployMetadata.merge(ExtraPublishMetadataSchemaOutput).extend({
  publisher: AddressSchema.optional()
});
var ProfileSchemaInput = mod.object({
  name: mod.string().optional(),
  bio: mod.string().optional(),
  avatar: FileOrBufferOrStringSchema.nullable().optional(),
  website: mod.string().optional(),
  twitter: mod.string().optional(),
  telegram: mod.string().optional(),
  facebook: mod.string().optional(),
  github: mod.string().optional(),
  medium: mod.string().optional(),
  linkedin: mod.string().optional(),
  reddit: mod.string().optional(),
  discord: mod.string().optional()
});
var ProfileSchemaOutput = ProfileSchemaInput.extend({
  avatar: mod.string().nullable().optional()
});
var PublishedContractSchema = mod.object({
  id: mod.string(),
  timestamp: BigNumberishSchema,
  metadataUri: mod.string()
});
var ContractInfoSchema = mod.object({
  title: mod.string().optional(),
  author: mod.string().optional(),
  details: mod.string().optional(),
  notice: mod.string().optional()
});
var CompilerMetadataFetchedSchema = mod.object({
  name: mod.string(),
  abi: AbiSchema,
  metadata: mod.record(mod.string(), mod.any()),
  info: ContractInfoSchema,
  licenses: mod.array(mod.string().optional()).default([]).transform((v) => {
    return v.filter((license) => license !== void 0);
  })
});
var PreDeployMetadataFetchedSchema = PreDeployMetadata.merge(CompilerMetadataFetchedSchema).extend({
  bytecode: mod.string()
});
var WalletAuthenticator = class extends RPCConnectionHandler {
  constructor(network, wallet, options) {
    super(network, options);
    _defineProperty(this, "wallet", void 0);
    this.wallet = wallet;
  }
  async login(domain, options) {
    const parsedOptions = LoginOptionsSchema.parse(options);
    const signerAddress = await this.wallet.getAddress();
    const expirationTime = (parsedOptions == null ? void 0 : parsedOptions.expirationTime) || new Date(Date.now() + 1e3 * 60 * 5);
    const payloadData = LoginPayloadDataSchema.parse({
      domain,
      address: signerAddress,
      nonce: parsedOptions == null ? void 0 : parsedOptions.nonce,
      expiration_time: expirationTime,
      chain_id: parsedOptions == null ? void 0 : parsedOptions.chainId
    });
    const message = this.generateMessage(payloadData);
    const signature = await this.wallet.sign(message);
    return {
      payload: payloadData,
      signature
    };
  }
  verify(domain, payload, options) {
    const parsedOptions = VerifyOptionsSchema.parse(options);
    if (payload.payload.domain !== domain) {
      throw new Error(`Expected domain '${domain}' does not match domain on payload '${payload.payload.domain}'`);
    }
    const currentTime = new Date();
    if (currentTime > new Date(payload.payload.expiration_time)) {
      throw new Error(`Login request has expired`);
    }
    if ((parsedOptions == null ? void 0 : parsedOptions.chainId) !== void 0 && parsedOptions.chainId !== payload.payload.chain_id) {
      throw new Error(`Chain ID '${parsedOptions.chainId}' does not match payload chain ID '${payload.payload.chain_id}'`);
    }
    const message = this.generateMessage(payload.payload);
    const userAddress = this.wallet.recoverAddress(message, payload.signature);
    if (userAddress.toLowerCase() !== payload.payload.address.toLowerCase()) {
      throw new Error(`Signer address '${userAddress.toLowerCase()}' does not match payload address '${payload.payload.address.toLowerCase()}'`);
    }
    return userAddress;
  }
  async generateAuthToken(domain, payload, options) {
    if (isBrowser3()) {
      throw new Error("Authentication tokens should not be generated in the browser, as they must be signed by a server-side admin wallet.");
    }
    const parsedOptions = AuthenticationOptionsSchema.parse(options);
    const userAddress = this.verify(domain, payload);
    const adminAddress = await this.wallet.getAddress();
    const payloadData = AuthenticationPayloadDataSchema.parse({
      iss: adminAddress,
      sub: userAddress,
      aud: domain,
      nbf: (parsedOptions == null ? void 0 : parsedOptions.invalidBefore) || new Date(),
      exp: (parsedOptions == null ? void 0 : parsedOptions.expirationTime) || new Date(Date.now() + 1e3 * 60 * 60 * 5),
      iat: new Date()
    });
    const message = JSON.stringify(payloadData);
    const signature = await this.wallet.sign(message);
    const header = {
      alg: "ES256",
      typ: "JWT"
    };
    const encodedHeader = Buffer.from(JSON.stringify(header)).toString("base64");
    const encodedData = Buffer.from(JSON.stringify(payloadData)).toString("base64").replace(/=/g, "");
    const encodedSignature = Buffer.from(signature).toString("base64");
    const token = `${encodedHeader}.${encodedData}.${encodedSignature}`;
    return token;
  }
  async authenticate(domain, token) {
    if (isBrowser3()) {
      throw new Error("Should not authenticate tokens in the browser, as they must be verified by the server-side admin wallet.");
    }
    const encodedPayload = token.split(".")[1];
    const encodedSignature = token.split(".")[2];
    const payload = JSON.parse(Buffer.from(encodedPayload, "base64").toString());
    const signature = Buffer.from(encodedSignature, "base64").toString();
    if (payload.aud !== domain) {
      throw new Error(`Expected token to be for the domain '${domain}', but found token with domain '${payload.aud}'`);
    }
    const currentTime = Math.floor(new Date().getTime() / 1e3);
    if (currentTime < payload.nbf) {
      throw new Error(`This token is invalid before epoch time '${payload.nbf}', current epoch time is '${currentTime}'`);
    }
    if (currentTime > payload.exp) {
      throw new Error(`This token expired at epoch time '${payload.exp}', current epoch time is '${currentTime}'`);
    }
    const connectedAddress = await this.wallet.getAddress();
    if (connectedAddress.toLowerCase() !== payload.iss.toLowerCase()) {
      throw new Error(`Expected the connected wallet address '${connectedAddress}' to match the token issuer address '${payload.iss}'`);
    }
    const adminAddress = this.wallet.recoverAddress(JSON.stringify(payload), signature);
    if (connectedAddress.toLowerCase() !== adminAddress.toLowerCase()) {
      throw new Error(`The connected wallet address '${connectedAddress}' did not sign the token`);
    }
    return payload.sub;
  }
  generateMessage(payload) {
    let message = ``;
    message += `${payload.domain} wants you to sign in with your account:
${payload.address}

`;
    message += `Make sure that the requesting domain above matches the URL of the current website.

`;
    if (payload.chain_id) {
      message += `Chain ID: ${payload.chain_id}
`;
    }
    message += `Nonce: ${payload.nonce}
`;
    message += `Expiration Time: ${payload.expiration_time}
`;
    return message;
  }
};
var ContractEncoder = class {
  constructor(contractWrapper) {
    _defineProperty(this, "contractWrapper", void 0);
    this.contractWrapper = contractWrapper;
  }
  encode(fn, args) {
    return this.contractWrapper.readContract.interface.encodeFunctionData(fn, args);
  }
  decode(fn, encodedArgs) {
    return this.contractWrapper.readContract.interface.decodeFunctionData(fn, encodedArgs);
  }
};
var ContractMetadata = class {
  constructor(contractWrapper, schema, storage) {
    _defineProperty(this, "featureName", FEATURE_METADATA.name);
    _defineProperty(this, "contractWrapper", void 0);
    _defineProperty(this, "schema", void 0);
    _defineProperty(this, "storage", void 0);
    this.contractWrapper = contractWrapper;
    this.schema = schema;
    this.storage = storage;
  }
  parseOutputMetadata(metadata) {
    return this.schema.output.parse(metadata);
  }
  parseInputMetadata(metadata) {
    return this.schema.input.parse(metadata);
  }
  async get() {
    let data;
    if (this.supportsContractMetadata(this.contractWrapper)) {
      const uri = await this.contractWrapper.readContract.contractURI();
      if (uri && uri.includes("://")) {
        data = await this.storage.downloadJSON(uri);
      }
    }
    if (!data) {
      try {
        let contractName;
        try {
          if (hasFunction("name", this.contractWrapper)) {
            contractName = await this.contractWrapper.readContract.name();
          }
        } catch (err) {
        }
        const publishedMetadata = await fetchContractMetadataFromAddress(this.contractWrapper.readContract.address, this.contractWrapper.getProvider(), this.storage);
        data = {
          name: contractName || publishedMetadata.name,
          description: publishedMetadata.info.title
        };
      } catch (e) {
        throw new Error("Could not fetch contract metadata");
      }
    }
    return this.parseOutputMetadata(data);
  }
  async set(metadata) {
    const uri = await this._parseAndUploadMetadata(metadata);
    const wrapper = this.contractWrapper;
    if (this.supportsContractMetadata(wrapper)) {
      const receipt = await wrapper.sendTransaction("setContractURI", [uri]);
      return {
        receipt,
        data: this.get
      };
    } else {
      throw new ExtensionNotImplementedError(FEATURE_METADATA);
    }
  }
  async update(metadata) {
    return await this.set({
      ...await this.get(),
      ...metadata
    });
  }
  async _parseAndUploadMetadata(metadata) {
    const parsedMetadata = this.parseInputMetadata(metadata);
    return this.storage.upload(parsedMetadata);
  }
  supportsContractMetadata(contractWrapper) {
    return detectContractFeature(contractWrapper, "ContractMetadata");
  }
};
var ContractRoles = class {
  constructor(contractWrapper, roles) {
    _defineProperty(this, "featureName", FEATURE_PERMISSIONS.name);
    _defineProperty(this, "contractWrapper", void 0);
    _defineProperty(this, "roles", void 0);
    this.contractWrapper = contractWrapper;
    this.roles = roles;
  }
  async getAll() {
    invariant(this.roles.length, "this contract has no support for roles");
    const roles = {};
    for (const role of this.roles) {
      roles[role] = await this.get(role);
    }
    return roles;
  }
  async get(role) {
    invariant(this.roles.includes(role), `this contract does not support the "${role}" role`);
    const wrapper = this.contractWrapper;
    if (hasFunction("getRoleMemberCount", wrapper) && hasFunction("getRoleMember", wrapper)) {
      const roleHash = getRoleHash(role);
      const count = (await wrapper.readContract.getRoleMemberCount(roleHash)).toNumber();
      return await Promise.all(Array.from(Array(count).keys()).map((i) => wrapper.readContract.getRoleMember(roleHash, i)));
    }
    throw new Error("Contract does not support enumerating roles. Please implement IPermissionsEnumerable to unlock this functionality.");
  }
  async setAll(rolesWithAddresses) {
    const roles = Object.keys(rolesWithAddresses);
    invariant(roles.length, "you must provide at least one role to set");
    invariant(roles.every((role) => this.roles.includes(role)), "this contract does not support the given role");
    const currentRoles = await this.getAll();
    const encoded = [];
    const sortedRoles = roles.sort((role) => role === "admin" ? 1 : -1);
    for (let i = 0; i < sortedRoles.length; i++) {
      const role = sortedRoles[i];
      const addresses = rolesWithAddresses[role] || [];
      const currentAddresses = currentRoles[role] || [];
      const toAdd = addresses.filter((address) => !currentAddresses.includes(address));
      const toRemove = currentAddresses.filter((address) => !addresses.includes(address));
      if (toAdd.length) {
        toAdd.forEach((address) => {
          encoded.push(this.contractWrapper.readContract.interface.encodeFunctionData("grantRole", [getRoleHash(role), address]));
        });
      }
      if (toRemove.length) {
        for (let j = 0; j < toRemove.length; j++) {
          const address = toRemove[j];
          const revokeFunctionName = await this.getRevokeRoleFunctionName(address);
          encoded.push(this.contractWrapper.readContract.interface.encodeFunctionData(revokeFunctionName, [getRoleHash(role), address]));
        }
      }
    }
    return {
      receipt: await this.contractWrapper.multiCall(encoded)
    };
  }
  async verify(roles, address) {
    await Promise.all(roles.map(async (role) => {
      const members = await this.get(role);
      if (!members.map((a) => a.toLowerCase()).includes(address.toLowerCase())) {
        throw new MissingRoleError(address, role);
      }
    }));
  }
  async grant(role, address) {
    invariant(this.roles.includes(role), `this contract does not support the "${role}" role`);
    return {
      receipt: await this.contractWrapper.sendTransaction("grantRole", [getRoleHash(role), address])
    };
  }
  async revoke(role, address) {
    invariant(this.roles.includes(role), `this contract does not support the "${role}" role`);
    const revokeFunctionName = await this.getRevokeRoleFunctionName(address);
    return {
      receipt: await this.contractWrapper.sendTransaction(revokeFunctionName, [getRoleHash(role), address])
    };
  }
  async getRevokeRoleFunctionName(address) {
    const signerAddress = await this.contractWrapper.getSignerAddress();
    if (signerAddress.toLowerCase() === address.toLowerCase()) {
      return "renounceRole";
    }
    return "revokeRole";
  }
};
var ContractRoyalty = class {
  constructor(contractWrapper, metadata) {
    _defineProperty(this, "featureName", FEATURE_ROYALTY.name);
    _defineProperty(this, "contractWrapper", void 0);
    _defineProperty(this, "metadata", void 0);
    this.contractWrapper = contractWrapper;
    this.metadata = metadata;
  }
  async getDefaultRoyaltyInfo() {
    const [royaltyRecipient, royaltyBps] = await this.contractWrapper.readContract.getDefaultRoyaltyInfo();
    return CommonRoyaltySchema.parse({
      fee_recipient: royaltyRecipient,
      seller_fee_basis_points: royaltyBps
    });
  }
  async getTokenRoyaltyInfo(tokenId) {
    const [royaltyRecipient, royaltyBps] = await this.contractWrapper.readContract.getRoyaltyInfoForToken(tokenId);
    return CommonRoyaltySchema.parse({
      fee_recipient: royaltyRecipient,
      seller_fee_basis_points: royaltyBps
    });
  }
  async setDefaultRoyaltyInfo(royaltyData) {
    const oldMetadata = await this.metadata.get();
    const mergedMetadata = this.metadata.parseInputMetadata({
      ...oldMetadata,
      ...royaltyData
    });
    const contractURI = await this.metadata._parseAndUploadMetadata(mergedMetadata);
    if (hasFunction("setContractURI", this.contractWrapper)) {
      const encoded = [this.contractWrapper.readContract.interface.encodeFunctionData("setDefaultRoyaltyInfo", [mergedMetadata.fee_recipient, mergedMetadata.seller_fee_basis_points]), this.contractWrapper.readContract.interface.encodeFunctionData("setContractURI", [contractURI])];
      return {
        receipt: await this.contractWrapper.multiCall(encoded),
        data: () => this.getDefaultRoyaltyInfo()
      };
    } else {
      throw new Error("Updating royalties requires implementing ContractMetadata in your contract to support marketplaces like OpenSea.");
    }
  }
  async setTokenRoyaltyInfo(tokenId, royaltyData) {
    return {
      receipt: await this.contractWrapper.sendTransaction("setRoyaltyInfoForToken", [tokenId, royaltyData.fee_recipient, royaltyData.seller_fee_basis_points]),
      data: () => this.getDefaultRoyaltyInfo()
    };
  }
};
var ContractPrimarySale = class {
  constructor(contractWrapper) {
    _defineProperty(this, "featureName", FEATURE_PRIMARY_SALE.name);
    _defineProperty(this, "contractWrapper", void 0);
    this.contractWrapper = contractWrapper;
  }
  async getRecipient() {
    return await this.contractWrapper.readContract.primarySaleRecipient();
  }
  async setRecipient(recipient) {
    return {
      receipt: await this.contractWrapper.sendTransaction("setPrimarySaleRecipient", [recipient])
    };
  }
};
var FALLBACK_METADATA = {
  name: "Failed to load NFT metadata"
};
async function fetchTokenMetadata(tokenId, tokenUri, storage) {
  const parsedUri = tokenUri.replace("{id}", ethers_exports.utils.hexZeroPad(BigNumber.from(tokenId).toHexString(), 32).slice(2));
  let jsonMetadata;
  try {
    jsonMetadata = await storage.downloadJSON(parsedUri);
  } catch (err) {
    const unparsedTokenIdUri = tokenUri.replace("{id}", BigNumber.from(tokenId).toString());
    try {
      jsonMetadata = await storage.downloadJSON(unparsedTokenIdUri);
    } catch (e) {
      console.warn(`failed to get token metadata: ${JSON.stringify({
        tokenId: tokenId.toString(),
        tokenUri
      })} -- falling back to default metadata`);
      jsonMetadata = FALLBACK_METADATA;
    }
  }
  return CommonNFTOutput.parse({
    ...jsonMetadata,
    id: BigNumber.from(tokenId).toString(),
    uri: tokenUri
  });
}
async function fetchTokenMetadataForContract(contractAddress, provider, tokenId, storage) {
  let uri;
  const erc165 = new Contract(contractAddress, IERC165_default, provider);
  const isERC721 = await erc165.supportsInterface(InterfaceId_IERC721);
  const isERC1155 = await erc165.supportsInterface(InterfaceId_IERC1155);
  if (isERC721) {
    const erc721 = new Contract(contractAddress, IERC721Metadata_default, provider);
    uri = await erc721.tokenURI(tokenId);
  } else if (isERC1155) {
    const erc1155 = new Contract(contractAddress, IERC1155Metadata_default, provider);
    uri = await erc1155.uri(tokenId);
  } else {
    throw Error("Contract must implement ERC 1155 or ERC 721.");
  }
  if (!uri) {
    throw new NotFoundError();
  }
  return fetchTokenMetadata(tokenId, uri, storage);
}
async function uploadOrExtractURI(metadata, storage) {
  if (typeof metadata === "string") {
    return metadata;
  } else {
    return await storage.upload(CommonNFTInput.parse(metadata));
  }
}
async function uploadOrExtractURIs(metadatas, storage, startNumber, options) {
  if (isUriList(metadatas)) {
    return metadatas;
  } else if (isMetadataList(metadatas)) {
    const uris = await storage.uploadBatch(metadatas.map((m) => CommonNFTInput.parse(m)), {
      rewriteFileNames: {
        fileStartNumber: startNumber || 0
      },
      onProgress: options == null ? void 0 : options.onProgress
    });
    return uris;
  } else {
    throw new Error("NFT metadatas must all be of the same type (all URI or all NFTMetadataInput)");
  }
}
function getBaseUriFromBatch(uris) {
  const baseUri = uris[0].substring(0, uris[0].lastIndexOf("/"));
  for (let i = 0; i < uris.length; i++) {
    const uri = uris[i].substring(0, uris[i].lastIndexOf("/"));
    if (baseUri !== uri) {
      throw new Error(`Can only create batches with the same base URI for every entry in the batch. Expected '${baseUri}' but got '${uri}'`);
    }
  }
  return baseUri.replace(/\/$/, "") + "/";
}
function isUriList(metadatas) {
  return metadatas.find((m) => typeof m !== "string") === void 0;
}
function isMetadataList(metadatas) {
  return metadatas.find((m) => typeof m !== "object") === void 0;
}
var DelayedReveal = class {
  constructor(contractWrapper, storage, fetureName, nextTokenIdToMintFn) {
    _defineProperty(this, "featureName", void 0);
    _defineProperty(this, "contractWrapper", void 0);
    _defineProperty(this, "storage", void 0);
    _defineProperty(this, "nextTokenIdToMintFn", void 0);
    this.featureName = fetureName;
    this.nextTokenIdToMintFn = nextTokenIdToMintFn;
    this.contractWrapper = contractWrapper;
    this.storage = storage;
  }
  async createDelayedRevealBatch(placeholder, metadatas, password, options) {
    if (!password) {
      throw new Error("Password is required");
    }
    const placeholderUris = await this.storage.uploadBatch([CommonNFTInput.parse(placeholder)], {
      rewriteFileNames: {
        fileStartNumber: 0
      }
    });
    const placeholderUri = getBaseUriFromBatch(placeholderUris);
    const startFileNumber = await this.nextTokenIdToMintFn();
    const uris = await this.storage.uploadBatch(metadatas.map((m) => CommonNFTInput.parse(m)), {
      onProgress: options == null ? void 0 : options.onProgress,
      rewriteFileNames: {
        fileStartNumber: startFileNumber.toNumber()
      }
    });
    const baseUri = getBaseUriFromBatch(uris);
    const baseUriId = await this.contractWrapper.readContract.getBaseURICount();
    const hashedPassword = await this.hashDelayRevealPasword(baseUriId, password);
    const encryptedBaseUri = await this.contractWrapper.readContract.encryptDecrypt(ethers_exports.utils.toUtf8Bytes(baseUri), hashedPassword);
    let data;
    const legacyContract = await this.isLegacyContract();
    if (legacyContract) {
      data = encryptedBaseUri;
    } else {
      const chainId = await this.contractWrapper.getChainID();
      const provenanceHash = ethers_exports.utils.solidityKeccak256(["bytes", "bytes", "uint256"], [ethers_exports.utils.toUtf8Bytes(baseUri), hashedPassword, chainId]);
      data = ethers_exports.utils.defaultAbiCoder.encode(["bytes", "bytes32"], [encryptedBaseUri, provenanceHash]);
    }
    const receipt = await this.contractWrapper.sendTransaction("lazyMint", [uris.length, placeholderUri.endsWith("/") ? placeholderUri : `${placeholderUri}/`, data]);
    const events = this.contractWrapper.parseLogs("TokensLazyMinted", receipt == null ? void 0 : receipt.logs);
    const startingIndex = events[0].args.startTokenId;
    const endingIndex = events[0].args.endTokenId;
    const results = [];
    for (let id = startingIndex; id.lte(endingIndex); id = id.add(1)) {
      results.push({
        id,
        receipt
      });
    }
    return results;
  }
  async reveal(batchId, password) {
    if (!password) {
      throw new Error("Password is required");
    }
    const key = await this.hashDelayRevealPasword(batchId, password);
    try {
      const decryptedUri = await this.contractWrapper.callStatic().reveal(batchId, key);
      if (!decryptedUri.includes("://") || !decryptedUri.endsWith("/")) {
        throw new Error("invalid password");
      }
    } catch (e) {
      throw new Error("invalid password");
    }
    return {
      receipt: await this.contractWrapper.sendTransaction("reveal", [batchId, key])
    };
  }
  async getBatchesToReveal() {
    const count = await this.contractWrapper.readContract.getBaseURICount();
    if (count.isZero()) {
      return [];
    }
    const countRangeArray = Array.from(Array(count.toNumber()).keys());
    const uriIndices = await Promise.all(countRangeArray.map((i) => {
      if (hasFunction("getBatchIdAtIndex", this.contractWrapper)) {
        return this.contractWrapper.readContract.getBatchIdAtIndex(i);
      }
      if (hasFunction("baseURIIndices", this.contractWrapper)) {
        return this.contractWrapper.readContract.baseURIIndices(i);
      }
      throw new Error("Contract does not have getBatchIdAtIndex or baseURIIndices.");
    }));
    const uriIndicesWithZeroStart = uriIndices.slice(0, uriIndices.length - 1);
    const tokenMetadatas = await Promise.all(Array.from([0, ...uriIndicesWithZeroStart]).map((i) => this.getNftMetadata(i.toString())));
    const legacyContract = await this.isLegacyContract();
    const encryptedUriData = await Promise.all(Array.from([...uriIndices]).map((i) => legacyContract ? this.getLegacyEncryptedData(i) : this.contractWrapper.readContract.encryptedData(i)));
    const encryptedBaseUris = encryptedUriData.map((data) => {
      if (ethers_exports.utils.hexDataLength(data) > 0) {
        if (legacyContract) {
          return data;
        }
        const result = ethers_exports.utils.defaultAbiCoder.decode(["bytes", "bytes32"], data);
        return result[0];
      } else {
        return data;
      }
    });
    return tokenMetadatas.map((meta, index) => ({
      batchId: BigNumber.from(index),
      batchUri: meta.uri,
      placeholderMetadata: meta
    })).filter((_, index) => ethers_exports.utils.hexDataLength(encryptedBaseUris[index]) > 0);
  }
  async hashDelayRevealPasword(batchTokenIndex, password) {
    const chainId = await this.contractWrapper.getChainID();
    const contractAddress = this.contractWrapper.readContract.address;
    return ethers_exports.utils.solidityKeccak256(["string", "uint256", "uint256", "address"], [password, chainId, batchTokenIndex, contractAddress]);
  }
  async getNftMetadata(tokenId) {
    return fetchTokenMetadataForContract(this.contractWrapper.readContract.address, this.contractWrapper.getProvider(), tokenId, this.storage);
  }
  async isLegacyContract() {
    if (hasFunction("contractVersion", this.contractWrapper)) {
      try {
        const version = await this.contractWrapper.readContract.contractVersion();
        return version <= 2;
      } catch (e) {
        return false;
      }
    }
    return false;
  }
  async getLegacyEncryptedData(index) {
    const legacy = new ethers_exports.Contract(this.contractWrapper.readContract.address, IDelayedRevealDeprecated_default, this.contractWrapper.getProvider());
    const result = await legacy.functions["encryptedBaseURI"](index);
    if (result.length > 0) {
      return result[0];
    } else {
      return "0x";
    }
  }
};
var ListingType;
(function(ListingType2) {
  ListingType2[ListingType2["Direct"] = 0] = "Direct";
  ListingType2[ListingType2["Auction"] = 1] = "Auction";
})(ListingType || (ListingType = {}));
var ProposalState;
(function(ProposalState2) {
  ProposalState2[ProposalState2["Pending"] = 0] = "Pending";
  ProposalState2[ProposalState2["Active"] = 1] = "Active";
  ProposalState2[ProposalState2["Canceled"] = 2] = "Canceled";
  ProposalState2[ProposalState2["Defeated"] = 3] = "Defeated";
  ProposalState2[ProposalState2["Succeeded"] = 4] = "Succeeded";
  ProposalState2[ProposalState2["Queued"] = 5] = "Queued";
  ProposalState2[ProposalState2["Expired"] = 6] = "Expired";
  ProposalState2[ProposalState2["Executed"] = 7] = "Executed";
})(ProposalState || (ProposalState = {}));
var VoteType;
(function(VoteType2) {
  VoteType2[VoteType2["Against"] = 0] = "Against";
  VoteType2[VoteType2["For"] = 1] = "For";
  VoteType2[VoteType2["Abstain"] = 2] = "Abstain";
})(VoteType || (VoteType = {}));
var ClaimEligibility;
(function(ClaimEligibility2) {
  ClaimEligibility2["NotEnoughSupply"] = "There is not enough supply to claim.";
  ClaimEligibility2["AddressNotAllowed"] = "This address is not on the allowlist.";
  ClaimEligibility2["WaitBeforeNextClaimTransaction"] = "Not enough time since last claim transaction. Please wait.";
  ClaimEligibility2["AlreadyClaimed"] = "You have already claimed the token.";
  ClaimEligibility2["NotEnoughTokens"] = "There are not enough tokens in the wallet to pay for the claim.";
  ClaimEligibility2["NoActiveClaimPhase"] = "There is no active claim phase at the moment. Please check back in later.";
  ClaimEligibility2["NoClaimConditionSet"] = "There is no claim condition set.";
  ClaimEligibility2["NoWallet"] = "No wallet connected.";
  ClaimEligibility2["Unknown"] = "No claim conditions found.";
})(ClaimEligibility || (ClaimEligibility = {}));
var GasCostEstimator = class {
  constructor(contractWrapper) {
    _defineProperty(this, "contractWrapper", void 0);
    this.contractWrapper = contractWrapper;
  }
  async gasCostOf(fn, args) {
    const price = await this.contractWrapper.getPreferredGasPrice();
    const gasUnits = await this.contractWrapper.estimateGas(fn, args);
    return ethers_exports.utils.formatEther(gasUnits.mul(price));
  }
  async gasLimitOf(fn, args) {
    return this.contractWrapper.estimateGas(fn, args);
  }
  async currentGasPriceInGwei() {
    const price = await this.contractWrapper.getProvider().getGasPrice();
    return ethers_exports.utils.formatUnits(price, "gwei");
  }
};
var TransactionTask = class {
  static make(taskArgs) {
    return new TransactionTask(taskArgs);
  }
  constructor(taskArgs) {
    _defineProperty(this, "contractWrapper", void 0);
    _defineProperty(this, "functionName", void 0);
    _defineProperty(this, "args", void 0);
    _defineProperty(this, "overrides", void 0);
    _defineProperty(this, "encoder", void 0);
    _defineProperty(this, "estimator", void 0);
    this.contractWrapper = taskArgs.contractWrapper;
    this.functionName = taskArgs.functionName;
    this.args = taskArgs.args || [];
    this.overrides = taskArgs.overrides;
    this.encoder = new ContractEncoder(this.contractWrapper);
    this.estimator = new GasCostEstimator(this.contractWrapper);
  }
  overrideGasLimit(gasLimit) {
    this.overrides = {
      ...this.overrides,
      gasLimit
    };
    return this;
  }
  overrideGasPrice(gasPrice) {
    this.overrides = {
      ...this.overrides,
      gasPrice
    };
    return this;
  }
  overrideNonce(nonce) {
    this.overrides = {
      ...this.overrides,
      nonce
    };
    return this;
  }
  overrideValue(value) {
    this.overrides = {
      ...this.overrides,
      value
    };
    return this;
  }
  async estimateGasLimit() {
    return await this.estimator.gasLimitOf(this.functionName, this.args);
  }
  async estimateGasCostInEther() {
    return await this.estimator.gasCostOf(this.functionName, this.args);
  }
  async encodeFunctionData() {
    return this.encoder.encode(this.functionName, this.args);
  }
  async submit() {
    return await this.contractWrapper.sendTransactionByFunction(this.functionName, this.args, this.overrides || {});
  }
  async execute() {
    const receipt = await this.contractWrapper.sendTransaction(this.functionName, this.args, this.overrides || {});
    return {
      receipt
    };
  }
};
var DropClaimConditions = class {
  constructor(contractWrapper, metadata, storage) {
    _defineProperty(this, "contractWrapper", void 0);
    _defineProperty(this, "metadata", void 0);
    _defineProperty(this, "storage", void 0);
    this.storage = storage;
    this.contractWrapper = contractWrapper;
    this.metadata = metadata;
  }
  async getActive(options) {
    const cc = await this.get();
    const metadata = await this.metadata.get();
    return await transformResultToClaimCondition(cc, await this.getTokenDecimals(), this.contractWrapper.getProvider(), metadata.merkle || {}, this.storage, (options == null ? void 0 : options.withAllowList) || false);
  }
  async get(conditionId) {
    if (this.isLegacySinglePhaseDrop(this.contractWrapper)) {
      const contractModel = await this.contractWrapper.readContract.claimCondition();
      return legacyContractModelToAbstract(contractModel);
    } else if (this.isLegacyMultiPhaseDrop(this.contractWrapper)) {
      const id = conditionId !== void 0 ? conditionId : await this.contractWrapper.readContract.getActiveClaimConditionId();
      const contractModel = await this.contractWrapper.readContract.getClaimConditionById(id);
      return legacyContractModelToAbstract(contractModel);
    } else if (this.isNewSinglePhaseDrop(this.contractWrapper)) {
      const contractModel = await this.contractWrapper.readContract.claimCondition();
      return newContractModelToAbstract(contractModel);
    } else if (this.isNewMultiphaseDrop(this.contractWrapper)) {
      const id = conditionId !== void 0 ? conditionId : await this.contractWrapper.readContract.getActiveClaimConditionId();
      const contractModel = await this.contractWrapper.readContract.getClaimConditionById(id);
      return newContractModelToAbstract(contractModel);
    } else {
      throw new Error("Contract does not support claim conditions");
    }
  }
  async getAll(options) {
    if (this.isLegacyMultiPhaseDrop(this.contractWrapper) || this.isNewMultiphaseDrop(this.contractWrapper)) {
      const claimCondition = await this.contractWrapper.readContract.claimCondition();
      const startId = claimCondition.currentStartId.toNumber();
      const count = claimCondition.count.toNumber();
      const conditions = [];
      for (let i = startId; i < startId + count; i++) {
        conditions.push(await this.get(i));
      }
      const metadata = await this.metadata.get();
      const decimals = await this.getTokenDecimals();
      return Promise.all(conditions.map((c) => transformResultToClaimCondition(c, decimals, this.contractWrapper.getProvider(), metadata.merkle, this.storage, (options == null ? void 0 : options.withAllowList) || false)));
    } else {
      return [await this.getActive(options)];
    }
  }
  async canClaim(quantity, addressToCheck) {
    return (await this.getClaimIneligibilityReasons(quantity, addressToCheck)).length === 0;
  }
  async getClaimIneligibilityReasons(quantity, addressToCheck) {
    const reasons = [];
    let activeConditionIndex;
    let claimCondition;
    const decimals = await this.getTokenDecimals();
    const quantityWithDecimals = ethers_exports.utils.parseUnits(AmountSchema.parse(quantity), decimals);
    if (addressToCheck === void 0) {
      try {
        addressToCheck = await this.contractWrapper.getSignerAddress();
      } catch (err) {
        console.warn("failed to get signer address", err);
      }
    }
    if (!addressToCheck) {
      return [ClaimEligibility.NoWallet];
    }
    try {
      claimCondition = await this.getActive();
    } catch (err) {
      if (includesErrorMessage(err, "!CONDITION") || includesErrorMessage(err, "no active mint condition")) {
        reasons.push(ClaimEligibility.NoClaimConditionSet);
        return reasons;
      }
      console.warn("failed to get active claim condition", err);
      reasons.push(ClaimEligibility.Unknown);
      return reasons;
    }
    if (claimCondition.availableSupply !== "unlimited") {
      const supplyWithDecimals = ethers_exports.utils.parseUnits(claimCondition.availableSupply, decimals);
      if (supplyWithDecimals.lt(quantityWithDecimals)) {
        reasons.push(ClaimEligibility.NotEnoughSupply);
      }
    }
    const merkleRootArray = ethers_exports.utils.stripZeros(claimCondition.merkleRootHash);
    const hasAllowList = merkleRootArray.length > 0;
    let allowListEntry = null;
    if (hasAllowList) {
      allowListEntry = await this.getClaimerProofs(addressToCheck);
      if (!allowListEntry && (this.isLegacySinglePhaseDrop(this.contractWrapper) || this.isLegacyMultiPhaseDrop(this.contractWrapper))) {
        reasons.push(ClaimEligibility.AddressNotAllowed);
        return reasons;
      }
      if (allowListEntry) {
        try {
          const claimVerification = await this.prepareClaim(quantity, false, decimals, addressToCheck);
          let validMerkleProof;
          if (this.isLegacyMultiPhaseDrop(this.contractWrapper)) {
            activeConditionIndex = await this.contractWrapper.readContract.getActiveClaimConditionId();
            [validMerkleProof] = await this.contractWrapper.readContract.verifyClaimMerkleProof(activeConditionIndex, addressToCheck, quantity, claimVerification.proofs, claimVerification.maxClaimable);
            if (!validMerkleProof) {
              reasons.push(ClaimEligibility.AddressNotAllowed);
              return reasons;
            }
          } else if (this.isLegacySinglePhaseDrop(this.contractWrapper)) {
            [validMerkleProof] = await this.contractWrapper.readContract.verifyClaimMerkleProof(addressToCheck, quantity, {
              proof: claimVerification.proofs,
              maxQuantityInAllowlist: claimVerification.maxClaimable
            });
            if (!validMerkleProof) {
              reasons.push(ClaimEligibility.AddressNotAllowed);
              return reasons;
            }
          } else if (this.isNewSinglePhaseDrop(this.contractWrapper)) {
            await this.contractWrapper.readContract.verifyClaim(addressToCheck, quantity, claimVerification.currencyAddress, claimVerification.price, {
              proof: claimVerification.proofs,
              quantityLimitPerWallet: claimVerification.maxClaimable,
              currency: claimVerification.currencyAddressInProof,
              pricePerToken: claimVerification.priceInProof
            });
            if (convertQuantityToBigNumber(claimCondition.maxClaimablePerWallet, decimals).eq(0) && claimVerification.maxClaimable === ethers_exports.constants.MaxUint256 || claimVerification.maxClaimable === BigNumber.from(0)) {
              reasons.push(ClaimEligibility.AddressNotAllowed);
              return reasons;
            }
          } else if (this.isNewMultiphaseDrop(this.contractWrapper)) {
            activeConditionIndex = await this.contractWrapper.readContract.getActiveClaimConditionId();
            await this.contractWrapper.readContract.verifyClaim(activeConditionIndex, addressToCheck, quantity, claimVerification.currencyAddress, claimVerification.price, {
              proof: claimVerification.proofs,
              quantityLimitPerWallet: claimVerification.maxClaimable,
              currency: claimVerification.currencyAddressInProof,
              pricePerToken: claimVerification.priceInProof
            });
            if (convertQuantityToBigNumber(claimCondition.maxClaimablePerWallet, decimals).eq(0) && claimVerification.maxClaimable === ethers_exports.constants.MaxUint256 || claimVerification.maxClaimable === BigNumber.from(0)) {
              reasons.push(ClaimEligibility.AddressNotAllowed);
              return reasons;
            }
          }
        } catch (e) {
          console.warn("Merkle proof verification failed:", "reason" in e ? e.reason : e);
          reasons.push(ClaimEligibility.AddressNotAllowed);
          return reasons;
        }
      }
    }
    if (this.isNewSinglePhaseDrop(this.contractWrapper) || this.isNewMultiphaseDrop(this.contractWrapper)) {
      if (!hasAllowList || hasAllowList && !allowListEntry) {
        if (convertQuantityToBigNumber(claimCondition.maxClaimablePerWallet, decimals).eq(0)) {
          reasons.push(ClaimEligibility.AddressNotAllowed);
          return reasons;
        }
      }
    }
    if (this.isLegacySinglePhaseDrop(this.contractWrapper) || this.isLegacyMultiPhaseDrop(this.contractWrapper)) {
      let [lastClaimedTimestamp, timestampForNextClaim] = [BigNumber.from(0), BigNumber.from(0)];
      if (this.isLegacyMultiPhaseDrop(this.contractWrapper)) {
        activeConditionIndex = await this.contractWrapper.readContract.getActiveClaimConditionId();
        [lastClaimedTimestamp, timestampForNextClaim] = await this.contractWrapper.readContract.getClaimTimestamp(activeConditionIndex, addressToCheck);
      } else if (this.isLegacySinglePhaseDrop(this.contractWrapper)) {
        [lastClaimedTimestamp, timestampForNextClaim] = await this.contractWrapper.readContract.getClaimTimestamp(addressToCheck);
      }
      const now = BigNumber.from(Date.now()).div(1e3);
      if (lastClaimedTimestamp.gt(0) && now.lt(timestampForNextClaim)) {
        if (timestampForNextClaim.eq(lib_exports.MaxUint256)) {
          reasons.push(ClaimEligibility.AlreadyClaimed);
        } else {
          reasons.push(ClaimEligibility.WaitBeforeNextClaimTransaction);
        }
      }
    }
    if (claimCondition.price.gt(0) && isNode()) {
      const totalPrice = claimCondition.price.mul(BigNumber.from(quantity));
      const provider = this.contractWrapper.getProvider();
      if (isNativeToken(claimCondition.currencyAddress)) {
        const balance = await provider.getBalance(addressToCheck);
        if (balance.lt(totalPrice)) {
          reasons.push(ClaimEligibility.NotEnoughTokens);
        }
      } else {
        const erc20 = new ContractWrapper(provider, claimCondition.currencyAddress, IERC20_default, {});
        const balance = await erc20.readContract.balanceOf(addressToCheck);
        if (balance.lt(totalPrice)) {
          reasons.push(ClaimEligibility.NotEnoughTokens);
        }
      }
    }
    return reasons;
  }
  async getClaimerProofs(claimerAddress, claimConditionId) {
    const claimCondition = await this.get(claimConditionId);
    const merkleRoot = claimCondition.merkleRoot;
    const merkleRootArray = ethers_exports.utils.stripZeros(merkleRoot);
    if (merkleRootArray.length > 0) {
      const metadata = await this.metadata.get();
      return await fetchSnapshotEntryForAddress(claimerAddress, merkleRoot.toString(), metadata.merkle, this.contractWrapper.getProvider(), this.storage, this.getSnapshotFormatVersion());
    } else {
      return null;
    }
  }
  async set(claimConditionInputs) {
    let resetClaimEligibilityForAll = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
    let claimConditionsProcessed = claimConditionInputs;
    if (this.isLegacySinglePhaseDrop(this.contractWrapper) || this.isNewSinglePhaseDrop(this.contractWrapper)) {
      resetClaimEligibilityForAll = true;
      if (claimConditionInputs.length === 0) {
        claimConditionsProcessed = [{
          startTime: new Date(0),
          currencyAddress: ethers_exports.constants.AddressZero,
          price: 0,
          maxClaimableSupply: 0,
          maxClaimablePerWallet: 0,
          waitInSeconds: 0,
          merkleRootHash: utils_exports.hexZeroPad([0], 32),
          snapshot: []
        }];
      } else if (claimConditionInputs.length > 1) {
        throw new Error("Single phase drop contract cannot have multiple claim conditions, only one is allowed");
      }
    }
    if (this.isNewSinglePhaseDrop(this.contractWrapper) || this.isNewMultiphaseDrop(this.contractWrapper)) {
      claimConditionsProcessed.forEach((cc) => {
        var _a;
        if (cc.snapshot && cc.snapshot.length > 0 && (cc.maxClaimablePerWallet === void 0 || cc.maxClaimablePerWallet === "unlimited")) {
          throw new Error("maxClaimablePerWallet must be set to a specific value when an allowlist is set.\nExample: Set it to 0 to only allow addresses in the allowlist to claim the amount specified in the allowlist.\ncontract.claimConditions.set([{ snapshot: [{ address: '0x...', maxClaimable: 1 }], maxClaimablePerWallet: 0 }])");
        }
        if (cc.snapshot && cc.snapshot.length > 0 && ((_a = cc.maxClaimablePerWallet) == null ? void 0 : _a.toString()) === "0" && cc.snapshot.map((s) => {
          var _a2;
          if (typeof s === "string") {
            return 0;
          } else {
            return Number(((_a2 = s.maxClaimable) == null ? void 0 : _a2.toString()) || 0);
          }
        }).reduce((acc, current) => {
          return acc + current;
        }, 0) === 0) {
          throw new Error("maxClaimablePerWallet is set to 0, and all addresses in the allowlist have max claimable 0. This means that no one can claim.");
        }
      });
    }
    const {
      snapshotInfos,
      sortedConditions
    } = await processClaimConditionInputs(claimConditionsProcessed, await this.getTokenDecimals(), this.contractWrapper.getProvider(), this.storage, this.getSnapshotFormatVersion());
    const merkleInfo = {};
    snapshotInfos.forEach((s) => {
      merkleInfo[s.merkleRoot] = s.snapshotUri;
    });
    const metadata = await this.metadata.get();
    const encoded = [];
    if (!(0, import_fast_deep_equal.default)(metadata.merkle, merkleInfo)) {
      const mergedMetadata = this.metadata.parseInputMetadata({
        ...metadata,
        merkle: merkleInfo
      });
      const contractURI = await this.metadata._parseAndUploadMetadata(mergedMetadata);
      if (hasFunction("setContractURI", this.contractWrapper)) {
        encoded.push(this.contractWrapper.readContract.interface.encodeFunctionData("setContractURI", [contractURI]));
      } else {
        throw new Error("Setting a merkle root requires implementing ContractMetadata in your contract to support storing a merkle root.");
      }
    }
    const cw = this.contractWrapper;
    if (this.isLegacySinglePhaseDrop(cw)) {
      encoded.push(cw.readContract.interface.encodeFunctionData("setClaimConditions", [abstractContractModelToLegacy(sortedConditions[0]), resetClaimEligibilityForAll]));
    } else if (this.isLegacyMultiPhaseDrop(cw)) {
      encoded.push(cw.readContract.interface.encodeFunctionData("setClaimConditions", [sortedConditions.map(abstractContractModelToLegacy), resetClaimEligibilityForAll]));
    } else if (this.isNewSinglePhaseDrop(cw)) {
      encoded.push(cw.readContract.interface.encodeFunctionData("setClaimConditions", [abstractContractModelToNew(sortedConditions[0]), resetClaimEligibilityForAll]));
    } else if (this.isNewMultiphaseDrop(cw)) {
      encoded.push(cw.readContract.interface.encodeFunctionData("setClaimConditions", [sortedConditions.map(abstractContractModelToNew), resetClaimEligibilityForAll]));
    } else {
      throw new Error("Contract does not support claim conditions");
    }
    return {
      receipt: await this.contractWrapper.multiCall(encoded)
    };
  }
  async update(index, claimConditionInput) {
    const existingConditions = await this.getAll();
    const newConditionInputs = await updateExistingClaimConditions(index, claimConditionInput, existingConditions);
    return await this.set(newConditionInputs);
  }
  async getTokenDecimals() {
    if (detectContractFeature(this.contractWrapper, "ERC20")) {
      return this.contractWrapper.readContract.decimals();
    } else {
      return Promise.resolve(0);
    }
  }
  async prepareClaim(quantity, checkERC20Allowance) {
    let decimals = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0;
    let address = arguments.length > 3 ? arguments[3] : void 0;
    const addressToClaim = address ? address : await this.contractWrapper.getSignerAddress();
    return prepareClaim(addressToClaim, quantity, await this.getActive(), async () => (await this.metadata.get()).merkle, decimals, this.contractWrapper, this.storage, checkERC20Allowance, this.getSnapshotFormatVersion());
  }
  async getClaimArguments(destinationAddress, quantity, claimVerification) {
    if (this.isLegacyMultiPhaseDrop(this.contractWrapper)) {
      return [destinationAddress, quantity, claimVerification.currencyAddress, claimVerification.price, claimVerification.proofs, claimVerification.maxClaimable];
    } else if (this.isLegacySinglePhaseDrop(this.contractWrapper)) {
      return [destinationAddress, quantity, claimVerification.currencyAddress, claimVerification.price, {
        proof: claimVerification.proofs,
        maxQuantityInAllowlist: claimVerification.maxClaimable
      }, ethers_exports.utils.toUtf8Bytes("")];
    }
    return [destinationAddress, quantity, claimVerification.currencyAddress, claimVerification.price, {
      proof: claimVerification.proofs,
      quantityLimitPerWallet: claimVerification.maxClaimable,
      pricePerToken: claimVerification.priceInProof,
      currency: claimVerification.currencyAddressInProof
    }, ethers_exports.utils.toUtf8Bytes("")];
  }
  async getClaimTransaction(destinationAddress, quantity, options) {
    if (options == null ? void 0 : options.pricePerToken) {
      throw new Error("Price per token is be set via claim conditions by calling `contract.erc721.claimConditions.set()`");
    }
    const claimVerification = await this.prepareClaim(quantity, (options == null ? void 0 : options.checkERC20Allowance) === void 0 ? true : options.checkERC20Allowance, await this.getTokenDecimals());
    return TransactionTask.make({
      contractWrapper: this.contractWrapper,
      functionName: "claim",
      args: await this.getClaimArguments(destinationAddress, quantity, claimVerification),
      overrides: claimVerification.overrides
    });
  }
  isNewSinglePhaseDrop(contractWrapper) {
    return detectContractFeature(contractWrapper, "ERC721ClaimConditionsV2") || detectContractFeature(contractWrapper, "ERC20ClaimConditionsV2");
  }
  isNewMultiphaseDrop(contractWrapper) {
    return detectContractFeature(contractWrapper, "ERC721ClaimPhasesV2") || detectContractFeature(contractWrapper, "ERC20ClaimPhasesV2");
  }
  isLegacySinglePhaseDrop(contractWrapper) {
    return detectContractFeature(contractWrapper, "ERC721ClaimConditionsV1") || detectContractFeature(contractWrapper, "ERC20ClaimConditionsV1");
  }
  isLegacyMultiPhaseDrop(contractWrapper) {
    return detectContractFeature(contractWrapper, "ERC721ClaimPhasesV1") || detectContractFeature(contractWrapper, "ERC20ClaimPhasesV1");
  }
  getSnapshotFormatVersion() {
    return this.isLegacyMultiPhaseDrop(this.contractWrapper) || this.isLegacySinglePhaseDrop(this.contractWrapper) ? SnapshotFormatVersion.V1 : SnapshotFormatVersion.V2;
  }
};
var DropErc1155ClaimConditions = class {
  constructor(contractWrapper, metadata, storage) {
    _defineProperty(this, "contractWrapper", void 0);
    _defineProperty(this, "metadata", void 0);
    _defineProperty(this, "storage", void 0);
    this.storage = storage;
    this.contractWrapper = contractWrapper;
    this.metadata = metadata;
  }
  async getActive(tokenId, options) {
    const mc = await this.get(tokenId);
    const metadata = await this.metadata.get();
    return await transformResultToClaimCondition(mc, 0, this.contractWrapper.getProvider(), metadata.merkle, this.storage, (options == null ? void 0 : options.withAllowList) || false);
  }
  async get(tokenId, conditionId) {
    if (this.isLegacySinglePhaseDrop(this.contractWrapper)) {
      const contractModel = await this.contractWrapper.readContract.claimCondition(tokenId);
      return legacyContractModelToAbstract(contractModel);
    } else if (this.isLegacyMultiPhaseDrop(this.contractWrapper)) {
      const id = conditionId !== void 0 ? conditionId : await this.contractWrapper.readContract.getActiveClaimConditionId(tokenId);
      const contractModel = await this.contractWrapper.readContract.getClaimConditionById(tokenId, id);
      return legacyContractModelToAbstract(contractModel);
    } else if (this.isNewSinglePhaseDrop(this.contractWrapper)) {
      const contractModel = await this.contractWrapper.readContract.claimCondition(tokenId);
      return newContractModelToAbstract(contractModel);
    } else if (this.isNewMultiphaseDrop(this.contractWrapper)) {
      const id = conditionId !== void 0 ? conditionId : await this.contractWrapper.readContract.getActiveClaimConditionId(tokenId);
      const contractModel = await this.contractWrapper.readContract.getClaimConditionById(tokenId, id);
      return newContractModelToAbstract(contractModel);
    } else {
      throw new Error("Contract does not support claim conditions");
    }
  }
  async getAll(tokenId, options) {
    if (this.isLegacyMultiPhaseDrop(this.contractWrapper) || this.isNewMultiphaseDrop(this.contractWrapper)) {
      const claimCondition = await this.contractWrapper.readContract.claimCondition(tokenId);
      const startId = claimCondition.currentStartId.toNumber();
      const count = claimCondition.count.toNumber();
      const conditions = [];
      for (let i = startId; i < startId + count; i++) {
        conditions.push(await this.get(tokenId, i));
      }
      const metadata = await this.metadata.get();
      return Promise.all(conditions.map((c) => transformResultToClaimCondition(c, 0, this.contractWrapper.getProvider(), metadata.merkle, this.storage, (options == null ? void 0 : options.withAllowList) || false)));
    } else {
      return [await this.getActive(tokenId, options)];
    }
  }
  async canClaim(tokenId, quantity, addressToCheck) {
    return (await this.getClaimIneligibilityReasons(tokenId, quantity, addressToCheck)).length === 0;
  }
  async getClaimIneligibilityReasons(tokenId, quantity, addressToCheck) {
    const reasons = [];
    let activeConditionIndex;
    let claimCondition;
    if (addressToCheck === void 0) {
      try {
        addressToCheck = await this.contractWrapper.getSignerAddress();
      } catch (err) {
        console.warn("failed to get signer address", err);
      }
    }
    if (!addressToCheck) {
      return [ClaimEligibility.NoWallet];
    }
    try {
      claimCondition = await this.getActive(tokenId);
    } catch (err) {
      if (includesErrorMessage(err, "!CONDITION") || includesErrorMessage(err, "no active mint condition")) {
        reasons.push(ClaimEligibility.NoClaimConditionSet);
        return reasons;
      }
      reasons.push(ClaimEligibility.Unknown);
      return reasons;
    }
    if (claimCondition.availableSupply !== "unlimited") {
      if (BigNumber.from(claimCondition.availableSupply).lt(quantity)) {
        reasons.push(ClaimEligibility.NotEnoughSupply);
      }
    }
    const merkleRootArray = ethers_exports.utils.stripZeros(claimCondition.merkleRootHash);
    const hasAllowList = merkleRootArray.length > 0;
    let allowListEntry = null;
    if (hasAllowList) {
      allowListEntry = await this.getClaimerProofs(tokenId, addressToCheck);
      if (!allowListEntry && (this.isLegacySinglePhaseDrop(this.contractWrapper) || this.isLegacyMultiPhaseDrop(this.contractWrapper))) {
        reasons.push(ClaimEligibility.AddressNotAllowed);
        return reasons;
      }
      if (allowListEntry) {
        try {
          const claimVerification = await this.prepareClaim(tokenId, quantity, false, addressToCheck);
          let validMerkleProof;
          if (this.isLegacyMultiPhaseDrop(this.contractWrapper)) {
            activeConditionIndex = await this.contractWrapper.readContract.getActiveClaimConditionId(tokenId);
            [validMerkleProof] = await this.contractWrapper.readContract.verifyClaimMerkleProof(activeConditionIndex, addressToCheck, tokenId, quantity, claimVerification.proofs, claimVerification.maxClaimable);
            if (!validMerkleProof) {
              reasons.push(ClaimEligibility.AddressNotAllowed);
              return reasons;
            }
          } else if (this.isLegacySinglePhaseDrop(this.contractWrapper)) {
            [validMerkleProof] = await this.contractWrapper.readContract.verifyClaimMerkleProof(tokenId, addressToCheck, quantity, {
              proof: claimVerification.proofs,
              maxQuantityInAllowlist: claimVerification.maxClaimable
            });
            if (!validMerkleProof) {
              reasons.push(ClaimEligibility.AddressNotAllowed);
              return reasons;
            }
          } else if (this.isNewSinglePhaseDrop(this.contractWrapper)) {
            await this.contractWrapper.readContract.verifyClaim(tokenId, addressToCheck, quantity, claimVerification.currencyAddress, claimVerification.price, {
              proof: claimVerification.proofs,
              quantityLimitPerWallet: claimVerification.maxClaimable,
              currency: claimVerification.currencyAddressInProof,
              pricePerToken: claimVerification.priceInProof
            });
            if (claimCondition.maxClaimablePerWallet === "0" && claimVerification.maxClaimable === ethers_exports.constants.MaxUint256 || claimVerification.maxClaimable === BigNumber.from(0)) {
              reasons.push(ClaimEligibility.AddressNotAllowed);
              return reasons;
            }
          } else if (this.isNewMultiphaseDrop(this.contractWrapper)) {
            activeConditionIndex = await this.contractWrapper.readContract.getActiveClaimConditionId(tokenId);
            await this.contractWrapper.readContract.verifyClaim(activeConditionIndex, addressToCheck, tokenId, quantity, claimVerification.currencyAddress, claimVerification.price, {
              proof: claimVerification.proofs,
              quantityLimitPerWallet: claimVerification.maxClaimable,
              currency: claimVerification.currencyAddressInProof,
              pricePerToken: claimVerification.priceInProof
            });
            if (claimCondition.maxClaimablePerWallet === "0" && claimVerification.maxClaimable === ethers_exports.constants.MaxUint256 || claimVerification.maxClaimable === BigNumber.from(0)) {
              reasons.push(ClaimEligibility.AddressNotAllowed);
              return reasons;
            }
          }
        } catch (e) {
          console.warn("Merkle proof verification failed:", "reason" in e ? e.reason : e);
          reasons.push(ClaimEligibility.AddressNotAllowed);
          return reasons;
        }
      }
    }
    if (this.isNewSinglePhaseDrop(this.contractWrapper) || this.isNewMultiphaseDrop(this.contractWrapper)) {
      if (!hasAllowList || hasAllowList && !allowListEntry) {
        if (claimCondition.maxClaimablePerWallet === "0") {
          reasons.push(ClaimEligibility.AddressNotAllowed);
          return reasons;
        }
      }
    }
    let [lastClaimedTimestamp, timestampForNextClaim] = [BigNumber.from(0), BigNumber.from(0)];
    if (this.isLegacyMultiPhaseDrop(this.contractWrapper)) {
      activeConditionIndex = await this.contractWrapper.readContract.getActiveClaimConditionId(tokenId);
      [lastClaimedTimestamp, timestampForNextClaim] = await this.contractWrapper.readContract.getClaimTimestamp(tokenId, activeConditionIndex, addressToCheck);
    } else if (this.isLegacySinglePhaseDrop(this.contractWrapper)) {
      [lastClaimedTimestamp, timestampForNextClaim] = await this.contractWrapper.readContract.getClaimTimestamp(tokenId, addressToCheck);
    }
    const now = BigNumber.from(Date.now()).div(1e3);
    if (lastClaimedTimestamp.gt(0) && now.lt(timestampForNextClaim)) {
      if (timestampForNextClaim.eq(lib_exports.MaxUint256)) {
        reasons.push(ClaimEligibility.AlreadyClaimed);
      } else {
        reasons.push(ClaimEligibility.WaitBeforeNextClaimTransaction);
      }
    }
    if (claimCondition.price.gt(0) && isNode()) {
      const totalPrice = claimCondition.price.mul(quantity);
      const provider = this.contractWrapper.getProvider();
      if (isNativeToken(claimCondition.currencyAddress)) {
        const balance = await provider.getBalance(addressToCheck);
        if (balance.lt(totalPrice)) {
          reasons.push(ClaimEligibility.NotEnoughTokens);
        }
      } else {
        const erc20 = new ContractWrapper(provider, claimCondition.currencyAddress, IERC20_default, {});
        const balance = await erc20.readContract.balanceOf(addressToCheck);
        if (balance.lt(totalPrice)) {
          reasons.push(ClaimEligibility.NotEnoughTokens);
        }
      }
    }
    return reasons;
  }
  async getClaimerProofs(tokenId, claimerAddress, claimConditionId) {
    const claimCondition = await this.get(tokenId, claimConditionId);
    const merkleRoot = claimCondition.merkleRoot;
    const merkleRootArray = ethers_exports.utils.stripZeros(merkleRoot);
    if (merkleRootArray.length > 0) {
      const metadata = await this.metadata.get();
      return await fetchSnapshotEntryForAddress(claimerAddress, merkleRoot.toString(), metadata.merkle, this.contractWrapper.getProvider(), this.storage, this.getSnapshotFormatVersion());
    } else {
      return null;
    }
  }
  async set(tokenId, claimConditionInputs) {
    let resetClaimEligibilityForAll = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
    return this.setBatch([{
      tokenId,
      claimConditions: claimConditionInputs
    }], resetClaimEligibilityForAll);
  }
  async setBatch(claimConditionsForToken) {
    let resetClaimEligibilityForAll = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
    const merkleInfo = {};
    const processedClaimConditions = await Promise.all(claimConditionsForToken.map(async (_ref) => {
      let {
        tokenId,
        claimConditions
      } = _ref;
      let claimConditionsProcessed = claimConditions;
      if (this.isLegacySinglePhaseDrop(this.contractWrapper)) {
        resetClaimEligibilityForAll = true;
        if (claimConditions.length === 0) {
          claimConditionsProcessed = [{
            startTime: new Date(0),
            currencyAddress: ethers_exports.constants.AddressZero,
            price: 0,
            maxClaimableSupply: 0,
            maxClaimablePerWallet: 0,
            waitInSeconds: 0,
            merkleRootHash: utils_exports.hexZeroPad([0], 32),
            snapshot: []
          }];
        } else if (claimConditions.length > 1) {
          throw new Error("Single phase drop contract cannot have multiple claim conditions, only one is allowed");
        }
      }
      if (this.isNewSinglePhaseDrop(this.contractWrapper) || this.isNewMultiphaseDrop(this.contractWrapper)) {
        claimConditionsProcessed.forEach((cc) => {
          var _a;
          if (cc.snapshot && cc.snapshot.length > 0 && (cc.maxClaimablePerWallet === void 0 || cc.maxClaimablePerWallet === "unlimited")) {
            throw new Error("maxClaimablePerWallet must be set to a specific value when an allowlist is set.\nSet it to 0 to only allow addresses in the allowlist to claim the amount specified in the allowlist.\n\nex:\ncontract.claimConditions.set(tokenId, [{ snapshot: [{ address: '0x...', maxClaimable: 1 }], maxClaimablePerWallet: 0 }])");
          }
          if (cc.snapshot && cc.snapshot.length > 0 && ((_a = cc.maxClaimablePerWallet) == null ? void 0 : _a.toString()) === "0" && cc.snapshot.map((s) => {
            var _a2;
            if (typeof s === "string") {
              return 0;
            } else {
              return Number(((_a2 = s.maxClaimable) == null ? void 0 : _a2.toString()) || 0);
            }
          }).reduce((acc, current) => {
            return acc + current;
          }, 0) === 0) {
            throw new Error("maxClaimablePerWallet is set to 0, and all addresses in the allowlist have max claimable 0. This means that no one can claim.");
          }
        });
      }
      const {
        snapshotInfos,
        sortedConditions
      } = await processClaimConditionInputs(claimConditionsProcessed, 0, this.contractWrapper.getProvider(), this.storage, this.getSnapshotFormatVersion());
      snapshotInfos.forEach((s) => {
        merkleInfo[s.merkleRoot] = s.snapshotUri;
      });
      return {
        tokenId,
        sortedConditions
      };
    }));
    const metadata = await this.metadata.get();
    const encoded = [];
    for (const key of Object.keys(metadata.merkle || {})) {
      merkleInfo[key] = metadata.merkle[key];
    }
    if (!(0, import_fast_deep_equal.default)(metadata.merkle, merkleInfo)) {
      const mergedMetadata = this.metadata.parseInputMetadata({
        ...metadata,
        merkle: merkleInfo
      });
      const contractURI = await this.metadata._parseAndUploadMetadata(mergedMetadata);
      if (hasFunction("setContractURI", this.contractWrapper)) {
        encoded.push(this.contractWrapper.readContract.interface.encodeFunctionData("setContractURI", [contractURI]));
      } else {
        throw new Error("Setting a merkle root requires implementing ContractMetadata in your contract to support storing a merkle root.");
      }
    }
    processedClaimConditions.forEach((_ref2) => {
      let {
        tokenId,
        sortedConditions
      } = _ref2;
      if (this.isLegacySinglePhaseDrop(this.contractWrapper)) {
        encoded.push(this.contractWrapper.readContract.interface.encodeFunctionData("setClaimConditions", [tokenId, abstractContractModelToLegacy(sortedConditions[0]), resetClaimEligibilityForAll]));
      } else if (this.isLegacyMultiPhaseDrop(this.contractWrapper)) {
        encoded.push(this.contractWrapper.readContract.interface.encodeFunctionData("setClaimConditions", [tokenId, sortedConditions.map(abstractContractModelToLegacy), resetClaimEligibilityForAll]));
      } else if (this.isNewSinglePhaseDrop(this.contractWrapper)) {
        encoded.push(this.contractWrapper.readContract.interface.encodeFunctionData("setClaimConditions", [tokenId, abstractContractModelToNew(sortedConditions[0]), resetClaimEligibilityForAll]));
      } else if (this.isNewMultiphaseDrop(this.contractWrapper)) {
        encoded.push(this.contractWrapper.readContract.interface.encodeFunctionData("setClaimConditions", [tokenId, sortedConditions.map(abstractContractModelToNew), resetClaimEligibilityForAll]));
      } else {
        throw new Error("Contract does not support claim conditions");
      }
    });
    return {
      receipt: await this.contractWrapper.multiCall(encoded)
    };
  }
  async update(tokenId, index, claimConditionInput) {
    const existingConditions = await this.getAll(tokenId);
    const newConditionInputs = await updateExistingClaimConditions(index, claimConditionInput, existingConditions);
    return await this.set(tokenId, newConditionInputs);
  }
  async prepareClaim(tokenId, quantity, checkERC20Allowance, address) {
    const addressToClaim = address ? address : await this.contractWrapper.getSignerAddress();
    return prepareClaim(addressToClaim, quantity, await this.getActive(tokenId), async () => (await this.metadata.get()).merkle, 0, this.contractWrapper, this.storage, checkERC20Allowance, this.getSnapshotFormatVersion());
  }
  async getClaimArguments(tokenId, destinationAddress, quantity, claimVerification) {
    if (this.isLegacyMultiPhaseDrop(this.contractWrapper)) {
      return [destinationAddress, tokenId, quantity, claimVerification.currencyAddress, claimVerification.price, claimVerification.proofs, claimVerification.maxClaimable];
    } else if (this.isLegacySinglePhaseDrop(this.contractWrapper)) {
      return [destinationAddress, tokenId, quantity, claimVerification.currencyAddress, claimVerification.price, {
        proof: claimVerification.proofs,
        maxQuantityInAllowlist: claimVerification.maxClaimable
      }, ethers_exports.utils.toUtf8Bytes("")];
    }
    return [destinationAddress, tokenId, quantity, claimVerification.currencyAddress, claimVerification.price, {
      proof: claimVerification.proofs,
      quantityLimitPerWallet: claimVerification.maxClaimable,
      pricePerToken: claimVerification.priceInProof,
      currency: claimVerification.currencyAddressInProof
    }, ethers_exports.utils.toUtf8Bytes("")];
  }
  async getClaimTransaction(destinationAddress, tokenId, quantity, options) {
    if (options == null ? void 0 : options.pricePerToken) {
      throw new Error("Price per token should be set via claim conditions by calling `contract.erc1155.claimConditions.set()`");
    }
    const claimVerification = await this.prepareClaim(tokenId, quantity, (options == null ? void 0 : options.checkERC20Allowance) || true);
    return TransactionTask.make({
      contractWrapper: this.contractWrapper,
      functionName: "claim",
      args: await this.getClaimArguments(tokenId, destinationAddress, quantity, claimVerification),
      overrides: claimVerification.overrides
    });
  }
  isNewSinglePhaseDrop(contractWrapper) {
    return detectContractFeature(contractWrapper, "ERC1155ClaimConditionsV2");
  }
  isNewMultiphaseDrop(contractWrapper) {
    return detectContractFeature(contractWrapper, "ERC1155ClaimPhasesV2");
  }
  isLegacySinglePhaseDrop(contractWrapper) {
    return detectContractFeature(contractWrapper, "ERC1155ClaimConditionsV1");
  }
  isLegacyMultiPhaseDrop(contractWrapper) {
    return detectContractFeature(contractWrapper, "ERC1155ClaimPhasesV1");
  }
  getSnapshotFormatVersion() {
    return this.isLegacyMultiPhaseDrop(this.contractWrapper) || this.isLegacySinglePhaseDrop(this.contractWrapper) ? SnapshotFormatVersion.V1 : SnapshotFormatVersion.V2;
  }
};
var DropErc1155History = class {
  constructor(events) {
    _defineProperty(this, "events", void 0);
    this.events = events;
  }
  async getAllClaimerAddresses(tokenId) {
    const a = (await this.events.getEvents("TokensClaimed")).filter((e) => e.data && BigNumber.isBigNumber(e.data.tokenId) ? e.data.tokenId.eq(tokenId) : false);
    return Array.from(new Set(a.filter((b) => {
      var _a;
      return typeof ((_a = b.data) == null ? void 0 : _a.claimer) === "string";
    }).map((b) => b.data.claimer)));
  }
};
var Erc20Burnable = class {
  constructor(erc20, contractWrapper) {
    _defineProperty(this, "featureName", FEATURE_TOKEN_BURNABLE.name);
    _defineProperty(this, "erc20", void 0);
    _defineProperty(this, "contractWrapper", void 0);
    this.erc20 = erc20;
    this.contractWrapper = contractWrapper;
  }
  async tokens(amount) {
    return {
      receipt: await this.contractWrapper.sendTransaction("burn", [await this.erc20.normalizeAmount(amount)])
    };
  }
  async from(holder, amount) {
    return {
      receipt: await this.contractWrapper.sendTransaction("burnFrom", [holder, await this.erc20.normalizeAmount(amount)])
    };
  }
};
var Erc20ClaimableWithConditions = class {
  constructor(erc20, contractWrapper, storage) {
    _defineProperty(this, "featureName", FEATURE_TOKEN_CLAIM_CONDITIONS_V2.name);
    _defineProperty(this, "conditions", void 0);
    _defineProperty(this, "contractWrapper", void 0);
    _defineProperty(this, "erc20", void 0);
    _defineProperty(this, "storage", void 0);
    this.erc20 = erc20;
    this.contractWrapper = contractWrapper;
    this.storage = storage;
    const metadata = new ContractMetadata(this.contractWrapper, CustomContractSchema, this.storage);
    this.conditions = new DropClaimConditions(this.contractWrapper, metadata, this.storage);
  }
  async to(destinationAddress, amount, options) {
    const quantity = await this.erc20.normalizeAmount(amount);
    const task = await this.conditions.getClaimTransaction(destinationAddress, quantity, options);
    return await task.execute();
  }
};
var Erc20Droppable = class {
  constructor(erc20, contractWrapper, storage) {
    _defineProperty(this, "claim", void 0);
    _defineProperty(this, "contractWrapper", void 0);
    _defineProperty(this, "erc20", void 0);
    _defineProperty(this, "storage", void 0);
    this.erc20 = erc20;
    this.contractWrapper = contractWrapper;
    this.storage = storage;
    this.claim = new Erc20ClaimableWithConditions(this.erc20, this.contractWrapper, this.storage);
  }
};
var Erc20BatchMintable = class {
  constructor(erc20, contractWrapper) {
    _defineProperty(this, "featureName", FEATURE_TOKEN_BATCH_MINTABLE.name);
    _defineProperty(this, "contractWrapper", void 0);
    _defineProperty(this, "erc20", void 0);
    this.erc20 = erc20;
    this.contractWrapper = contractWrapper;
  }
  async to(args) {
    const encoded = [];
    for (const arg of args) {
      encoded.push(this.contractWrapper.readContract.interface.encodeFunctionData("mintTo", [arg.toAddress, await this.erc20.normalizeAmount(arg.amount)]));
    }
    return {
      receipt: await this.contractWrapper.multiCall(encoded)
    };
  }
};
var Erc20Mintable = class {
  constructor(erc20, contractWrapper) {
    _defineProperty(this, "featureName", FEATURE_TOKEN_MINTABLE.name);
    _defineProperty(this, "contractWrapper", void 0);
    _defineProperty(this, "erc20", void 0);
    _defineProperty(this, "batch", void 0);
    this.erc20 = erc20;
    this.contractWrapper = contractWrapper;
    this.batch = this.detectErc20BatchMintable();
  }
  async to(to, amount) {
    return {
      receipt: await this.contractWrapper.sendTransaction("mintTo", [to, await this.erc20.normalizeAmount(amount)])
    };
  }
  detectErc20BatchMintable() {
    if (detectContractFeature(this.contractWrapper, "ERC20BatchMintable")) {
      return new Erc20BatchMintable(this.erc20, this.contractWrapper);
    }
    return void 0;
  }
};
var Erc20SignatureMintable = class {
  constructor(contractWrapper, roles) {
    _defineProperty(this, "featureName", FEATURE_TOKEN_SIGNATURE_MINTABLE.name);
    _defineProperty(this, "contractWrapper", void 0);
    _defineProperty(this, "roles", void 0);
    this.contractWrapper = contractWrapper;
    this.roles = roles;
  }
  async mint(signedPayload) {
    const mintRequest = signedPayload.payload;
    const signature = signedPayload.signature;
    const message = await this.mapPayloadToContractStruct(mintRequest);
    const overrides = await this.contractWrapper.getCallOverrides();
    await setErc20Allowance(this.contractWrapper, BigNumber.from(message.price), mintRequest.currencyAddress, overrides);
    return {
      receipt: await this.contractWrapper.sendTransaction("mintWithSignature", [message, signature], overrides)
    };
  }
  async mintBatch(signedPayloads) {
    const contractPayloads = await Promise.all(signedPayloads.map(async (s) => {
      const message = await this.mapPayloadToContractStruct(s.payload);
      const signature = s.signature;
      const price = s.payload.price;
      if (BigNumber.from(price).gt(0)) {
        throw new Error("Can only batch free mints. For mints with a price, use regular mint()");
      }
      return {
        message,
        signature
      };
    }));
    const encoded = contractPayloads.map((p) => {
      return this.contractWrapper.readContract.interface.encodeFunctionData("mintWithSignature", [p.message, p.signature]);
    });
    return {
      receipt: await this.contractWrapper.multiCall(encoded)
    };
  }
  async verify(signedPayload) {
    const mintRequest = signedPayload.payload;
    const signature = signedPayload.signature;
    const message = await this.mapPayloadToContractStruct(mintRequest);
    const verification = await this.contractWrapper.readContract.verify(message, signature);
    return verification[0];
  }
  async generate(mintRequest) {
    return (await this.generateBatch([mintRequest]))[0];
  }
  async generateBatch(payloadsToSign) {
    var _a;
    await ((_a = this.roles) == null ? void 0 : _a.verify(["minter"], await this.contractWrapper.getSignerAddress()));
    const parsedRequests = payloadsToSign.map((m) => Signature20PayloadInput.parse(m));
    const chainId = await this.contractWrapper.getChainID();
    const signer = this.contractWrapper.getSigner();
    invariant(signer, "No signer available");
    const name = await this.contractWrapper.readContract.name();
    return await Promise.all(parsedRequests.map(async (m) => {
      const finalPayload = Signature20PayloadOutput.parse(m);
      const signature = await this.contractWrapper.signTypedData(signer, {
        name,
        version: "1",
        chainId,
        verifyingContract: this.contractWrapper.readContract.address
      }, {
        MintRequest: MintRequest20
      }, await this.mapPayloadToContractStruct(finalPayload));
      return {
        payload: finalPayload,
        signature: signature.toString()
      };
    }));
  }
  async mapPayloadToContractStruct(mintRequest) {
    const normalizedPrice = await normalizePriceValue(this.contractWrapper.getProvider(), mintRequest.price, mintRequest.currencyAddress);
    const amountWithDecimals = ethers_exports.utils.parseUnits(mintRequest.quantity, await this.contractWrapper.readContract.decimals());
    return {
      to: mintRequest.to,
      primarySaleRecipient: mintRequest.primarySaleRecipient,
      quantity: amountWithDecimals,
      price: normalizedPrice,
      currency: mintRequest.currencyAddress,
      validityEndTimestamp: mintRequest.mintEndTime,
      validityStartTimestamp: mintRequest.mintStartTime,
      uid: mintRequest.uid
    };
  }
};
var Erc20 = class {
  get chainId() {
    return this._chainId;
  }
  constructor(contractWrapper, storage, chainId) {
    _defineProperty(this, "featureName", FEATURE_TOKEN.name);
    _defineProperty(this, "mintable", void 0);
    _defineProperty(this, "burnable", void 0);
    _defineProperty(this, "droppable", void 0);
    _defineProperty(this, "signatureMintable", void 0);
    _defineProperty(this, "contractWrapper", void 0);
    _defineProperty(this, "storage", void 0);
    _defineProperty(this, "_chainId", void 0);
    this.contractWrapper = contractWrapper;
    this.storage = storage;
    this.mintable = this.detectErc20Mintable();
    this.burnable = this.detectErc20Burnable();
    this.droppable = this.detectErc20Droppable();
    this.signatureMintable = this.detectErc20SignatureMintable();
    this._chainId = chainId;
  }
  onNetworkUpdated(network) {
    this.contractWrapper.updateSignerOrProvider(network);
  }
  getAddress() {
    return this.contractWrapper.readContract.address;
  }
  async get() {
    return await fetchCurrencyMetadata(this.contractWrapper.getProvider(), this.getAddress());
  }
  async balance() {
    return await this.balanceOf(await this.contractWrapper.getSignerAddress());
  }
  async balanceOf(address) {
    return this.getValue(await this.contractWrapper.readContract.balanceOf(address));
  }
  async totalSupply() {
    return await this.getValue(await this.contractWrapper.readContract.totalSupply());
  }
  async allowance(spender) {
    return await this.allowanceOf(await this.contractWrapper.getSignerAddress(), spender);
  }
  async allowanceOf(owner, spender) {
    return await this.getValue(await this.contractWrapper.readContract.allowance(owner, spender));
  }
  async transfer(to, amount) {
    return {
      receipt: await this.contractWrapper.sendTransaction("transfer", [to, await this.normalizeAmount(amount)])
    };
  }
  async transferFrom(from, to, amount) {
    return {
      receipt: await this.contractWrapper.sendTransaction("transferFrom", [from, to, await this.normalizeAmount(amount)])
    };
  }
  async setAllowance(spender, amount) {
    return {
      receipt: await this.contractWrapper.sendTransaction("approve", [spender, await this.normalizeAmount(amount)])
    };
  }
  async transferBatch(args) {
    const encoded = await Promise.all(args.map(async (arg) => {
      const amountWithDecimals = await this.normalizeAmount(arg.amount);
      return this.contractWrapper.readContract.interface.encodeFunctionData("transfer", [arg.toAddress, amountWithDecimals]);
    }));
    await this.contractWrapper.multiCall(encoded);
  }
  async mint(amount) {
    return this.mintTo(await this.contractWrapper.getSignerAddress(), amount);
  }
  async mintTo(receiver, amount) {
    return assertEnabled(this.mintable, FEATURE_TOKEN_MINTABLE).to(receiver, amount);
  }
  async mintBatchTo(args) {
    var _a;
    return assertEnabled((_a = this.mintable) == null ? void 0 : _a.batch, FEATURE_TOKEN_BATCH_MINTABLE).to(args);
  }
  async burn(amount) {
    return assertEnabled(this.burnable, FEATURE_TOKEN_BURNABLE).tokens(amount);
  }
  async burnFrom(holder, amount) {
    return assertEnabled(this.burnable, FEATURE_TOKEN_BURNABLE).from(holder, amount);
  }
  async claim(amount, options) {
    return this.claimTo(await this.contractWrapper.getSignerAddress(), amount, options);
  }
  async claimTo(destinationAddress, amount, options) {
    var _a;
    return assertEnabled((_a = this.droppable) == null ? void 0 : _a.claim, FEATURE_TOKEN_CLAIM_CONDITIONS_V2).to(destinationAddress, amount, options);
  }
  get claimConditions() {
    var _a;
    return assertEnabled((_a = this.droppable) == null ? void 0 : _a.claim, FEATURE_TOKEN_CLAIM_CONDITIONS_V2).conditions;
  }
  get signature() {
    return assertEnabled(this.signatureMintable, FEATURE_TOKEN_SIGNATURE_MINTABLE);
  }
  async normalizeAmount(amount) {
    const decimals = await this.contractWrapper.readContract.decimals();
    return ethers_exports.utils.parseUnits(AmountSchema.parse(amount), decimals);
  }
  async getValue(value) {
    return await fetchCurrencyValue(this.contractWrapper.getProvider(), this.getAddress(), BigNumber.from(value));
  }
  detectErc20Mintable() {
    if (detectContractFeature(this.contractWrapper, "ERC20")) {
      return new Erc20Mintable(this, this.contractWrapper);
    }
    return void 0;
  }
  detectErc20Burnable() {
    if (detectContractFeature(this.contractWrapper, "ERC20Burnable")) {
      return new Erc20Burnable(this, this.contractWrapper);
    }
    return void 0;
  }
  detectErc20Droppable() {
    if (detectContractFeature(this.contractWrapper, "ERC20ClaimConditionsV1") || detectContractFeature(this.contractWrapper, "ERC20ClaimConditionsV2") || detectContractFeature(this.contractWrapper, "ERC20ClaimPhasesV1") || detectContractFeature(this.contractWrapper, "ERC20ClaimPhasesV2")) {
      return new Erc20Droppable(this, this.contractWrapper, this.storage);
    }
    return void 0;
  }
  detectErc20SignatureMintable() {
    if (detectContractFeature(this.contractWrapper, "ERC20SignatureMintable")) {
      return new Erc20SignatureMintable(this.contractWrapper);
    }
    return void 0;
  }
};
var TokenERC20History = class {
  constructor(contractWrapper, events) {
    _defineProperty(this, "events", void 0);
    _defineProperty(this, "contractWrapper", void 0);
    this.contractWrapper = contractWrapper;
    this.events = events;
  }
  async getAllHolderBalances() {
    const a = await this.events.getEvents("Transfer");
    const txns = a.map((b) => b.data);
    const balances = {};
    txns.forEach((item) => {
      const from = item == null ? void 0 : item.from;
      const to = item == null ? void 0 : item.to;
      const amount = item == null ? void 0 : item.value;
      if (!(from === lib_exports.AddressZero)) {
        if (!(from in balances)) {
          balances[from] = BigNumber.from(0);
        }
        balances[from] = balances[from].sub(amount);
      }
      if (!(to === lib_exports.AddressZero)) {
        if (!(to in balances)) {
          balances[to] = BigNumber.from(0);
        }
        balances[to] = balances[to].add(amount);
      }
    });
    return Promise.all(Object.keys(balances).map(async (addr) => ({
      holder: addr,
      balance: await fetchCurrencyValue(this.contractWrapper.getProvider(), this.contractWrapper.readContract.address, balances[addr])
    })));
  }
};
var StandardErc20 = class {
  get chainId() {
    return this._chainId;
  }
  constructor(contractWrapper, storage, chainId) {
    _defineProperty(this, "contractWrapper", void 0);
    _defineProperty(this, "storage", void 0);
    _defineProperty(this, "erc20", void 0);
    _defineProperty(this, "_chainId", void 0);
    this.contractWrapper = contractWrapper;
    this.storage = storage;
    this.erc20 = new Erc20(this.contractWrapper, this.storage, chainId);
    this._chainId = chainId;
  }
  onNetworkUpdated(network) {
    this.contractWrapper.updateSignerOrProvider(network);
  }
  getAddress() {
    return this.contractWrapper.readContract.address;
  }
  async get() {
    return this.erc20.get();
  }
  async balance() {
    return await this.erc20.balance();
  }
  async balanceOf(address) {
    return this.erc20.balanceOf(address);
  }
  async totalSupply() {
    return await this.erc20.totalSupply();
  }
  async allowance(spender) {
    return await this.erc20.allowance(spender);
  }
  async allowanceOf(owner, spender) {
    return await this.erc20.allowanceOf(owner, spender);
  }
  async transfer(to, amount) {
    return this.erc20.transfer(to, amount);
  }
  async transferFrom(from, to, amount) {
    return this.erc20.transferFrom(from, to, amount);
  }
  async setAllowance(spender, amount) {
    return this.erc20.setAllowance(spender, amount);
  }
  async transferBatch(args) {
    return this.erc20.transferBatch(args);
  }
};
var Erc721Burnable = class {
  constructor(contractWrapper) {
    _defineProperty(this, "featureName", FEATURE_NFT_BURNABLE.name);
    _defineProperty(this, "contractWrapper", void 0);
    this.contractWrapper = contractWrapper;
  }
  async token(tokenId) {
    return {
      receipt: await this.contractWrapper.sendTransaction("burn", [tokenId])
    };
  }
};
var Erc721Claimable = class {
  constructor(erc721, contractWrapper) {
    _defineProperty(this, "featureName", FEATURE_NFT_CLAIM_CUSTOM.name);
    _defineProperty(this, "erc721", void 0);
    _defineProperty(this, "contractWrapper", void 0);
    this.erc721 = erc721;
    this.contractWrapper = contractWrapper;
  }
  async getClaimTransaction(destinationAddress, quantity, options) {
    let overrides = {};
    if (options && options.pricePerToken) {
      overrides = await calculateClaimCost(this.contractWrapper, options.pricePerToken, quantity, options.currencyAddress, options.checkERC20Allowance);
    }
    return TransactionTask.make({
      contractWrapper: this.contractWrapper,
      functionName: "claim",
      args: [destinationAddress, quantity],
      overrides
    });
  }
  async to(destinationAddress, quantity, options) {
    const task = await this.getClaimTransaction(destinationAddress, quantity, options);
    const {
      receipt
    } = await task.execute();
    const event = this.contractWrapper.parseLogs("TokensClaimed", receipt == null ? void 0 : receipt.logs);
    const startingIndex = event[0].args.startTokenId;
    const endingIndex = startingIndex.add(quantity);
    const results = [];
    for (let id = startingIndex; id.lt(endingIndex); id = id.add(1)) {
      results.push({
        id,
        receipt,
        data: () => this.erc721.get(id)
      });
    }
    return results;
  }
};
var Erc721ClaimableWithConditions = class {
  constructor(erc721, contractWrapper, storage) {
    _defineProperty(this, "featureName", FEATURE_NFT_CLAIM_CONDITIONS_V2.name);
    _defineProperty(this, "conditions", void 0);
    _defineProperty(this, "contractWrapper", void 0);
    _defineProperty(this, "erc721", void 0);
    _defineProperty(this, "storage", void 0);
    this.erc721 = erc721;
    this.contractWrapper = contractWrapper;
    this.storage = storage;
    const metadata = new ContractMetadata(this.contractWrapper, CustomContractSchema, this.storage);
    this.conditions = new DropClaimConditions(this.contractWrapper, metadata, this.storage);
  }
  async to(destinationAddress, quantity, options) {
    const task = await this.conditions.getClaimTransaction(destinationAddress, quantity, options);
    const {
      receipt
    } = await task.execute();
    const event = this.contractWrapper.parseLogs("TokensClaimed", receipt == null ? void 0 : receipt.logs);
    const startingIndex = event[0].args.startTokenId;
    const endingIndex = startingIndex.add(quantity);
    const results = [];
    for (let id = startingIndex; id.lt(endingIndex); id = id.add(1)) {
      results.push({
        id,
        receipt,
        data: () => this.erc721.get(id)
      });
    }
    return results;
  }
};
var Erc721LazyMintable = class {
  constructor(erc721, contractWrapper, storage) {
    _defineProperty(this, "featureName", FEATURE_NFT_LAZY_MINTABLE.name);
    _defineProperty(this, "revealer", void 0);
    _defineProperty(this, "claimWithConditions", void 0);
    _defineProperty(this, "claim", void 0);
    _defineProperty(this, "contractWrapper", void 0);
    _defineProperty(this, "erc721", void 0);
    _defineProperty(this, "storage", void 0);
    this.erc721 = erc721;
    this.contractWrapper = contractWrapper;
    this.storage = storage;
    this.revealer = this.detectErc721Revealable();
    this.claimWithConditions = this.detectErc721ClaimableWithConditions();
    this.claim = this.detectErc721Claimable();
  }
  async lazyMint(metadatas, options) {
    const startFileNumber = await this.erc721.nextTokenIdToMint();
    const batch = await uploadOrExtractURIs(metadatas, this.storage, startFileNumber.toNumber(), options);
    const baseUri = getBaseUriFromBatch(batch);
    const receipt = await this.contractWrapper.sendTransaction("lazyMint", [batch.length, baseUri.endsWith("/") ? baseUri : `${baseUri}/`, ethers_exports.utils.toUtf8Bytes("")]);
    const event = this.contractWrapper.parseLogs("TokensLazyMinted", receipt == null ? void 0 : receipt.logs);
    const startingIndex = event[0].args.startTokenId;
    const endingIndex = event[0].args.endTokenId;
    const results = [];
    for (let id = startingIndex; id.lte(endingIndex); id = id.add(1)) {
      results.push({
        id,
        receipt,
        data: () => this.erc721.getTokenMetadata(id)
      });
    }
    return results;
  }
  detectErc721Revealable() {
    if (detectContractFeature(this.contractWrapper, "ERC721Revealable")) {
      return new DelayedReveal(this.contractWrapper, this.storage, FEATURE_NFT_REVEALABLE.name, () => this.erc721.nextTokenIdToMint());
    }
    return void 0;
  }
  detectErc721ClaimableWithConditions() {
    if (detectContractFeature(this.contractWrapper, "ERC721ClaimConditionsV1") || detectContractFeature(this.contractWrapper, "ERC721ClaimConditionsV2") || detectContractFeature(this.contractWrapper, "ERC721ClaimPhasesV1") || detectContractFeature(this.contractWrapper, "ERC721ClaimPhasesV2")) {
      return new Erc721ClaimableWithConditions(this.erc721, this.contractWrapper, this.storage);
    }
    return void 0;
  }
  detectErc721Claimable() {
    if (detectContractFeature(this.contractWrapper, "ERC721ClaimCustom")) {
      return new Erc721Claimable(this.erc721, this.contractWrapper);
    }
    return void 0;
  }
};
var Erc721BatchMintable = class {
  constructor(erc721, contractWrapper, storage) {
    _defineProperty(this, "featureName", FEATURE_NFT_BATCH_MINTABLE.name);
    _defineProperty(this, "contractWrapper", void 0);
    _defineProperty(this, "storage", void 0);
    _defineProperty(this, "erc721", void 0);
    this.erc721 = erc721;
    this.contractWrapper = contractWrapper;
    this.storage = storage;
  }
  async to(to, metadatas) {
    const uris = await uploadOrExtractURIs(metadatas, this.storage);
    const encoded = uris.map((uri) => this.contractWrapper.readContract.interface.encodeFunctionData("mintTo", [to, uri]));
    const receipt = await this.contractWrapper.multiCall(encoded);
    const events = this.contractWrapper.parseLogs("TokensMinted", receipt.logs);
    if (events.length === 0 || events.length < metadatas.length) {
      throw new Error("TokenMinted event not found, minting failed");
    }
    return events.map((e) => {
      const id = e.args.tokenIdMinted;
      return {
        id,
        receipt,
        data: () => this.erc721.get(id)
      };
    });
  }
};
var Erc721Mintable = class {
  constructor(erc721, contractWrapper, storage) {
    _defineProperty(this, "featureName", FEATURE_NFT_MINTABLE.name);
    _defineProperty(this, "contractWrapper", void 0);
    _defineProperty(this, "storage", void 0);
    _defineProperty(this, "erc721", void 0);
    _defineProperty(this, "batch", void 0);
    this.erc721 = erc721;
    this.contractWrapper = contractWrapper;
    this.storage = storage;
    this.batch = this.detectErc721BatchMintable();
  }
  async to(to, metadata) {
    const uri = await uploadOrExtractURI(metadata, this.storage);
    const receipt = await this.contractWrapper.sendTransaction("mintTo", [to, uri]);
    const event = this.contractWrapper.parseLogs("Transfer", receipt == null ? void 0 : receipt.logs);
    if (event.length === 0) {
      throw new Error("TransferEvent event not found");
    }
    const id = event[0].args.tokenId;
    return {
      id,
      receipt,
      data: () => this.erc721.get(id)
    };
  }
  detectErc721BatchMintable() {
    if (detectContractFeature(this.contractWrapper, "ERC721BatchMintable")) {
      return new Erc721BatchMintable(this.erc721, this.contractWrapper, this.storage);
    }
    return void 0;
  }
};
var Erc721Enumerable = class {
  constructor(erc721, contractWrapper) {
    _defineProperty(this, "featureName", FEATURE_NFT_ENUMERABLE.name);
    _defineProperty(this, "contractWrapper", void 0);
    _defineProperty(this, "erc721", void 0);
    this.erc721 = erc721;
    this.contractWrapper = contractWrapper;
  }
  async all(walletAddress) {
    const tokenIds = await this.tokenIds(walletAddress);
    return await Promise.all(tokenIds.map((tokenId) => this.erc721.get(tokenId.toString())));
  }
  async tokenIds(walletAddress) {
    const address = walletAddress || await this.contractWrapper.getSignerAddress();
    const balance = await this.contractWrapper.readContract.balanceOf(address);
    const indices = Array.from(Array(balance.toNumber()).keys());
    return await Promise.all(indices.map((i) => this.contractWrapper.readContract.tokenOfOwnerByIndex(address, i)));
  }
};
var Erc721Supply = class {
  constructor(erc721, contractWrapper) {
    _defineProperty(this, "featureName", FEATURE_NFT_SUPPLY.name);
    _defineProperty(this, "contractWrapper", void 0);
    _defineProperty(this, "erc721", void 0);
    _defineProperty(this, "owned", void 0);
    this.erc721 = erc721;
    this.contractWrapper = contractWrapper;
    this.owned = this.detectErc721Owned();
  }
  async all(queryParams) {
    const start = BigNumber.from((queryParams == null ? void 0 : queryParams.start) || 0).toNumber();
    const count = BigNumber.from((queryParams == null ? void 0 : queryParams.count) || DEFAULT_QUERY_ALL_COUNT).toNumber();
    const maxSupply = await this.erc721.nextTokenIdToMint();
    const maxId = Math.min(maxSupply.toNumber(), start + count);
    return await Promise.all([...Array(maxId - start).keys()].map((i) => this.erc721.get((start + i).toString())));
  }
  async allOwners() {
    return Promise.all([...new Array((await this.totalCount()).toNumber()).keys()].map(async (i) => ({
      tokenId: i,
      owner: await this.erc721.ownerOf(i).catch(() => lib_exports.AddressZero)
    })));
  }
  async totalCount() {
    return await this.erc721.nextTokenIdToMint();
  }
  async totalCirculatingSupply() {
    return await this.contractWrapper.readContract.totalSupply();
  }
  detectErc721Owned() {
    if (detectContractFeature(this.contractWrapper, "ERC721Enumerable")) {
      return new Erc721Enumerable(this.erc721, this.contractWrapper);
    }
    return void 0;
  }
};
var TieredDropPayloadSchema = BaseSignaturePayloadInput.extend({
  tierPriority: mod.array(mod.string()),
  royaltyRecipient: mod.string().default(lib_exports.AddressZero),
  royaltyBps: BasisPointsSchema.default(0),
  quantity: BigNumberSchema2.default(1)
});
var Erc721TieredDrop = class {
  constructor(erc721, contractWrapper, storage) {
    _defineProperty(this, "featureName", FEATURE_NFT_TIERED_DROP.name);
    _defineProperty(this, "contractWrapper", void 0);
    _defineProperty(this, "erc721", void 0);
    _defineProperty(this, "storage", void 0);
    this.erc721 = erc721;
    this.contractWrapper = contractWrapper;
    this.storage = storage;
  }
  async getMetadataInTier(tier) {
    const tiers = await this.contractWrapper.readContract.getMetadataForAllTiers();
    const batches = tiers.find((t) => t.tier === tier);
    if (!batches) {
      throw new Error("Tier not found in contract.");
    }
    const nfts = await Promise.all(batches.ranges.map((range, i) => {
      const nftsInRange = [];
      const baseUri = batches.baseURIs[i];
      for (let j = range.startIdInclusive.toNumber(); j < range.endIdNonInclusive.toNumber(); j++) {
        const uri = `${baseUri}/${j}`;
        const metadata = this.storage.downloadJSON(uri);
        nftsInRange.push(metadata);
      }
      return nftsInRange;
    }).flat());
    return nfts;
  }
  async getTokensInTier(tier) {
    const endIndex = await this.contractWrapper.readContract.getTokensInTierLen();
    if (endIndex.eq(0)) {
      return [];
    }
    const ranges = await this.contractWrapper.readContract.getTokensInTier(tier, 0, endIndex);
    const nfts = await Promise.all(ranges.map((range) => {
      const nftsInRange = [];
      for (let i = range.startIdInclusive.toNumber(); i < range.endIdNonInclusive.toNumber(); i++) {
        nftsInRange.push(this.erc721.get(i));
      }
      return nftsInRange;
    }).flat());
    return nfts;
  }
  async createBatchWithTier(metadatas, tier, options) {
    const startFileNumber = await this.erc721.nextTokenIdToMint();
    const batch = await uploadOrExtractURIs(metadatas, this.storage, startFileNumber.toNumber(), options);
    const baseUri = getBaseUriFromBatch(batch);
    const receipt = await this.contractWrapper.sendTransaction("lazyMint", [batch.length, baseUri.endsWith("/") ? baseUri : `${baseUri}/`, tier, ethers_exports.utils.toUtf8Bytes("")]);
    const event = this.contractWrapper.parseLogs("TokensLazyMinted", receipt == null ? void 0 : receipt.logs);
    const startingIndex = event[0].args[1];
    const endingIndex = event[0].args[2];
    const results = [];
    for (let id = startingIndex; id.lte(endingIndex); id = id.add(1)) {
      results.push({
        id,
        receipt,
        data: () => this.erc721.getTokenMetadata(id)
      });
    }
    return results;
  }
  async createDelayedRevealBatchWithTier(placeholder, metadatas, password, tier, options) {
    if (!password) {
      throw new Error("Password is required");
    }
    const placeholderUris = await this.storage.uploadBatch([CommonNFTInput.parse(placeholder)], {
      rewriteFileNames: {
        fileStartNumber: 0
      }
    });
    const placeholderUri = getBaseUriFromBatch(placeholderUris);
    const startFileNumber = await this.erc721.nextTokenIdToMint();
    const uris = await this.storage.uploadBatch(metadatas.map((m) => CommonNFTInput.parse(m)), {
      onProgress: options == null ? void 0 : options.onProgress,
      rewriteFileNames: {
        fileStartNumber: startFileNumber.toNumber()
      }
    });
    const baseUri = getBaseUriFromBatch(uris);
    const baseUriId = await this.contractWrapper.readContract.getBaseURICount();
    const chainId = await this.contractWrapper.getChainID();
    const hashedPassword = ethers_exports.utils.solidityKeccak256(["string", "uint256", "uint256", "address"], [password, chainId, baseUriId, this.contractWrapper.readContract.address]);
    const encryptedBaseUri = await this.contractWrapper.readContract.encryptDecrypt(ethers_exports.utils.toUtf8Bytes(baseUri), hashedPassword);
    let data;
    const provenanceHash = ethers_exports.utils.solidityKeccak256(["bytes", "bytes", "uint256"], [ethers_exports.utils.toUtf8Bytes(baseUri), hashedPassword, chainId]);
    data = ethers_exports.utils.defaultAbiCoder.encode(["bytes", "bytes32"], [encryptedBaseUri, provenanceHash]);
    const receipt = await this.contractWrapper.sendTransaction("lazyMint", [uris.length, placeholderUri.endsWith("/") ? placeholderUri : `${placeholderUri}/`, tier, data]);
    const event = this.contractWrapper.parseLogs("TokensLazyMinted", receipt == null ? void 0 : receipt.logs);
    const startingIndex = event[0].args[1];
    const endingIndex = event[0].args[2];
    const results = [];
    for (let id = startingIndex; id.lte(endingIndex); id = id.add(1)) {
      results.push({
        id,
        receipt,
        data: () => this.erc721.getTokenMetadata(id)
      });
    }
    return results;
  }
  async reveal(batchId, password) {
    if (!password) {
      throw new Error("Password is required");
    }
    const chainId = await this.contractWrapper.getChainID();
    const key = ethers_exports.utils.solidityKeccak256(["string", "uint256", "uint256", "address"], [password, chainId, batchId, this.contractWrapper.readContract.address]);
    try {
      const decryptedUri = await this.contractWrapper.callStatic().reveal(batchId, key);
      if (!decryptedUri.includes("://") || !decryptedUri.endsWith("/")) {
        throw new Error("invalid password");
      }
    } catch (e) {
      throw new Error("invalid password");
    }
    return {
      receipt: await this.contractWrapper.sendTransaction("reveal", [batchId, key])
    };
  }
  async generate(payloadToSign) {
    const [payload] = await this.generateBatch([payloadToSign]);
    return payload;
  }
  async generateBatch(payloadsToSign) {
    const parsedPayloads = payloadsToSign.map((payload) => TieredDropPayloadSchema.parse(payload));
    const chainId = await this.contractWrapper.getChainID();
    const signer = this.contractWrapper.getSigner();
    invariant(signer, "No signer available");
    return await Promise.all(parsedPayloads.map(async (payload) => {
      const signature = await this.contractWrapper.signTypedData(signer, {
        name: "SignatureAction",
        version: "1",
        chainId,
        verifyingContract: this.contractWrapper.readContract.address
      }, {
        GenericRequest
      }, await this.mapPayloadToContractStruct(payload));
      return {
        payload,
        signature: signature.toString()
      };
    }));
  }
  async verify(signedPayload) {
    const message = await this.mapPayloadToContractStruct(signedPayload.payload);
    const verification = await this.contractWrapper.readContract.verify(message, signedPayload.signature);
    return verification[0];
  }
  async claimWithSignature(signedPayload) {
    const message = await this.mapPayloadToContractStruct(signedPayload.payload);
    const pricePerToken = await normalizePriceValue(this.contractWrapper.getProvider(), signedPayload.payload.price, signedPayload.payload.currencyAddress);
    const price = pricePerToken.mul(signedPayload.payload.quantity);
    const overrides = await this.contractWrapper.getCallOverrides();
    await setErc20Allowance(this.contractWrapper, price, signedPayload.payload.currencyAddress, overrides);
    const receipt = await this.contractWrapper.sendTransaction("claimWithSignature", [message, signedPayload.signature], overrides);
    const event = this.contractWrapper.parseLogs("TokensClaimed", receipt == null ? void 0 : receipt.logs);
    const startingIndex = event[0].args.startTokenId;
    const endingIndex = startingIndex.add(event[0].args.quantityClaimed);
    const results = [];
    for (let id = startingIndex; id.lt(endingIndex); id = id.add(1)) {
      results.push({
        id,
        receipt,
        data: () => this.erc721.get(id)
      });
    }
    return results;
  }
  async mapPayloadToContractStruct(payload) {
    const normalizedPricePerToken = await normalizePriceValue(this.contractWrapper.getProvider(), payload.price, payload.currencyAddress);
    const data = ethers_exports.utils.defaultAbiCoder.encode(["string[]", "address", "address", "uint256", "address", "uint256", "uint256", "address"], [payload.tierPriority, payload.to, payload.royaltyRecipient, payload.royaltyBps, payload.primarySaleRecipient, payload.quantity, normalizedPricePerToken, payload.currencyAddress]);
    return {
      uid: payload.uid,
      validityStartTimestamp: payload.mintStartTime,
      validityEndTimestamp: payload.mintEndTime,
      data
    };
  }
};
var Erc721WithQuantitySignatureMintable = class {
  constructor(contractWrapper, storage) {
    _defineProperty(this, "featureName", FEATURE_NFT_SIGNATURE_MINTABLE_V2.name);
    _defineProperty(this, "contractWrapper", void 0);
    _defineProperty(this, "storage", void 0);
    this.contractWrapper = contractWrapper;
    this.storage = storage;
  }
  async mint(signedPayload) {
    const mintRequest = signedPayload.payload;
    const signature = signedPayload.signature;
    const isLegacyNFTContract = await this.isLegacyNFTContract();
    let message;
    let price;
    if (isLegacyNFTContract) {
      message = await this.mapLegacyPayloadToContractStruct(mintRequest);
      price = message.price;
    } else {
      message = await this.mapPayloadToContractStruct(mintRequest);
      price = message.pricePerToken.mul(message.quantity);
    }
    const overrides = await this.contractWrapper.getCallOverrides();
    await setErc20Allowance(this.contractWrapper, price, mintRequest.currencyAddress, overrides);
    const receipt = await this.contractWrapper.sendTransaction("mintWithSignature", [message, signature], overrides);
    const t = this.contractWrapper.parseLogs("TokensMintedWithSignature", receipt.logs);
    if (t.length === 0) {
      throw new Error("No MintWithSignature event found");
    }
    const id = t[0].args.tokenIdMinted;
    return {
      id,
      receipt
    };
  }
  async mintBatch(signedPayloads) {
    const isLegacyNFTContract = await this.isLegacyNFTContract();
    const contractPayloads = await Promise.all(signedPayloads.map(async (s) => {
      let message;
      if (isLegacyNFTContract) {
        message = await this.mapLegacyPayloadToContractStruct(s.payload);
      } else {
        message = await this.mapPayloadToContractStruct(s.payload);
      }
      const signature = s.signature;
      const price = s.payload.price;
      if (BigNumber.from(price).gt(0)) {
        throw new Error("Can only batch free mints. For mints with a price, use regular mint()");
      }
      return {
        message,
        signature
      };
    }));
    const encoded = contractPayloads.map((p) => {
      if (isLegacyNFTContract) {
        const contract = this.contractWrapper.readContract;
        return contract.interface.encodeFunctionData("mintWithSignature", [p.message, p.signature]);
      } else {
        const contract = this.contractWrapper.readContract;
        return contract.interface.encodeFunctionData("mintWithSignature", [p.message, p.signature]);
      }
    });
    const receipt = await this.contractWrapper.multiCall(encoded);
    const events = this.contractWrapper.parseLogs("TokensMintedWithSignature", receipt.logs);
    if (events.length === 0) {
      throw new Error("No MintWithSignature event found");
    }
    return events.map((log) => ({
      id: log.args.tokenIdMinted,
      receipt
    }));
  }
  async verify(signedPayload) {
    const isLegacyNFTContract = await this.isLegacyNFTContract();
    const mintRequest = signedPayload.payload;
    const signature = signedPayload.signature;
    let message;
    let verification;
    if (isLegacyNFTContract) {
      const contract = this.contractWrapper.readContract;
      message = await this.mapLegacyPayloadToContractStruct(mintRequest);
      verification = await contract.verify(message, signature);
    } else {
      const contract = this.contractWrapper.readContract;
      message = await this.mapPayloadToContractStruct(mintRequest);
      verification = await contract.verify(message, signature);
    }
    return verification[0];
  }
  async generate(mintRequest) {
    return (await this.generateBatch([mintRequest]))[0];
  }
  async generateBatch(payloadsToSign) {
    const isLegacyNFTContract = await this.isLegacyNFTContract();
    const parsedRequests = payloadsToSign.map((m) => Signature721WithQuantityInput.parse(m));
    const metadatas = parsedRequests.map((r) => r.metadata);
    const uris = await uploadOrExtractURIs(metadatas, this.storage);
    const chainId = await this.contractWrapper.getChainID();
    const signer = this.contractWrapper.getSigner();
    invariant(signer, "No signer available");
    return await Promise.all(parsedRequests.map(async (m, i) => {
      const uri = uris[i];
      const finalPayload = Signature721WithQuantityOutput.parse({
        ...m,
        uri
      });
      let signature;
      if (isLegacyNFTContract) {
        signature = await this.contractWrapper.signTypedData(signer, {
          name: "TokenERC721",
          version: "1",
          chainId,
          verifyingContract: this.contractWrapper.readContract.address
        }, {
          MintRequest: MintRequest721
        }, await this.mapLegacyPayloadToContractStruct(finalPayload));
      } else {
        signature = await this.contractWrapper.signTypedData(
          signer,
          {
            name: "SignatureMintERC721",
            version: "1",
            chainId,
            verifyingContract: await this.contractWrapper.readContract.address
          },
          {
            MintRequest: MintRequest721withQuantity
          },
          await this.mapPayloadToContractStruct(finalPayload)
        );
      }
      return {
        payload: finalPayload,
        signature: signature.toString()
      };
    }));
  }
  async mapPayloadToContractStruct(mintRequest) {
    const normalizedPricePerToken = await normalizePriceValue(this.contractWrapper.getProvider(), mintRequest.price, mintRequest.currencyAddress);
    return {
      to: mintRequest.to,
      royaltyRecipient: mintRequest.royaltyRecipient,
      royaltyBps: mintRequest.royaltyBps,
      primarySaleRecipient: mintRequest.primarySaleRecipient,
      uri: mintRequest.uri,
      quantity: mintRequest.quantity,
      pricePerToken: normalizedPricePerToken,
      currency: mintRequest.currencyAddress,
      validityStartTimestamp: mintRequest.mintStartTime,
      validityEndTimestamp: mintRequest.mintEndTime,
      uid: mintRequest.uid
    };
  }
  async mapLegacyPayloadToContractStruct(mintRequest) {
    const normalizedPricePerToken = await normalizePriceValue(this.contractWrapper.getProvider(), mintRequest.price, mintRequest.currencyAddress);
    return {
      to: mintRequest.to,
      price: normalizedPricePerToken,
      uri: mintRequest.uri,
      currency: mintRequest.currencyAddress,
      validityEndTimestamp: mintRequest.mintEndTime,
      validityStartTimestamp: mintRequest.mintStartTime,
      uid: mintRequest.uid,
      royaltyRecipient: mintRequest.royaltyRecipient,
      royaltyBps: mintRequest.royaltyBps,
      primarySaleRecipient: mintRequest.primarySaleRecipient
    };
  }
  async isLegacyNFTContract() {
    return detectContractFeature(this.contractWrapper, "ERC721SignatureMintV1");
  }
};
var Erc721 = class {
  get chainId() {
    return this._chainId;
  }
  constructor(contractWrapper, storage, chainId) {
    _defineProperty(this, "featureName", FEATURE_NFT.name);
    _defineProperty(this, "query", void 0);
    _defineProperty(this, "mintable", void 0);
    _defineProperty(this, "burnable", void 0);
    _defineProperty(this, "lazyMintable", void 0);
    _defineProperty(this, "tieredDropable", void 0);
    _defineProperty(this, "signatureMintable", void 0);
    _defineProperty(this, "contractWrapper", void 0);
    _defineProperty(this, "storage", void 0);
    _defineProperty(this, "_chainId", void 0);
    this.contractWrapper = contractWrapper;
    this.storage = storage;
    this.query = this.detectErc721Enumerable();
    this.mintable = this.detectErc721Mintable();
    this.burnable = this.detectErc721Burnable();
    this.lazyMintable = this.detectErc721LazyMintable();
    this.tieredDropable = this.detectErc721TieredDrop();
    this.signatureMintable = this.detectErc721SignatureMintable();
    this._chainId = chainId;
  }
  onNetworkUpdated(network) {
    this.contractWrapper.updateSignerOrProvider(network);
  }
  getAddress() {
    return this.contractWrapper.readContract.address;
  }
  async get(tokenId) {
    const [owner, metadata] = await Promise.all([this.ownerOf(tokenId).catch(() => lib_exports.AddressZero), this.getTokenMetadata(tokenId).catch(() => ({
      id: tokenId.toString(),
      uri: "",
      ...FALLBACK_METADATA
    }))]);
    return {
      owner,
      metadata,
      type: "ERC721",
      supply: 1
    };
  }
  async ownerOf(tokenId) {
    return await this.contractWrapper.readContract.ownerOf(tokenId);
  }
  async balanceOf(address) {
    return await this.contractWrapper.readContract.balanceOf(address);
  }
  async balance() {
    return await this.balanceOf(await this.contractWrapper.getSignerAddress());
  }
  async isApproved(address, operator) {
    return await this.contractWrapper.readContract.isApprovedForAll(address, operator);
  }
  async transfer(to, tokenId) {
    const from = await this.contractWrapper.getSignerAddress();
    return {
      receipt: await this.contractWrapper.sendTransaction("safeTransferFrom(address,address,uint256)", [from, to, tokenId])
    };
  }
  async setApprovalForAll(operator, approved) {
    return {
      receipt: await this.contractWrapper.sendTransaction("setApprovalForAll", [operator, approved])
    };
  }
  async setApprovalForToken(operator, tokenId) {
    return {
      receipt: await this.contractWrapper.sendTransaction("approve", [operator, tokenId])
    };
  }
  async getAll(queryParams) {
    return assertEnabled(this.query, FEATURE_NFT_SUPPLY).all(queryParams);
  }
  async getAllOwners() {
    return assertEnabled(this.query, FEATURE_NFT_SUPPLY).allOwners();
  }
  async totalCount() {
    return this.nextTokenIdToMint();
  }
  async totalCirculatingSupply() {
    return assertEnabled(this.query, FEATURE_NFT_SUPPLY).totalCirculatingSupply();
  }
  async getOwned(walletAddress) {
    var _a;
    if ((_a = this.query) == null ? void 0 : _a.owned) {
      return this.query.owned.all(walletAddress);
    } else {
      const address = walletAddress || await this.contractWrapper.getSignerAddress();
      const allOwners = await this.getAllOwners();
      return Promise.all((allOwners || []).filter((i) => {
        var _a2;
        return (address == null ? void 0 : address.toLowerCase()) === ((_a2 = i.owner) == null ? void 0 : _a2.toLowerCase());
      }).map(async (i) => await this.get(i.tokenId)));
    }
  }
  async getOwnedTokenIds(walletAddress) {
    var _a;
    if ((_a = this.query) == null ? void 0 : _a.owned) {
      return this.query.owned.tokenIds(walletAddress);
    } else {
      const address = walletAddress || await this.contractWrapper.getSignerAddress();
      const allOwners = await this.getAllOwners();
      return (allOwners || []).filter((i) => {
        var _a2;
        return (address == null ? void 0 : address.toLowerCase()) === ((_a2 = i.owner) == null ? void 0 : _a2.toLowerCase());
      }).map((i) => BigNumber.from(i.tokenId));
    }
  }
  async mint(metadata) {
    return this.mintTo(await this.contractWrapper.getSignerAddress(), metadata);
  }
  async mintTo(receiver, metadata) {
    return assertEnabled(this.mintable, FEATURE_NFT_MINTABLE).to(receiver, metadata);
  }
  async mintBatch(metadatas) {
    return this.mintBatchTo(await this.contractWrapper.getSignerAddress(), metadatas);
  }
  async mintBatchTo(receiver, metadatas) {
    var _a;
    return assertEnabled((_a = this.mintable) == null ? void 0 : _a.batch, FEATURE_NFT_BATCH_MINTABLE).to(receiver, metadatas);
  }
  async burn(tokenId) {
    return assertEnabled(this.burnable, FEATURE_NFT_BURNABLE).token(tokenId);
  }
  async lazyMint(metadatas, options) {
    return assertEnabled(this.lazyMintable, FEATURE_NFT_LAZY_MINTABLE).lazyMint(metadatas, options);
  }
  async claim(quantity, options) {
    return this.claimTo(await this.contractWrapper.getSignerAddress(), quantity, options);
  }
  async claimTo(destinationAddress, quantity, options) {
    var _a, _b;
    const claimWithConditions = (_a = this.lazyMintable) == null ? void 0 : _a.claimWithConditions;
    const claim = (_b = this.lazyMintable) == null ? void 0 : _b.claim;
    if (claimWithConditions) {
      return claimWithConditions.to(destinationAddress, quantity, options);
    }
    if (claim) {
      return claim.to(destinationAddress, quantity, options);
    }
    throw new ExtensionNotImplementedError(FEATURE_NFT_CLAIM_CUSTOM);
  }
  async getClaimTransaction(destinationAddress, quantity, options) {
    var _a, _b;
    const claimWithConditions = (_a = this.lazyMintable) == null ? void 0 : _a.claimWithConditions;
    const claim = (_b = this.lazyMintable) == null ? void 0 : _b.claim;
    if (claimWithConditions) {
      return claimWithConditions.conditions.getClaimTransaction(destinationAddress, quantity, options);
    }
    if (claim) {
      return claim.getClaimTransaction(destinationAddress, quantity, options);
    }
    throw new ExtensionNotImplementedError(FEATURE_NFT_CLAIM_CUSTOM);
  }
  async totalClaimedSupply() {
    const contract = this.contractWrapper;
    if (hasFunction("nextTokenIdToClaim", contract)) {
      return contract.readContract.nextTokenIdToClaim();
    }
    if (hasFunction("totalMinted", contract)) {
      return contract.readContract.totalMinted();
    }
    throw new Error("No function found on contract to get total claimed supply");
  }
  async totalUnclaimedSupply() {
    return (await this.nextTokenIdToMint()).sub(await this.totalClaimedSupply());
  }
  get claimConditions() {
    var _a;
    return assertEnabled((_a = this.lazyMintable) == null ? void 0 : _a.claimWithConditions, FEATURE_NFT_CLAIM_CONDITIONS_V2).conditions;
  }
  get tieredDrop() {
    return assertEnabled(this.tieredDropable, FEATURE_NFT_TIERED_DROP);
  }
  get signature() {
    return assertEnabled(this.signatureMintable, FEATURE_NFT_SIGNATURE_MINTABLE_V2);
  }
  get revealer() {
    var _a;
    return assertEnabled((_a = this.lazyMintable) == null ? void 0 : _a.revealer, FEATURE_NFT_REVEALABLE);
  }
  async getTokenMetadata(tokenId) {
    const tokenUri = await this.contractWrapper.readContract.tokenURI(tokenId);
    if (!tokenUri) {
      throw new NotFoundError();
    }
    return fetchTokenMetadata(tokenId, tokenUri, this.storage);
  }
  async nextTokenIdToMint() {
    if (hasFunction("nextTokenIdToMint", this.contractWrapper)) {
      return await this.contractWrapper.readContract.nextTokenIdToMint();
    } else if (hasFunction("totalSupply", this.contractWrapper)) {
      return await this.contractWrapper.readContract.totalSupply();
    } else {
      throw new Error("Contract requires either `nextTokenIdToMint` or `totalSupply` function available to determine the next token ID to mint");
    }
  }
  detectErc721Enumerable() {
    if (detectContractFeature(this.contractWrapper, "ERC721Supply") || hasFunction("nextTokenIdToMint", this.contractWrapper)) {
      return new Erc721Supply(this, this.contractWrapper);
    }
    return void 0;
  }
  detectErc721Mintable() {
    if (detectContractFeature(this.contractWrapper, "ERC721Mintable")) {
      return new Erc721Mintable(this, this.contractWrapper, this.storage);
    }
    return void 0;
  }
  detectErc721Burnable() {
    if (detectContractFeature(this.contractWrapper, "ERC721Burnable")) {
      return new Erc721Burnable(this.contractWrapper);
    }
    return void 0;
  }
  detectErc721LazyMintable() {
    if (detectContractFeature(this.contractWrapper, "ERC721LazyMintable")) {
      return new Erc721LazyMintable(this, this.contractWrapper, this.storage);
    }
    return void 0;
  }
  detectErc721TieredDrop() {
    if (detectContractFeature(this.contractWrapper, "ERC721TieredDrop")) {
      return new Erc721TieredDrop(this, this.contractWrapper, this.storage);
    }
    return void 0;
  }
  detectErc721SignatureMintable() {
    if (detectContractFeature(this.contractWrapper, "ERC721SignatureMintV1") || detectContractFeature(this.contractWrapper, "ERC721SignatureMintV2")) {
      return new Erc721WithQuantitySignatureMintable(this.contractWrapper, this.storage);
    }
    return void 0;
  }
};
var StandardErc721 = class {
  get chainId() {
    return this._chainId;
  }
  constructor(contractWrapper, storage, chainId) {
    _defineProperty(this, "contractWrapper", void 0);
    _defineProperty(this, "storage", void 0);
    _defineProperty(this, "erc721", void 0);
    _defineProperty(this, "_chainId", void 0);
    this.contractWrapper = contractWrapper;
    this.storage = storage;
    this.erc721 = new Erc721(this.contractWrapper, this.storage, chainId);
    this._chainId = chainId;
  }
  onNetworkUpdated(network) {
    this.contractWrapper.updateSignerOrProvider(network);
  }
  getAddress() {
    return this.contractWrapper.readContract.address;
  }
  async getAll(queryParams) {
    return this.erc721.getAll(queryParams);
  }
  async getOwned(walletAddress) {
    return this.erc721.getOwned(walletAddress);
  }
  async getOwnedTokenIds(walletAddress) {
    return this.erc721.getOwnedTokenIds(walletAddress);
  }
  async totalSupply() {
    return this.erc721.totalCirculatingSupply();
  }
  async get(tokenId) {
    return this.erc721.get(tokenId);
  }
  async ownerOf(tokenId) {
    return this.erc721.ownerOf(tokenId);
  }
  async balanceOf(address) {
    return this.erc721.balanceOf(address);
  }
  async balance() {
    return this.erc721.balance();
  }
  async isApproved(address, operator) {
    return this.erc721.isApproved(address, operator);
  }
  async transfer(to, tokenId) {
    return this.erc721.transfer(to, tokenId);
  }
  async setApprovalForAll(operator, approved) {
    return this.erc721.setApprovalForAll(operator, approved);
  }
  async setApprovalForToken(operator, tokenId) {
    return {
      receipt: await this.contractWrapper.sendTransaction("approve", [operator, tokenId])
    };
  }
};
var AirdropAddressInput = mod.object({
  address: AddressSchema,
  quantity: AmountSchema.default(1)
});
var AirdropInputSchema = mod.union([mod.array(mod.string()).transform((strings) => strings.map((address) => AirdropAddressInput.parse({
  address
}))), mod.array(AirdropAddressInput)]);
var Erc1155Burnable = class {
  constructor(contractWrapper) {
    _defineProperty(this, "featureName", FEATURE_EDITION_BURNABLE.name);
    _defineProperty(this, "contractWrapper", void 0);
    this.contractWrapper = contractWrapper;
  }
  async tokens(tokenId, amount) {
    const account = await this.contractWrapper.getSignerAddress();
    return this.from(account, tokenId, amount);
  }
  async from(account, tokenId, amount) {
    return {
      receipt: await this.contractWrapper.sendTransaction("burn", [account, tokenId, amount])
    };
  }
  async batch(tokenIds, amounts) {
    const account = await this.contractWrapper.getSignerAddress();
    return this.batchFrom(account, tokenIds, amounts);
  }
  async batchFrom(account, tokenIds, amounts) {
    return {
      receipt: await this.contractWrapper.sendTransaction("burnBatch", [account, tokenIds, amounts])
    };
  }
};
var Erc1155Enumerable = class {
  constructor(erc1155, contractWrapper) {
    _defineProperty(this, "featureName", FEATURE_EDITION_ENUMERABLE.name);
    _defineProperty(this, "contractWrapper", void 0);
    _defineProperty(this, "erc1155", void 0);
    this.erc1155 = erc1155;
    this.contractWrapper = contractWrapper;
  }
  async all(queryParams) {
    const start = BigNumber.from((queryParams == null ? void 0 : queryParams.start) || 0).toNumber();
    const count = BigNumber.from((queryParams == null ? void 0 : queryParams.count) || DEFAULT_QUERY_ALL_COUNT).toNumber();
    const maxId = Math.min((await this.totalCount()).toNumber(), start + count);
    return await Promise.all([...Array(maxId - start).keys()].map((i) => this.erc1155.get((start + i).toString())));
  }
  async totalCount() {
    return await this.contractWrapper.readContract.nextTokenIdToMint();
  }
  async totalCirculatingSupply(tokenId) {
    return await this.contractWrapper.readContract.totalSupply(tokenId);
  }
  async owned(walletAddress) {
    const address = walletAddress || await this.contractWrapper.getSignerAddress();
    const maxId = await this.contractWrapper.readContract.nextTokenIdToMint();
    const balances = await this.contractWrapper.readContract.balanceOfBatch(Array(maxId.toNumber()).fill(address), Array.from(Array(maxId.toNumber()).keys()));
    const ownedBalances = balances.map((b, i) => {
      return {
        tokenId: i,
        balance: b
      };
    }).filter((b) => b.balance.gt(0));
    return await Promise.all(ownedBalances.map(async (b) => {
      const editionMetadata = await this.erc1155.get(b.tokenId.toString());
      return {
        ...editionMetadata,
        owner: address,
        quantityOwned: b.balance.toNumber()
      };
    }));
  }
};
async function getPrebuiltInfo(address, provider) {
  try {
    const contract = new ethers_exports.Contract(address, IThirdwebContract_default, provider);
    const [type, version] = await Promise.all([ethers_exports.utils.toUtf8String(await contract.contractType()).replace(/\x00/g, ""), await contract.contractVersion()]);
    return {
      type,
      version
    };
  } catch (e) {
    return void 0;
  }
}
var ERC1155Claimable = class {
  constructor(contractWrapper) {
    _defineProperty(this, "featureName", FEATURE_EDITION_CLAIM_CUSTOM.name);
    _defineProperty(this, "contractWrapper", void 0);
    this.contractWrapper = contractWrapper;
  }
  async getClaimTransaction(destinationAddress, tokenId, quantity, options) {
    let overrides = {};
    if (options && options.pricePerToken) {
      overrides = await calculateClaimCost(this.contractWrapper, options.pricePerToken, quantity, options.currencyAddress, options.checkERC20Allowance);
    }
    return TransactionTask.make({
      contractWrapper: this.contractWrapper,
      functionName: "claim",
      args: [destinationAddress, tokenId, quantity],
      overrides
    });
  }
  async to(destinationAddress, tokenId, quantity, options) {
    const tx = await this.getClaimTransaction(destinationAddress, tokenId, quantity, options);
    return await tx.execute();
  }
};
var Erc1155ClaimableWithConditions = class {
  constructor(contractWrapper, storage) {
    _defineProperty(this, "featureName", FEATURE_EDITION_CLAIM_CONDITIONS_V2.name);
    _defineProperty(this, "conditions", void 0);
    _defineProperty(this, "contractWrapper", void 0);
    _defineProperty(this, "storage", void 0);
    this.contractWrapper = contractWrapper;
    this.storage = storage;
    const metadata = new ContractMetadata(this.contractWrapper, CustomContractSchema, this.storage);
    this.conditions = new DropErc1155ClaimConditions(contractWrapper, metadata, this.storage);
  }
  async to(destinationAddress, tokenId, quantity, options) {
    const tx = await this.conditions.getClaimTransaction(destinationAddress, tokenId, quantity, options);
    return await tx.execute();
  }
};
var Erc1155LazyMintable = class {
  constructor(erc1155, contractWrapper, storage) {
    _defineProperty(this, "featureName", FEATURE_EDITION_LAZY_MINTABLE_V2.name);
    _defineProperty(this, "revealer", void 0);
    _defineProperty(this, "claimWithConditions", void 0);
    _defineProperty(this, "claim", void 0);
    _defineProperty(this, "contractWrapper", void 0);
    _defineProperty(this, "erc1155", void 0);
    _defineProperty(this, "storage", void 0);
    this.erc1155 = erc1155;
    this.contractWrapper = contractWrapper;
    this.storage = storage;
    this.claim = this.detectErc1155Claimable();
    this.claimWithConditions = this.detectErc1155ClaimableWithConditions();
    this.revealer = this.detectErc1155Revealable();
  }
  async lazyMint(metadatas, options) {
    const startFileNumber = await this.erc1155.nextTokenIdToMint();
    const batch = await uploadOrExtractURIs(metadatas, this.storage, startFileNumber.toNumber(), options);
    const baseUri = batch[0].substring(0, batch[0].lastIndexOf("/"));
    for (let i = 0; i < batch.length; i++) {
      const uri = batch[i].substring(0, batch[i].lastIndexOf("/"));
      if (baseUri !== uri) {
        throw new Error(`Can only create batches with the same base URI for every entry in the batch. Expected '${baseUri}' but got '${uri}'`);
      }
    }
    const isLegacyEditionDropContract = await this.isLegacyEditionDropContract();
    let receipt;
    if (isLegacyEditionDropContract) {
      receipt = await this.contractWrapper.sendTransaction("lazyMint", [batch.length, `${baseUri.endsWith("/") ? baseUri : `${baseUri}/`}`]);
    } else {
      receipt = await this.contractWrapper.sendTransaction("lazyMint", [batch.length, `${baseUri.endsWith("/") ? baseUri : `${baseUri}/`}`, ethers_exports.utils.toUtf8Bytes("")]);
    }
    const event = this.contractWrapper.parseLogs("TokensLazyMinted", receipt == null ? void 0 : receipt.logs);
    const startingIndex = event[0].args.startTokenId;
    const endingIndex = event[0].args.endTokenId;
    const results = [];
    for (let id = startingIndex; id.lte(endingIndex); id = id.add(1)) {
      results.push({
        id,
        receipt,
        data: () => this.erc1155.getTokenMetadata(id)
      });
    }
    return results;
  }
  detectErc1155Claimable() {
    if (detectContractFeature(this.contractWrapper, "ERC1155ClaimCustom")) {
      return new ERC1155Claimable(this.contractWrapper);
    }
    return void 0;
  }
  detectErc1155ClaimableWithConditions() {
    if (detectContractFeature(this.contractWrapper, "ERC1155ClaimConditionsV1") || detectContractFeature(this.contractWrapper, "ERC1155ClaimConditionsV2") || detectContractFeature(this.contractWrapper, "ERC1155ClaimPhasesV1") || detectContractFeature(this.contractWrapper, "ERC1155ClaimPhasesV2")) {
      return new Erc1155ClaimableWithConditions(this.contractWrapper, this.storage);
    }
    return void 0;
  }
  detectErc1155Revealable() {
    if (detectContractFeature(this.contractWrapper, "ERC1155Revealable")) {
      return new DelayedReveal(this.contractWrapper, this.storage, FEATURE_EDITION_REVEALABLE.name, () => this.erc1155.nextTokenIdToMint());
    }
    return void 0;
  }
  async isLegacyEditionDropContract() {
    const info = await getPrebuiltInfo(this.contractWrapper.readContract.address, this.contractWrapper.getProvider());
    return info && info.type === "DropERC1155" && info.version < 3;
  }
};
var Erc1155BatchMintable = class {
  constructor(erc1155, contractWrapper, storage) {
    _defineProperty(this, "featureName", FEATURE_EDITION_BATCH_MINTABLE.name);
    _defineProperty(this, "contractWrapper", void 0);
    _defineProperty(this, "erc1155", void 0);
    _defineProperty(this, "storage", void 0);
    this.erc1155 = erc1155;
    this.contractWrapper = contractWrapper;
    this.storage = storage;
  }
  async to(to, metadataWithSupply) {
    const metadatas = metadataWithSupply.map((a) => a.metadata);
    const supplies = metadataWithSupply.map((a) => a.supply);
    const uris = await uploadOrExtractURIs(metadatas, this.storage);
    const encoded = uris.map((uri, index) => this.contractWrapper.readContract.interface.encodeFunctionData("mintTo", [to, ethers_exports.constants.MaxUint256, uri, supplies[index]]));
    const receipt = await this.contractWrapper.multiCall(encoded);
    const events = this.contractWrapper.parseLogs("TokensMinted", receipt.logs);
    if (events.length === 0 || events.length < metadatas.length) {
      throw new Error("TokenMinted event not found, minting failed");
    }
    return events.map((e) => {
      const id = e.args.tokenIdMinted;
      return {
        id,
        receipt,
        data: () => this.erc1155.get(id)
      };
    });
  }
};
var Erc1155Mintable = class {
  constructor(erc1155, contractWrapper, storage) {
    _defineProperty(this, "featureName", FEATURE_EDITION_MINTABLE.name);
    _defineProperty(this, "contractWrapper", void 0);
    _defineProperty(this, "erc1155", void 0);
    _defineProperty(this, "storage", void 0);
    _defineProperty(this, "batch", void 0);
    this.erc1155 = erc1155;
    this.contractWrapper = contractWrapper;
    this.storage = storage;
    this.batch = this.detectErc1155BatchMintable();
  }
  async to(to, metadataWithSupply) {
    const uri = await uploadOrExtractURI(metadataWithSupply.metadata, this.storage);
    const receipt = await this.contractWrapper.sendTransaction("mintTo", [to, ethers_exports.constants.MaxUint256, uri, metadataWithSupply.supply]);
    const event = this.contractWrapper.parseLogs("TransferSingle", receipt == null ? void 0 : receipt.logs);
    if (event.length === 0) {
      throw new Error("TransferSingleEvent event not found");
    }
    const id = event[0].args.id;
    return {
      id,
      receipt,
      data: () => this.erc1155.get(id.toString())
    };
  }
  async additionalSupplyTo(to, tokenId, additionalSupply) {
    const metadata = await this.erc1155.getTokenMetadata(tokenId);
    const receipt = await this.contractWrapper.sendTransaction("mintTo", [to, tokenId, metadata.uri, additionalSupply]);
    return {
      id: BigNumber.from(tokenId),
      receipt,
      data: () => this.erc1155.get(tokenId)
    };
  }
  detectErc1155BatchMintable() {
    if (detectContractFeature(this.contractWrapper, "ERC1155BatchMintable")) {
      return new Erc1155BatchMintable(this.erc1155, this.contractWrapper, this.storage);
    }
    return void 0;
  }
};
var Erc1155SignatureMintable = class {
  constructor(contractWrapper, storage, roles) {
    _defineProperty(this, "featureName", FEATURE_EDITION_SIGNATURE_MINTABLE.name);
    _defineProperty(this, "contractWrapper", void 0);
    _defineProperty(this, "storage", void 0);
    _defineProperty(this, "roles", void 0);
    this.contractWrapper = contractWrapper;
    this.storage = storage;
    this.roles = roles;
  }
  async mint(signedPayload) {
    const mintRequest = signedPayload.payload;
    const signature = signedPayload.signature;
    const message = await this.mapPayloadToContractStruct(mintRequest);
    const overrides = await this.contractWrapper.getCallOverrides();
    await setErc20Allowance(this.contractWrapper, message.pricePerToken.mul(message.quantity), mintRequest.currencyAddress, overrides);
    const receipt = await this.contractWrapper.sendTransaction("mintWithSignature", [message, signature], overrides);
    const t = this.contractWrapper.parseLogs("TokensMintedWithSignature", receipt.logs);
    if (t.length === 0) {
      throw new Error("No MintWithSignature event found");
    }
    const id = t[0].args.tokenIdMinted;
    return {
      id,
      receipt
    };
  }
  async mintBatch(signedPayloads) {
    const contractPayloads = await Promise.all(signedPayloads.map(async (s) => {
      const message = await this.mapPayloadToContractStruct(s.payload);
      const signature = s.signature;
      const price = s.payload.price;
      if (BigNumber.from(price).gt(0)) {
        throw new Error("Can only batch free mints. For mints with a price, use regular mint()");
      }
      return {
        message,
        signature
      };
    }));
    const encoded = contractPayloads.map((p) => {
      return this.contractWrapper.readContract.interface.encodeFunctionData("mintWithSignature", [p.message, p.signature]);
    });
    const receipt = await this.contractWrapper.multiCall(encoded);
    const events = this.contractWrapper.parseLogs("TokensMintedWithSignature", receipt.logs);
    if (events.length === 0) {
      throw new Error("No MintWithSignature event found");
    }
    return events.map((log) => ({
      id: log.args.tokenIdMinted,
      receipt
    }));
  }
  async verify(signedPayload) {
    const mintRequest = signedPayload.payload;
    const signature = signedPayload.signature;
    const message = await this.mapPayloadToContractStruct(mintRequest);
    const verification = await this.contractWrapper.readContract.verify(message, signature);
    return verification[0];
  }
  async generate(payloadToSign) {
    const payload = {
      ...payloadToSign,
      tokenId: ethers_exports.constants.MaxUint256
    };
    return this.generateFromTokenId(payload);
  }
  async generateFromTokenId(payloadToSign) {
    const payloads = await this.generateBatchFromTokenIds([payloadToSign]);
    return payloads[0];
  }
  async generateBatch(payloadsToSign) {
    const payloads = payloadsToSign.map((payload) => ({
      ...payload,
      tokenId: ethers_exports.constants.MaxUint256
    }));
    return this.generateBatchFromTokenIds(payloads);
  }
  async generateBatchFromTokenIds(payloadsToSign) {
    var _a;
    await ((_a = this.roles) == null ? void 0 : _a.verify(["minter"], await this.contractWrapper.getSignerAddress()));
    const parsedRequests = payloadsToSign.map((m) => Signature1155PayloadInputWithTokenId.parse(m));
    const metadatas = parsedRequests.map((r) => r.metadata);
    const uris = await uploadOrExtractURIs(metadatas, this.storage);
    const chainId = await this.contractWrapper.getChainID();
    const signer = this.contractWrapper.getSigner();
    invariant(signer, "No signer available");
    const contractInfo = await getPrebuiltInfo(this.contractWrapper.readContract.address, this.contractWrapper.getProvider());
    const isLegacyContract = (contractInfo == null ? void 0 : contractInfo.type) === "TokenERC1155";
    return await Promise.all(parsedRequests.map(async (m, i) => {
      const uri = uris[i];
      const finalPayload = Signature1155PayloadOutput.parse({
        ...m,
        uri
      });
      const signature = await this.contractWrapper.signTypedData(
        signer,
        {
          name: isLegacyContract ? "TokenERC1155" : "SignatureMintERC1155",
          version: "1",
          chainId,
          verifyingContract: this.contractWrapper.readContract.address
        },
        {
          MintRequest: MintRequest1155
        },
        await this.mapPayloadToContractStruct(finalPayload)
      );
      return {
        payload: finalPayload,
        signature: signature.toString()
      };
    }));
  }
  async mapPayloadToContractStruct(mintRequest) {
    const normalizedPricePerToken = await normalizePriceValue(this.contractWrapper.getProvider(), mintRequest.price, mintRequest.currencyAddress);
    return {
      to: mintRequest.to,
      tokenId: mintRequest.tokenId,
      uri: mintRequest.uri,
      quantity: mintRequest.quantity,
      pricePerToken: normalizedPricePerToken,
      currency: mintRequest.currencyAddress,
      validityStartTimestamp: mintRequest.mintStartTime,
      validityEndTimestamp: mintRequest.mintEndTime,
      uid: mintRequest.uid,
      royaltyRecipient: mintRequest.royaltyRecipient,
      royaltyBps: mintRequest.royaltyBps,
      primarySaleRecipient: mintRequest.primarySaleRecipient
    };
  }
};
var Erc1155 = class {
  get chainId() {
    return this._chainId;
  }
  constructor(contractWrapper, storage, chainId) {
    _defineProperty(this, "featureName", FEATURE_EDITION.name);
    _defineProperty(this, "query", void 0);
    _defineProperty(this, "mintable", void 0);
    _defineProperty(this, "burnable", void 0);
    _defineProperty(this, "lazyMintable", void 0);
    _defineProperty(this, "signatureMintable", void 0);
    _defineProperty(this, "contractWrapper", void 0);
    _defineProperty(this, "storage", void 0);
    _defineProperty(this, "_chainId", void 0);
    this.contractWrapper = contractWrapper;
    this.storage = storage;
    this.query = this.detectErc1155Enumerable();
    this.mintable = this.detectErc1155Mintable();
    this.burnable = this.detectErc1155Burnable();
    this.lazyMintable = this.detectErc1155LazyMintable();
    this.signatureMintable = this.detectErc1155SignatureMintable();
    this._chainId = chainId;
  }
  onNetworkUpdated(network) {
    this.contractWrapper.updateSignerOrProvider(network);
  }
  getAddress() {
    return this.contractWrapper.readContract.address;
  }
  async get(tokenId) {
    const [supply, metadata] = await Promise.all([this.contractWrapper.readContract.totalSupply(tokenId).catch(() => BigNumber.from(0)), this.getTokenMetadata(tokenId).catch(() => ({
      id: tokenId.toString(),
      uri: "",
      ...FALLBACK_METADATA
    }))]);
    return {
      owner: ethers_exports.constants.AddressZero,
      metadata,
      type: "ERC1155",
      supply: supply.toNumber()
    };
  }
  async totalSupply(tokenId) {
    return await this.contractWrapper.readContract.totalSupply(tokenId);
  }
  async balanceOf(address, tokenId) {
    return await this.contractWrapper.readContract.balanceOf(address, tokenId);
  }
  async balance(tokenId) {
    return await this.balanceOf(await this.contractWrapper.getSignerAddress(), tokenId);
  }
  async isApproved(address, operator) {
    return await this.contractWrapper.readContract.isApprovedForAll(address, operator);
  }
  async transfer(to, tokenId, amount) {
    let data = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : [0];
    const from = await this.contractWrapper.getSignerAddress();
    return {
      receipt: await this.contractWrapper.sendTransaction("safeTransferFrom", [from, to, tokenId, amount, data])
    };
  }
  async setApprovalForAll(operator, approved) {
    return {
      receipt: await this.contractWrapper.sendTransaction("setApprovalForAll", [operator, approved])
    };
  }
  async airdrop(tokenId, addresses) {
    let data = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : [0];
    const from = await this.contractWrapper.getSignerAddress();
    const balanceOf = await this.balanceOf(from, tokenId);
    const input = AirdropInputSchema.parse(addresses);
    const totalToAirdrop = input.reduce((prev, curr) => {
      return prev + Number((curr == null ? void 0 : curr.quantity) || 1);
    }, 0);
    if (balanceOf.toNumber() < totalToAirdrop) {
      throw new Error(`The caller owns ${balanceOf.toNumber()} NFTs, but wants to airdrop ${totalToAirdrop} NFTs.`);
    }
    const encoded = input.map((_ref) => {
      let {
        address: to,
        quantity
      } = _ref;
      return this.contractWrapper.readContract.interface.encodeFunctionData("safeTransferFrom", [from, to, tokenId, quantity, data]);
    });
    return {
      receipt: await this.contractWrapper.multiCall(encoded)
    };
  }
  async nextTokenIdToMint() {
    if (hasFunction("nextTokenIdToMint", this.contractWrapper)) {
      return await this.contractWrapper.readContract.nextTokenIdToMint();
    } else {
      throw new Error("Contract requires the `nextTokenIdToMint` function available to determine the next token ID to mint");
    }
  }
  async getAll(queryParams) {
    return assertEnabled(this.query, FEATURE_EDITION_ENUMERABLE).all(queryParams);
  }
  async totalCount() {
    return assertEnabled(this.query, FEATURE_EDITION_ENUMERABLE).totalCount();
  }
  async totalCirculatingSupply(tokenId) {
    return assertEnabled(this.query, FEATURE_EDITION_ENUMERABLE).totalCirculatingSupply(tokenId);
  }
  async getOwned(walletAddress) {
    return assertEnabled(this.query, FEATURE_EDITION_ENUMERABLE).owned(walletAddress);
  }
  async mint(metadataWithSupply) {
    return this.mintTo(await this.contractWrapper.getSignerAddress(), metadataWithSupply);
  }
  async mintTo(receiver, metadataWithSupply) {
    return assertEnabled(this.mintable, FEATURE_EDITION_MINTABLE).to(receiver, metadataWithSupply);
  }
  async mintAdditionalSupply(tokenId, additionalSupply) {
    return assertEnabled(this.mintable, FEATURE_EDITION_MINTABLE).additionalSupplyTo(await this.contractWrapper.getSignerAddress(), tokenId, additionalSupply);
  }
  async mintAdditionalSupplyTo(receiver, tokenId, additionalSupply) {
    return assertEnabled(this.mintable, FEATURE_EDITION_MINTABLE).additionalSupplyTo(receiver, tokenId, additionalSupply);
  }
  async mintBatch(metadataWithSupply) {
    return this.mintBatchTo(await this.contractWrapper.getSignerAddress(), metadataWithSupply);
  }
  async mintBatchTo(receiver, metadataWithSupply) {
    var _a;
    return assertEnabled((_a = this.mintable) == null ? void 0 : _a.batch, FEATURE_EDITION_BATCH_MINTABLE).to(receiver, metadataWithSupply);
  }
  async burn(tokenId, amount) {
    return assertEnabled(this.burnable, FEATURE_EDITION_BURNABLE).tokens(tokenId, amount);
  }
  async burnFrom(account, tokenId, amount) {
    return assertEnabled(this.burnable, FEATURE_EDITION_BURNABLE).from(account, tokenId, amount);
  }
  async burnBatch(tokenIds, amounts) {
    return assertEnabled(this.burnable, FEATURE_EDITION_BURNABLE).batch(tokenIds, amounts);
  }
  async burnBatchFrom(account, tokenIds, amounts) {
    return assertEnabled(this.burnable, FEATURE_EDITION_BURNABLE).batchFrom(account, tokenIds, amounts);
  }
  async lazyMint(metadatas, options) {
    return assertEnabled(this.lazyMintable, FEATURE_EDITION_LAZY_MINTABLE_V2).lazyMint(metadatas, options);
  }
  async getClaimTransaction(destinationAddress, tokenId, quantity, options) {
    var _a, _b;
    const claimWithConditions = (_a = this.lazyMintable) == null ? void 0 : _a.claimWithConditions;
    const claim = (_b = this.lazyMintable) == null ? void 0 : _b.claim;
    if (claimWithConditions) {
      return claimWithConditions.conditions.getClaimTransaction(destinationAddress, tokenId, quantity, options);
    }
    if (claim) {
      return claim.getClaimTransaction(destinationAddress, tokenId, quantity, options);
    }
    throw new ExtensionNotImplementedError(FEATURE_EDITION_CLAIM_CUSTOM);
  }
  async claim(tokenId, quantity, options) {
    return this.claimTo(await this.contractWrapper.getSignerAddress(), tokenId, quantity, options);
  }
  async claimTo(destinationAddress, tokenId, quantity, options) {
    var _a, _b;
    const claimWithConditions = (_a = this.lazyMintable) == null ? void 0 : _a.claimWithConditions;
    const claim = (_b = this.lazyMintable) == null ? void 0 : _b.claim;
    if (claimWithConditions) {
      return claimWithConditions.to(destinationAddress, tokenId, quantity, options);
    }
    if (claim) {
      return claim.to(destinationAddress, tokenId, quantity, options);
    }
    throw new ExtensionNotImplementedError(FEATURE_EDITION_CLAIM_CUSTOM);
  }
  get claimConditions() {
    var _a;
    return assertEnabled((_a = this.lazyMintable) == null ? void 0 : _a.claimWithConditions, FEATURE_EDITION_CLAIM_CONDITIONS_V2).conditions;
  }
  get signature() {
    return assertEnabled(this.signatureMintable, FEATURE_EDITION_SIGNATURE_MINTABLE);
  }
  get revealer() {
    var _a;
    return assertEnabled((_a = this.lazyMintable) == null ? void 0 : _a.revealer, FEATURE_EDITION_REVEALABLE);
  }
  async getTokenMetadata(tokenId) {
    const tokenUri = await this.contractWrapper.readContract.uri(tokenId);
    if (!tokenUri) {
      throw new NotFoundError();
    }
    return fetchTokenMetadata(tokenId, tokenUri, this.storage);
  }
  detectErc1155Enumerable() {
    if (detectContractFeature(this.contractWrapper, "ERC1155Enumerable")) {
      return new Erc1155Enumerable(this, this.contractWrapper);
    }
    return void 0;
  }
  detectErc1155Mintable() {
    if (detectContractFeature(this.contractWrapper, "ERC1155Mintable")) {
      return new Erc1155Mintable(this, this.contractWrapper, this.storage);
    }
    return void 0;
  }
  detectErc1155Burnable() {
    if (detectContractFeature(this.contractWrapper, "ERC1155Burnable")) {
      return new Erc1155Burnable(this.contractWrapper);
    }
    return void 0;
  }
  detectErc1155LazyMintable() {
    if (detectContractFeature(this.contractWrapper, "ERC1155LazyMintableV1") || detectContractFeature(this.contractWrapper, "ERC1155LazyMintableV2")) {
      return new Erc1155LazyMintable(this, this.contractWrapper, this.storage);
    }
    return void 0;
  }
  detectErc1155SignatureMintable() {
    if (detectContractFeature(this.contractWrapper, "ERC1155SignatureMintable")) {
      return new Erc1155SignatureMintable(this.contractWrapper, this.storage);
    }
    return void 0;
  }
};
var StandardErc1155 = class {
  get chainId() {
    return this._chainId;
  }
  constructor(contractWrapper, storage, chainId) {
    _defineProperty(this, "contractWrapper", void 0);
    _defineProperty(this, "storage", void 0);
    _defineProperty(this, "erc1155", void 0);
    _defineProperty(this, "_chainId", void 0);
    this.contractWrapper = contractWrapper;
    this.storage = storage;
    this.erc1155 = new Erc1155(this.contractWrapper, this.storage, chainId);
    this._chainId = chainId;
  }
  onNetworkUpdated(network) {
    this.contractWrapper.updateSignerOrProvider(network);
  }
  getAddress() {
    return this.contractWrapper.readContract.address;
  }
  async get(tokenId) {
    return this.erc1155.get(tokenId);
  }
  async totalSupply(tokenId) {
    return this.erc1155.totalSupply(tokenId);
  }
  async balanceOf(address, tokenId) {
    return this.erc1155.balanceOf(address, tokenId);
  }
  async balance(tokenId) {
    return this.erc1155.balance(tokenId);
  }
  async isApproved(address, operator) {
    return this.erc1155.isApproved(address, operator);
  }
  async transfer(to, tokenId, amount) {
    let data = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : [0];
    return this.erc1155.transfer(to, tokenId, amount, data);
  }
  async setApprovalForAll(operator, approved) {
    return this.erc1155.setApprovalForAll(operator, approved);
  }
  async airdrop(tokenId, addresses) {
    let data = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : [0];
    return this.erc1155.airdrop(tokenId, addresses, data);
  }
};
async function isTokenApprovedForTransfer(provider, transferrerContractAddress, assetContract, tokenId, owner) {
  try {
    const erc165 = new Contract(assetContract, IERC165_default, provider);
    const isERC721 = await erc165.supportsInterface(InterfaceId_IERC721);
    const isERC1155 = await erc165.supportsInterface(InterfaceId_IERC1155);
    if (isERC721) {
      const asset = new Contract(assetContract, IERC721_default, provider);
      const approved = await asset.isApprovedForAll(owner, transferrerContractAddress);
      if (approved) {
        return true;
      }
      return (await asset.getApproved(tokenId)).toLowerCase() === transferrerContractAddress.toLowerCase();
    } else if (isERC1155) {
      const asset = new Contract(assetContract, IERC1155_default, provider);
      return await asset.isApprovedForAll(owner, transferrerContractAddress);
    } else {
      console.error("Contract does not implement ERC 1155 or ERC 721.");
      return false;
    }
  } catch (err) {
    console.error("Failed to check if token is approved", err);
    return false;
  }
}
async function handleTokenApproval(contractWrapper, marketplaceAddress, assetContract, tokenId, from) {
  const erc165 = new ContractWrapper(contractWrapper.getSignerOrProvider(), assetContract, IERC165_default, contractWrapper.options);
  const isERC721 = await erc165.readContract.supportsInterface(InterfaceId_IERC721);
  const isERC1155 = await erc165.readContract.supportsInterface(InterfaceId_IERC1155);
  if (isERC721) {
    const asset = new ContractWrapper(contractWrapper.getSignerOrProvider(), assetContract, IERC721_default, contractWrapper.options);
    const approved = await asset.readContract.isApprovedForAll(from, marketplaceAddress);
    if (!approved) {
      const isTokenApproved = (await asset.readContract.getApproved(tokenId)).toLowerCase() === marketplaceAddress.toLowerCase();
      if (!isTokenApproved) {
        await asset.sendTransaction("setApprovalForAll", [marketplaceAddress, true]);
      }
    }
  } else if (isERC1155) {
    const asset = new ContractWrapper(contractWrapper.getSignerOrProvider(), assetContract, IERC1155_default, contractWrapper.options);
    const approved = await asset.readContract.isApprovedForAll(from, marketplaceAddress);
    if (!approved) {
      await asset.sendTransaction("setApprovalForAll", [marketplaceAddress, true]);
    }
  } else {
    throw Error("Contract must implement ERC 1155 or ERC 721.");
  }
}
function validateNewListingParam(param) {
  invariant(param.assetContractAddress !== void 0 && param.assetContractAddress !== null, "Asset contract address is required");
  invariant(param.buyoutPricePerToken !== void 0 && param.buyoutPricePerToken !== null, "Buyout price is required");
  invariant(param.listingDurationInSeconds !== void 0 && param.listingDurationInSeconds !== null, "Listing duration is required");
  invariant(param.startTimestamp !== void 0 && param.startTimestamp !== null, "Start time is required");
  invariant(param.tokenId !== void 0 && param.tokenId !== null, "Token ID is required");
  invariant(param.quantity !== void 0 && param.quantity !== null, "Quantity is required");
  switch (param.type) {
    case "NewAuctionListing": {
      invariant(param.reservePricePerToken !== void 0 && param.reservePricePerToken !== null, "Reserve price is required");
    }
  }
}
async function mapOffer(provider, listingId, offer) {
  return {
    quantity: offer.quantityDesired,
    pricePerToken: offer.pricePerToken,
    currencyContractAddress: offer.currency,
    buyerAddress: offer.offeror,
    quantityDesired: offer.quantityWanted,
    currencyValue: await fetchCurrencyValue(provider, offer.currency, offer.quantityWanted.mul(offer.pricePerToken)),
    listingId
  };
}
function isWinningBid(winningPrice, newBidPrice, bidBuffer) {
  bidBuffer = BigNumber.from(bidBuffer);
  winningPrice = BigNumber.from(winningPrice);
  newBidPrice = BigNumber.from(newBidPrice);
  if (winningPrice.eq(BigNumber.from(0))) {
    return false;
  }
  const buffer = newBidPrice.sub(winningPrice).mul(MAX_BPS).div(winningPrice);
  return buffer.gte(bidBuffer);
}
var MarketplaceDirect = class {
  constructor(contractWrapper, storage) {
    _defineProperty(this, "contractWrapper", void 0);
    _defineProperty(this, "storage", void 0);
    this.contractWrapper = contractWrapper;
    this.storage = storage;
  }
  getAddress() {
    return this.contractWrapper.readContract.address;
  }
  async getListing(listingId) {
    const listing = await this.contractWrapper.readContract.listings(listingId);
    if (listing.assetContract === lib_exports.AddressZero) {
      throw new ListingNotFoundError(this.getAddress(), listingId.toString());
    }
    if (listing.listingType !== ListingType.Direct) {
      throw new WrongListingTypeError(this.getAddress(), listingId.toString(), "Auction", "Direct");
    }
    return await this.mapListing(listing);
  }
  async getActiveOffer(listingId, address) {
    await this.validateListing(BigNumber.from(listingId));
    invariant(utils_exports.isAddress(address), "Address must be a valid address");
    const offers = await this.contractWrapper.readContract.offers(listingId, address);
    if (offers.offeror === lib_exports.AddressZero) {
      return void 0;
    }
    return await mapOffer(this.contractWrapper.getProvider(), BigNumber.from(listingId), offers);
  }
  async createListing(listing) {
    validateNewListingParam(listing);
    await handleTokenApproval(this.contractWrapper, this.getAddress(), listing.assetContractAddress, listing.tokenId, await this.contractWrapper.getSignerAddress());
    const normalizedPricePerToken = await normalizePriceValue(this.contractWrapper.getProvider(), listing.buyoutPricePerToken, listing.currencyContractAddress);
    let listingStartTime = Math.floor(listing.startTimestamp.getTime() / 1e3);
    const block = await this.contractWrapper.getProvider().getBlock("latest");
    const blockTime = block.timestamp;
    if (listingStartTime < blockTime) {
      listingStartTime = blockTime;
    }
    const receipt = await this.contractWrapper.sendTransaction("createListing", [{
      assetContract: listing.assetContractAddress,
      tokenId: listing.tokenId,
      buyoutPricePerToken: normalizedPricePerToken,
      currencyToAccept: cleanCurrencyAddress(listing.currencyContractAddress),
      listingType: ListingType.Direct,
      quantityToList: listing.quantity,
      reservePricePerToken: normalizedPricePerToken,
      secondsUntilEndTime: listing.listingDurationInSeconds,
      startTime: BigNumber.from(listingStartTime)
    }], {
      gasLimit: 5e5
    });
    const event = this.contractWrapper.parseLogs("ListingAdded", receipt == null ? void 0 : receipt.logs);
    return {
      id: event[0].args.listingId,
      receipt
    };
  }
  async makeOffer(listingId, quantityDesired, currencyContractAddress, pricePerToken, expirationDate) {
    if (isNativeToken(currencyContractAddress)) {
      throw new Error("You must use the wrapped native token address when making an offer with a native token");
    }
    const normalizedPrice = await normalizePriceValue(this.contractWrapper.getProvider(), pricePerToken, currencyContractAddress);
    try {
      await this.getListing(listingId);
    } catch (err) {
      console.error("Failed to get listing, err =", err);
      throw new Error(`Error getting the listing with id ${listingId}`);
    }
    const quantity = BigNumber.from(quantityDesired);
    const value = BigNumber.from(normalizedPrice).mul(quantity);
    const overrides = await this.contractWrapper.getCallOverrides() || {};
    await setErc20Allowance(this.contractWrapper, value, currencyContractAddress, overrides);
    let expirationTimestamp = ethers_exports.constants.MaxUint256;
    if (expirationDate) {
      expirationTimestamp = BigNumber.from(Math.floor(expirationDate.getTime() / 1e3));
    }
    return {
      receipt: await this.contractWrapper.sendTransaction("offer", [listingId, quantityDesired, currencyContractAddress, normalizedPrice, expirationTimestamp], overrides)
    };
  }
  async acceptOffer(listingId, addressOfOfferor) {
    await this.validateListing(BigNumber.from(listingId));
    const offer = await this.contractWrapper.readContract.offers(listingId, addressOfOfferor);
    return {
      receipt: await this.contractWrapper.sendTransaction("acceptOffer", [listingId, addressOfOfferor, offer.currency, offer.pricePerToken])
    };
  }
  async buyoutListing(listingId, quantityDesired, receiver) {
    const listing = await this.validateListing(BigNumber.from(listingId));
    const {
      valid,
      error
    } = await this.isStillValidListing(listing, quantityDesired);
    if (!valid) {
      throw new Error(`Listing ${listingId} is no longer valid. ${error}`);
    }
    const buyFor = receiver ? receiver : await this.contractWrapper.getSignerAddress();
    const quantity = BigNumber.from(quantityDesired);
    const value = BigNumber.from(listing.buyoutPrice).mul(quantity);
    const overrides = await this.contractWrapper.getCallOverrides() || {};
    await setErc20Allowance(this.contractWrapper, value, listing.currencyContractAddress, overrides);
    return {
      receipt: await this.contractWrapper.sendTransaction("buy", [listingId, buyFor, quantity, listing.currencyContractAddress, value], overrides)
    };
  }
  async updateListing(listing) {
    return {
      receipt: await this.contractWrapper.sendTransaction("updateListing", [
        listing.id,
        listing.quantity,
        listing.buyoutPrice,
        listing.buyoutPrice,
        listing.currencyContractAddress,
        listing.startTimeInSeconds,
        listing.secondsUntilEnd
      ])
    };
  }
  async cancelListing(listingId) {
    return {
      receipt: await this.contractWrapper.sendTransaction("cancelDirectListing", [listingId])
    };
  }
  async validateListing(listingId) {
    try {
      return await this.getListing(listingId);
    } catch (err) {
      console.error(`Error getting the listing with id ${listingId}`);
      throw err;
    }
  }
  async mapListing(listing) {
    return {
      assetContractAddress: listing.assetContract,
      buyoutPrice: BigNumber.from(listing.buyoutPricePerToken),
      currencyContractAddress: listing.currency,
      buyoutCurrencyValuePerToken: await fetchCurrencyValue(this.contractWrapper.getProvider(), listing.currency, listing.buyoutPricePerToken),
      id: listing.listingId.toString(),
      tokenId: listing.tokenId,
      quantity: listing.quantity,
      startTimeInSeconds: listing.startTime,
      asset: await fetchTokenMetadataForContract(listing.assetContract, this.contractWrapper.getProvider(), listing.tokenId, this.storage),
      secondsUntilEnd: listing.endTime,
      sellerAddress: listing.tokenOwner,
      type: ListingType.Direct
    };
  }
  async isStillValidListing(listing, quantity) {
    const approved = await isTokenApprovedForTransfer(this.contractWrapper.getProvider(), this.getAddress(), listing.assetContractAddress, listing.tokenId, listing.sellerAddress);
    if (!approved) {
      return {
        valid: false,
        error: `Token '${listing.tokenId}' from contract '${listing.assetContractAddress}' is not approved for transfer`
      };
    }
    const provider = this.contractWrapper.getProvider();
    const erc165 = new Contract(listing.assetContractAddress, IERC165_default, provider);
    const isERC721 = await erc165.supportsInterface(InterfaceId_IERC721);
    const isERC1155 = await erc165.supportsInterface(InterfaceId_IERC1155);
    if (isERC721) {
      const asset = new Contract(listing.assetContractAddress, IERC721_default, provider);
      const valid = (await asset.ownerOf(listing.tokenId)).toLowerCase() === listing.sellerAddress.toLowerCase();
      return {
        valid,
        error: valid ? void 0 : `Seller is not the owner of Token '${listing.tokenId}' from contract '${listing.assetContractAddress} anymore'`
      };
    } else if (isERC1155) {
      const asset = new Contract(listing.assetContractAddress, IERC1155_default, provider);
      const balance = await asset.balanceOf(listing.sellerAddress, listing.tokenId);
      const valid = balance.gte(quantity || listing.quantity);
      return {
        valid,
        error: valid ? void 0 : `Seller does not have enough balance of Token '${listing.tokenId}' from contract '${listing.assetContractAddress} to fulfill the listing`
      };
    } else {
      return {
        valid: false,
        error: "Contract does not implement ERC 1155 or ERC 721."
      };
    }
  }
};
var MarketplaceAuction = class {
  constructor(contractWrapper, storage) {
    _defineProperty(this, "contractWrapper", void 0);
    _defineProperty(this, "storage", void 0);
    _defineProperty(this, "encoder", void 0);
    this.contractWrapper = contractWrapper;
    this.storage = storage;
    this.encoder = new ContractEncoder(contractWrapper);
  }
  getAddress() {
    return this.contractWrapper.readContract.address;
  }
  async getListing(listingId) {
    const listing = await this.contractWrapper.readContract.listings(listingId);
    if (listing.listingId.toString() !== listingId.toString()) {
      throw new ListingNotFoundError(this.getAddress(), listingId.toString());
    }
    if (listing.listingType !== ListingType.Auction) {
      throw new WrongListingTypeError(this.getAddress(), listingId.toString(), "Direct", "Auction");
    }
    return await this.mapListing(listing);
  }
  async getWinningBid(listingId) {
    await this.validateListing(BigNumber.from(listingId));
    const offers = await this.contractWrapper.readContract.winningBid(listingId);
    if (offers.offeror === lib_exports.AddressZero) {
      return void 0;
    }
    return await mapOffer(this.contractWrapper.getProvider(), BigNumber.from(listingId), offers);
  }
  async getWinner(listingId) {
    const listing = await this.validateListing(BigNumber.from(listingId));
    const offers = await this.contractWrapper.readContract.winningBid(listingId);
    const now = BigNumber.from(Math.floor(Date.now() / 1e3));
    const endTime = BigNumber.from(listing.endTimeInEpochSeconds);
    if (now.gt(endTime) && offers.offeror !== lib_exports.AddressZero) {
      return offers.offeror;
    }
    const closedAuctions = await this.contractWrapper.readContract.queryFilter(this.contractWrapper.readContract.filters.AuctionClosed());
    const auction = closedAuctions.find((a) => a.args.listingId.eq(BigNumber.from(listingId)));
    if (!auction) {
      throw new Error(`Could not find auction with listingId ${listingId} in closed auctions`);
    }
    return auction.args.winningBidder;
  }
  async createListing(listing) {
    validateNewListingParam(listing);
    await handleTokenApproval(this.contractWrapper, this.getAddress(), listing.assetContractAddress, listing.tokenId, await this.contractWrapper.getSignerAddress());
    const normalizedPricePerToken = await normalizePriceValue(this.contractWrapper.getProvider(), listing.buyoutPricePerToken, listing.currencyContractAddress);
    const normalizedReservePrice = await normalizePriceValue(this.contractWrapper.getProvider(), listing.reservePricePerToken, listing.currencyContractAddress);
    let listingStartTime = Math.floor(listing.startTimestamp.getTime() / 1e3);
    const block = await this.contractWrapper.getProvider().getBlock("latest");
    const blockTime = block.timestamp;
    if (listingStartTime < blockTime) {
      listingStartTime = blockTime;
    }
    const receipt = await this.contractWrapper.sendTransaction("createListing", [{
      assetContract: listing.assetContractAddress,
      tokenId: listing.tokenId,
      buyoutPricePerToken: normalizedPricePerToken,
      currencyToAccept: cleanCurrencyAddress(listing.currencyContractAddress),
      listingType: ListingType.Auction,
      quantityToList: listing.quantity,
      reservePricePerToken: normalizedReservePrice,
      secondsUntilEndTime: listing.listingDurationInSeconds,
      startTime: BigNumber.from(listingStartTime)
    }], {
      gasLimit: 5e5
    });
    const event = this.contractWrapper.parseLogs("ListingAdded", receipt == null ? void 0 : receipt.logs);
    return {
      id: event[0].args.listingId,
      receipt
    };
  }
  async buyoutListing(listingId) {
    const listing = await this.validateListing(BigNumber.from(listingId));
    const currencyMetadata = await fetchCurrencyMetadata(this.contractWrapper.getProvider(), listing.currencyContractAddress);
    return this.makeBid(listingId, ethers_exports.utils.formatUnits(listing.buyoutPrice, currencyMetadata.decimals));
  }
  async makeBid(listingId, pricePerToken) {
    const listing = await this.validateListing(BigNumber.from(listingId));
    const normalizedPrice = await normalizePriceValue(this.contractWrapper.getProvider(), pricePerToken, listing.currencyContractAddress);
    if (normalizedPrice.eq(BigNumber.from(0))) {
      throw new Error("Cannot make a bid with 0 value");
    }
    const bidBuffer = await this.contractWrapper.readContract.bidBufferBps();
    const winningBid = await this.getWinningBid(listingId);
    if (winningBid) {
      const isWinnner = isWinningBid(winningBid.pricePerToken, normalizedPrice, bidBuffer);
      invariant(isWinnner, "Bid price is too low based on the current winning bid and the bid buffer");
    } else {
      const tokenPrice = normalizedPrice;
      const reservePrice = BigNumber.from(listing.reservePrice);
      invariant(tokenPrice.gte(reservePrice), "Bid price is too low based on reserve price");
    }
    const quantity = BigNumber.from(listing.quantity);
    const value = normalizedPrice.mul(quantity);
    const overrides = await this.contractWrapper.getCallOverrides() || {};
    await setErc20Allowance(this.contractWrapper, value, listing.currencyContractAddress, overrides);
    return {
      receipt: await this.contractWrapper.sendTransaction("offer", [listingId, listing.quantity, listing.currencyContractAddress, normalizedPrice, ethers_exports.constants.MaxUint256], overrides)
    };
  }
  async cancelListing(listingId) {
    const listing = await this.validateListing(BigNumber.from(listingId));
    const now = BigNumber.from(Math.floor(Date.now() / 1e3));
    const startTime = BigNumber.from(listing.startTimeInEpochSeconds);
    const offers = await this.contractWrapper.readContract.winningBid(listingId);
    if (now.gt(startTime) && offers.offeror !== lib_exports.AddressZero) {
      throw new AuctionAlreadyStartedError(listingId.toString());
    }
    return {
      receipt: await this.contractWrapper.sendTransaction("closeAuction", [BigNumber.from(listingId), await this.contractWrapper.getSignerAddress()])
    };
  }
  async closeListing(listingId, closeFor) {
    if (!closeFor) {
      closeFor = await this.contractWrapper.getSignerAddress();
    }
    const listing = await this.validateListing(BigNumber.from(listingId));
    try {
      return {
        receipt: await this.contractWrapper.sendTransaction("closeAuction", [BigNumber.from(listingId), closeFor])
      };
    } catch (err) {
      if (err.message.includes("cannot close auction before it has ended")) {
        throw new AuctionHasNotEndedError(listingId.toString(), listing.endTimeInEpochSeconds.toString());
      } else {
        throw err;
      }
    }
  }
  async executeSale(listingId) {
    const listing = await this.validateListing(BigNumber.from(listingId));
    try {
      const winningBid = await this.getWinningBid(listingId);
      invariant(winningBid, "No winning bid found");
      const closeForSeller = this.encoder.encode("closeAuction", [listingId, listing.sellerAddress]);
      const closeForBuyer = this.encoder.encode("closeAuction", [listingId, winningBid.buyerAddress]);
      return await this.contractWrapper.multiCall([closeForSeller, closeForBuyer]);
    } catch (err) {
      if (err.message.includes("cannot close auction before it has ended")) {
        throw new AuctionHasNotEndedError(listingId.toString(), listing.endTimeInEpochSeconds.toString());
      } else {
        throw err;
      }
    }
  }
  async updateListing(listing) {
    return {
      receipt: await this.contractWrapper.sendTransaction("updateListing", [listing.id, listing.quantity, listing.reservePrice, listing.buyoutPrice, listing.currencyContractAddress, listing.startTimeInEpochSeconds, listing.endTimeInEpochSeconds])
    };
  }
  async getBidBufferBps() {
    return this.contractWrapper.readContract.bidBufferBps();
  }
  async getMinimumNextBid(listingId) {
    const [currentBidBufferBps, winningBid, listing] = await Promise.all([this.getBidBufferBps(), this.getWinningBid(listingId), await this.validateListing(BigNumber.from(listingId))]);
    const currentBidOrReservePrice = winningBid ? winningBid.currencyValue.value : listing.reservePrice;
    const minimumNextBid = currentBidOrReservePrice.add(
      currentBidOrReservePrice.mul(currentBidBufferBps).div(1e4)
    );
    return fetchCurrencyValue(this.contractWrapper.getProvider(), listing.currencyContractAddress, minimumNextBid);
  }
  async validateListing(listingId) {
    try {
      return await this.getListing(listingId);
    } catch (err) {
      console.error(`Error getting the listing with id ${listingId}`);
      throw err;
    }
  }
  async mapListing(listing) {
    return {
      assetContractAddress: listing.assetContract,
      buyoutPrice: BigNumber.from(listing.buyoutPricePerToken),
      currencyContractAddress: listing.currency,
      buyoutCurrencyValuePerToken: await fetchCurrencyValue(this.contractWrapper.getProvider(), listing.currency, listing.buyoutPricePerToken),
      id: listing.listingId.toString(),
      tokenId: listing.tokenId,
      quantity: listing.quantity,
      startTimeInEpochSeconds: listing.startTime,
      asset: await fetchTokenMetadataForContract(listing.assetContract, this.contractWrapper.getProvider(), listing.tokenId, this.storage),
      reservePriceCurrencyValuePerToken: await fetchCurrencyValue(this.contractWrapper.getProvider(), listing.currency, listing.reservePricePerToken),
      reservePrice: BigNumber.from(listing.reservePricePerToken),
      endTimeInEpochSeconds: listing.endTime,
      sellerAddress: listing.tokenOwner,
      type: ListingType.Auction
    };
  }
};
var DropErc20ContractInput = CommonContractSchema.merge(MerkleSchema).merge(CommonSymbolSchema);
var DropErc20ContractOutput = CommonContractOutputSchema.merge(MerkleSchema).merge(CommonSymbolSchema);
var DropErc20ContractDeploy = DropErc20ContractInput.merge(CommonPlatformFeeSchema).merge(CommonPrimarySaleSchema).merge(CommonTrustedForwarderSchema);
var DropErc20ContractSchema = {
  deploy: DropErc20ContractDeploy,
  output: DropErc20ContractOutput,
  input: DropErc20ContractInput
};
var MultiwrapContractInput = CommonContractSchema.merge(CommonRoyaltySchema).merge(CommonSymbolSchema);
var MultiwrapContractOutput = CommonContractOutputSchema.merge(CommonRoyaltySchema).merge(CommonSymbolSchema);
var MultiwrapContractDeploy = MultiwrapContractInput.merge(CommonTrustedForwarderSchema);
var MultiwrapContractSchema = {
  deploy: MultiwrapContractDeploy,
  output: MultiwrapContractOutput,
  input: MultiwrapContractInput
};
var EditionDropInitializer = {
  name: "DropERC1155",
  contractType: "edition-drop",
  schema: DropErc1155ContractSchema,
  roles: ["admin", "minter", "transfer"],
  initialize: async function() {
    for (var _len = arguments.length, _ref = new Array(_len), _key = 0; _key < _len; _key++) {
      _ref[_key] = arguments[_key];
    }
    let [network, address, storage, options] = _ref;
    const [, provider] = getSignerAndProvider(network, options);
    const [abi, contract, _network] = await Promise.all([await EditionDropInitializer.getAbi(address, provider), import("./edition-drop-f16cbe1e.esm-7LHRX4VY.js"), provider.getNetwork()]);
    return new contract.EditionDrop(network, address, storage, options, abi, _network.chainId);
  },
  getAbi: async (address, provider) => {
    const contractInfo = await getContractInfo(address, provider);
    return !contractInfo || contractInfo.version > 2 ? (await import("./DropERC1155-7UCWVYKV.js")).default : (await import("./DropERC1155_V2-FNGUGCET.js")).default;
  }
};
var EditionInitializer = {
  name: "TokenERC1155",
  contractType: "edition",
  schema: TokenErc1155ContractSchema,
  roles: ["admin", "minter", "transfer"],
  initialize: async function() {
    for (var _len2 = arguments.length, _ref2 = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
      _ref2[_key2] = arguments[_key2];
    }
    let [network, address, storage, options] = _ref2;
    const [, provider] = getSignerAndProvider(network, options);
    const [abi, contract, _network] = await Promise.all([EditionInitializer.getAbi(address, provider), import("./edition-63e45020.esm-UG27J7SH.js"), provider.getNetwork()]);
    return new contract.Edition(network, address, storage, options, abi, _network.chainId);
  },
  getAbi: async (address, provider) => {
    return (await import("./TokenERC1155-SO6LPWSE.js")).default;
  }
};
var MarketplaceInitializer = {
  name: "Marketplace",
  contractType: "marketplace",
  schema: MarketplaceContractSchema,
  roles: ["admin", "lister", "asset"],
  initialize: async function() {
    for (var _len3 = arguments.length, _ref3 = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
      _ref3[_key3] = arguments[_key3];
    }
    let [network, address, storage, options] = _ref3;
    const [, provider] = getSignerAndProvider(network, options);
    const [abi, contract, _network] = await Promise.all([MarketplaceInitializer.getAbi(address, provider), import("./marketplace-2a793a9e.esm-XI3Q6CAF.js"), provider.getNetwork()]);
    return new contract.Marketplace(network, address, storage, options, abi, _network.chainId);
  },
  getAbi: async (address, provider) => {
    return (await import("./Marketplace-WTCP2LWG.js")).default;
  }
};
var MultiwrapInitializer = {
  name: "Multiwrap",
  contractType: "multiwrap",
  schema: MultiwrapContractSchema,
  roles: ["admin", "transfer", "minter", "unwrap", "asset"],
  initialize: async function() {
    for (var _len4 = arguments.length, _ref4 = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
      _ref4[_key4] = arguments[_key4];
    }
    let [network, address, storage, options] = _ref4;
    const [, provider] = getSignerAndProvider(network, options);
    const [abi, contract, _network] = await Promise.all([MultiwrapInitializer.getAbi(address, provider), import("./multiwrap-51bc6646.esm-OU6CQFXN.js"), provider.getNetwork()]);
    return new contract.Multiwrap(network, address, storage, options, abi, _network.chainId);
  },
  getAbi: async (address, provider) => {
    return (await import("./Multiwrap-6CD2X7UC.js")).default;
  }
};
var NFTCollectionInitializer = {
  name: "TokenERC721",
  contractType: "nft-collection",
  schema: TokenErc721ContractSchema,
  roles: ["admin", "minter", "transfer"],
  initialize: async function() {
    for (var _len5 = arguments.length, _ref5 = new Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {
      _ref5[_key5] = arguments[_key5];
    }
    let [network, address, storage, options] = _ref5;
    const [, provider] = getSignerAndProvider(network, options);
    const [abi, contract, _network] = await Promise.all([NFTCollectionInitializer.getAbi(address, provider), import("./nft-collection-239c6356.esm-GEXCMSSR.js"), provider.getNetwork()]);
    return new contract.NFTCollection(network, address, storage, options, abi, _network.chainId);
  },
  getAbi: async (address, provider) => {
    return (await import("./TokenERC721-2KHP5ZFY.js")).default;
  }
};
var NFTDropInitializer = {
  name: "DropERC721",
  contractType: "nft-drop",
  schema: DropErc721ContractSchema,
  roles: ["admin", "minter", "transfer"],
  initialize: async function() {
    for (var _len6 = arguments.length, _ref6 = new Array(_len6), _key6 = 0; _key6 < _len6; _key6++) {
      _ref6[_key6] = arguments[_key6];
    }
    let [network, address, storage, options] = _ref6;
    const [, provider] = getSignerAndProvider(network, options);
    const [abi, contract, _network] = await Promise.all([NFTDropInitializer.getAbi(address, provider), import("./nft-drop-cbb0ae6c.esm-VOSAY2KN.js"), provider.getNetwork()]);
    return new contract.NFTDrop(network, address, storage, options, abi, _network.chainId);
  },
  getAbi: async (address, provider) => {
    const contractInfo = await getContractInfo(address, provider);
    return !contractInfo || contractInfo.version > 3 ? (await import("./DropERC721-CHRCJK6P.js")).default : (await import("./DropERC721_V3-26RH4QAI.js")).default;
  }
};
var PackInitializer = {
  name: "Pack",
  contractType: "pack",
  schema: PackContractSchema,
  roles: ["admin", "minter", "asset", "transfer"],
  initialize: async function() {
    for (var _len7 = arguments.length, _ref7 = new Array(_len7), _key7 = 0; _key7 < _len7; _key7++) {
      _ref7[_key7] = arguments[_key7];
    }
    let [network, address, storage, options] = _ref7;
    const [, provider] = getSignerAndProvider(network, options);
    const [abi, contract, _network] = await Promise.all([PackInitializer.getAbi(address, provider), import("./pack-2f8c55e9.esm-YRYLRL65.js"), provider.getNetwork()]);
    return new contract.Pack(network, address, storage, options, abi, _network.chainId);
  },
  getAbi: async (address, provider) => {
    return (await import("./Pack-KFWI6MHK.js")).default;
  }
};
var SignatureDropInitializer = {
  name: "SignatureDrop",
  contractType: "signature-drop",
  schema: DropErc721ContractSchema,
  roles: ["admin", "minter", "transfer"],
  initialize: async function() {
    for (var _len8 = arguments.length, _ref8 = new Array(_len8), _key8 = 0; _key8 < _len8; _key8++) {
      _ref8[_key8] = arguments[_key8];
    }
    let [network, address, storage, options] = _ref8;
    const [, provider] = getSignerAndProvider(network, options);
    const [abi, contract, _network] = await Promise.all([SignatureDropInitializer.getAbi(address, provider), import("./signature-drop-add9266e.esm-GA5HHXZX.js"), provider.getNetwork()]);
    return new contract.SignatureDrop(network, address, storage, options, abi, _network.chainId);
  },
  getAbi: async (address, provider) => {
    const contractInfo = await getContractInfo(address, provider);
    return !contractInfo || contractInfo.version > 4 ? (await import("./SignatureDrop-HIKEJHW6.js")).default : (await import("./SignatureDrop_V4-7CZJGTKC.js")).default;
  }
};
var SplitInitializer = {
  name: "Split",
  contractType: "split",
  schema: SplitsContractSchema,
  roles: ["admin"],
  initialize: async function() {
    for (var _len9 = arguments.length, _ref9 = new Array(_len9), _key9 = 0; _key9 < _len9; _key9++) {
      _ref9[_key9] = arguments[_key9];
    }
    let [network, address, storage, options] = _ref9;
    const [, provider] = getSignerAndProvider(network, options);
    const [abi, contract, _network] = await Promise.all([SplitInitializer.getAbi(address, provider), import("./split-19d2d8dc.esm-E334TTWS.js"), provider.getNetwork()]);
    return new contract.Split(network, address, storage, options, abi, _network.chainId);
  },
  getAbi: async (address, provider) => {
    return (await import("./Split-RVOEAUGQ.js")).default;
  }
};
var TokenDropInitializer = {
  name: "DropERC20",
  contractType: "token-drop",
  schema: DropErc20ContractSchema,
  roles: ["admin", "transfer"],
  initialize: async function() {
    for (var _len10 = arguments.length, _ref10 = new Array(_len10), _key10 = 0; _key10 < _len10; _key10++) {
      _ref10[_key10] = arguments[_key10];
    }
    let [network, address, storage, options] = _ref10;
    const [, provider] = getSignerAndProvider(network, options);
    const [abi, contract, _network] = await Promise.all([TokenDropInitializer.getAbi(address, provider), import("./token-drop-06cca1c8.esm-QXMB76LA.js"), provider.getNetwork()]);
    return new contract.TokenDrop(network, address, storage, options, abi, _network.chainId);
  },
  getAbi: async (address, provider) => {
    const contractInfo = await getContractInfo(address, provider);
    return !contractInfo || contractInfo.version > 2 ? (await import("./DropERC20-7OYEMI3M.js")).default : (await import("./DropERC20_V2-DFOKWB54.js")).default;
  }
};
var TokenInitializer = {
  name: "TokenERC20",
  contractType: "token",
  schema: TokenErc20ContractSchema,
  roles: ["admin", "minter", "transfer"],
  initialize: async function() {
    for (var _len11 = arguments.length, _ref11 = new Array(_len11), _key11 = 0; _key11 < _len11; _key11++) {
      _ref11[_key11] = arguments[_key11];
    }
    let [network, address, storage, options] = _ref11;
    const [, provider] = getSignerAndProvider(network, options);
    const [abi, contract, _network] = await Promise.all([TokenInitializer.getAbi(address, provider), import("./token-76d06ae4.esm-DBCHT2ON.js"), provider.getNetwork()]);
    return new contract.Token(network, address, storage, options, abi, _network.chainId);
  },
  getAbi: async (address, provider) => {
    return (await import("./TokenERC20-TLS3RO67.js")).default;
  }
};
var VoteInitializer = {
  name: "VoteERC20",
  contractType: "vote",
  schema: VoteContractSchema,
  roles: [],
  initialize: async function() {
    for (var _len12 = arguments.length, _ref12 = new Array(_len12), _key12 = 0; _key12 < _len12; _key12++) {
      _ref12[_key12] = arguments[_key12];
    }
    let [network, address, storage, options] = _ref12;
    const [, provider] = getSignerAndProvider(network, options);
    const [abi, contract, _network] = await Promise.all([VoteInitializer.getAbi(address, provider), import("./vote-f85a81aa.esm-WFUCQGBU.js"), provider.getNetwork()]);
    return new contract.Vote(network, address, storage, options, abi, _network.chainId);
  },
  getAbi: async (address, provider) => {
    return (await import("./VoteERC20-7BOJLXD7.js")).default;
  }
};
async function getContractInfo(address, provider) {
  try {
    return await getPrebuiltInfo(address, provider);
  } catch (e) {
    return void 0;
  }
}
var PREBUILT_CONTRACTS_MAP = {
  [EditionDropInitializer.contractType]: EditionDropInitializer,
  [EditionInitializer.contractType]: EditionInitializer,
  [MarketplaceInitializer.contractType]: MarketplaceInitializer,
  [MultiwrapInitializer.contractType]: MultiwrapInitializer,
  [NFTCollectionInitializer.contractType]: NFTCollectionInitializer,
  [NFTDropInitializer.contractType]: NFTDropInitializer,
  [PackInitializer.contractType]: PackInitializer,
  [SignatureDropInitializer.contractType]: SignatureDropInitializer,
  [SplitInitializer.contractType]: SplitInitializer,
  [TokenDropInitializer.contractType]: TokenDropInitializer,
  [TokenInitializer.contractType]: TokenInitializer,
  [VoteInitializer.contractType]: VoteInitializer
};
var SmartContract$1 = {
  name: "SmartContract",
  contractType: "custom",
  schema: CustomContractSchema,
  roles: ALL_ROLES
};
var CONTRACTS_MAP = {
  ...PREBUILT_CONTRACTS_MAP,
  [SmartContract$1.contractType]: SmartContract$1
};
function getContractTypeForRemoteName(name) {
  var _a;
  return ((_a = Object.values(CONTRACTS_MAP).find((contract) => contract.name === name)) == null ? void 0 : _a.contractType) || "custom";
}
function getContractName(type) {
  var _a;
  return (_a = Object.values(CONTRACTS_MAP).find((contract) => contract.contractType === type)) == null ? void 0 : _a.name;
}
var ContractAppURI = class {
  constructor(contractWrapper, metadata) {
    _defineProperty(this, "featureName", FEATURE_APPURI.name);
    _defineProperty(this, "contractWrapper", void 0);
    _defineProperty(this, "metadata", void 0);
    this.contractWrapper = contractWrapper;
    this.metadata = metadata;
  }
  async get() {
    if (detectContractFeature(this.contractWrapper, "AppURI")) {
      return await this.contractWrapper.readContract.appURI();
    }
    return (await this.metadata.get()).appURI || "";
  }
  async set(appURI) {
    if (detectContractFeature(this.contractWrapper, "AppURI")) {
      return {
        receipt: await this.contractWrapper.sendTransaction("setAppURI", [appURI])
      };
    }
    return await this.metadata.update({
      appURI
    });
  }
};
var ContractEvents = class {
  constructor(contractWrapper) {
    _defineProperty(this, "contractWrapper", void 0);
    this.contractWrapper = contractWrapper;
  }
  addTransactionListener(listener) {
    this.contractWrapper.addListener(EventType.Transaction, listener);
  }
  removeTransactionListener(listener) {
    this.contractWrapper.off(EventType.Transaction, listener);
  }
  addEventListener(eventName, listener) {
    const event = this.contractWrapper.readContract.interface.getEvent(eventName);
    const address = this.contractWrapper.readContract.address;
    const filter = {
      address,
      topics: [this.contractWrapper.readContract.interface.getEventTopic(event)]
    };
    const wrappedListener = (log) => {
      const parsedLog = this.contractWrapper.readContract.interface.parseLog(log);
      listener(this.toContractEvent(parsedLog.eventFragment, parsedLog.args, log));
    };
    this.contractWrapper.getProvider().on(filter, wrappedListener);
    return () => {
      this.contractWrapper.getProvider().off(filter, wrappedListener);
    };
  }
  listenToAllEvents(listener) {
    const address = this.contractWrapper.readContract.address;
    const filter = {
      address
    };
    const wrappedListener = (log) => {
      try {
        const parsedLog = this.contractWrapper.readContract.interface.parseLog(log);
        listener(this.toContractEvent(parsedLog.eventFragment, parsedLog.args, log));
      } catch (e) {
        console.error("Could not parse event:", log, e);
      }
    };
    this.contractWrapper.getProvider().on(filter, wrappedListener);
    return () => {
      this.contractWrapper.getProvider().off(filter, wrappedListener);
    };
  }
  removeEventListener(eventName, listener) {
    const event = this.contractWrapper.readContract.interface.getEvent(eventName);
    this.contractWrapper.readContract.off(event.name, listener);
  }
  removeAllListeners() {
    this.contractWrapper.readContract.removeAllListeners();
    const address = this.contractWrapper.readContract.address;
    const filter = {
      address
    };
    this.contractWrapper.getProvider().removeAllListeners(filter);
  }
  async getAllEvents() {
    let filters = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {
      fromBlock: 0,
      toBlock: "latest",
      order: "desc"
    };
    const events = await this.contractWrapper.readContract.queryFilter({}, filters.fromBlock, filters.toBlock);
    const orderedEvents = events.sort((a, b) => {
      return filters.order === "desc" ? b.blockNumber - a.blockNumber : a.blockNumber - b.blockNumber;
    });
    return this.parseEvents(orderedEvents);
  }
  async getEvents(eventName) {
    let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {
      fromBlock: 0,
      toBlock: "latest",
      order: "desc"
    };
    const event = this.contractWrapper.readContract.interface.getEvent(eventName);
    const eventInterface = this.contractWrapper.readContract.interface.getEvent(eventName);
    const args = options.filters ? eventInterface.inputs.map((e) => options.filters[e.name]) : [];
    const filter = this.contractWrapper.readContract.filters[event.name](...args);
    const events = await this.contractWrapper.readContract.queryFilter(filter, options.fromBlock, options.toBlock);
    const orderedEvents = events.sort((a, b) => {
      return options.order === "desc" ? b.blockNumber - a.blockNumber : a.blockNumber - b.blockNumber;
    });
    return this.parseEvents(orderedEvents);
  }
  parseEvents(events) {
    return events.map((e) => {
      const transaction = Object.fromEntries(Object.entries(e).filter((a) => typeof a[1] !== "function" && a[0] !== "args"));
      if (e.args) {
        const entries = Object.entries(e.args);
        const args = entries.slice(entries.length / 2, entries.length);
        const data = {};
        for (const [key, value] of args) {
          data[key] = value;
        }
        return {
          eventName: e.event || "",
          data,
          transaction
        };
      }
      return {
        eventName: e.event || "",
        data: {},
        transaction
      };
    });
  }
  toContractEvent(event, args, rawLog) {
    const transaction = Object.fromEntries(Object.entries(rawLog).filter((a) => typeof a[1] !== "function" && a[0] !== "args"));
    const results = {};
    event.inputs.forEach((param, index) => {
      if (Array.isArray(args[index])) {
        const obj = {};
        const components = param.components;
        if (components) {
          const arr = args[index];
          for (let i = 0; i < components.length; i++) {
            const name = components[i].name;
            obj[name] = arr[i];
          }
          results[param.name] = obj;
        }
      } else {
        results[param.name] = args[index];
      }
    });
    return {
      eventName: event.name,
      data: results,
      transaction
    };
  }
};
var ContractInterceptor = class {
  constructor(contractWrapper) {
    _defineProperty(this, "contractWrapper", void 0);
    this.contractWrapper = contractWrapper;
  }
  overrideNextTransaction(hook) {
    this.contractWrapper.withTransactionOverride(hook);
  }
};
var ContractPlatformFee = class {
  constructor(contractWrapper) {
    _defineProperty(this, "featureName", FEATURE_PLATFORM_FEE.name);
    _defineProperty(this, "contractWrapper", void 0);
    this.contractWrapper = contractWrapper;
  }
  async get() {
    const [platformFeeRecipient, platformFeeBps] = await this.contractWrapper.readContract.getPlatformFeeInfo();
    return CommonPlatformFeeSchema.parse({
      platform_fee_recipient: platformFeeRecipient,
      platform_fee_basis_points: platformFeeBps
    });
  }
  async set(platformFeeInfo) {
    const parsed = CommonPlatformFeeSchema.parse(platformFeeInfo);
    return {
      receipt: await this.contractWrapper.sendTransaction("setPlatformFeeInfo", [parsed.platform_fee_recipient, parsed.platform_fee_basis_points])
    };
  }
};
var ContractPublishedMetadata = class {
  constructor(contractWrapper, storage) {
    _defineProperty(this, "contractWrapper", void 0);
    _defineProperty(this, "storage", void 0);
    _defineProperty(this, "_cachedMetadata", void 0);
    this.contractWrapper = contractWrapper;
    this.storage = storage;
  }
  async get() {
    if (this._cachedMetadata) {
      return this._cachedMetadata;
    }
    this._cachedMetadata = await fetchContractMetadataFromAddress(this.contractWrapper.readContract.address, this.contractWrapper.getProvider(), this.storage);
    return this._cachedMetadata;
  }
  async extractFunctions() {
    let publishedMetadata;
    try {
      publishedMetadata = await this.get();
    } catch (e) {
    }
    return extractFunctionsFromAbi(AbiSchema.parse(this.contractWrapper.abi), publishedMetadata == null ? void 0 : publishedMetadata.metadata);
  }
  async extractEvents() {
    let publishedMetadata;
    try {
      publishedMetadata = await this.get();
    } catch (e) {
    }
    return extractEventsFromAbi(AbiSchema.parse(this.contractWrapper.abi), publishedMetadata == null ? void 0 : publishedMetadata.metadata);
  }
};
var SmartContract = class {
  get royalties() {
    return assertEnabled(this.detectRoyalties(), FEATURE_ROYALTY);
  }
  get roles() {
    return assertEnabled(this.detectRoles(), FEATURE_PERMISSIONS);
  }
  get sales() {
    return assertEnabled(this.detectPrimarySales(), FEATURE_PRIMARY_SALE);
  }
  get platformFees() {
    return assertEnabled(this.detectPlatformFees(), FEATURE_PLATFORM_FEE);
  }
  get owner() {
    return assertEnabled(this.detectOwnable(), FEATURE_OWNER);
  }
  get erc20() {
    return assertEnabled(this.detectErc20(), FEATURE_TOKEN);
  }
  get erc721() {
    return assertEnabled(this.detectErc721(), FEATURE_NFT);
  }
  get erc1155() {
    return assertEnabled(this.detectErc1155(), FEATURE_EDITION);
  }
  get chainId() {
    return this._chainId;
  }
  constructor(network, address, abi, storage) {
    let options = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : {};
    let chainId = arguments.length > 5 ? arguments[5] : void 0;
    let contractWrapper = arguments.length > 6 && arguments[6] !== void 0 ? arguments[6] : new ContractWrapper(network, address, abi, options);
    _defineProperty(this, "contractWrapper", void 0);
    _defineProperty(this, "storage", void 0);
    _defineProperty(this, "events", void 0);
    _defineProperty(this, "interceptor", void 0);
    _defineProperty(this, "encoder", void 0);
    _defineProperty(this, "estimator", void 0);
    _defineProperty(this, "publishedMetadata", void 0);
    _defineProperty(this, "abi", void 0);
    _defineProperty(this, "metadata", void 0);
    _defineProperty(this, "appURI", void 0);
    _defineProperty(this, "_chainId", void 0);
    this._chainId = chainId;
    this.storage = storage;
    this.contractWrapper = contractWrapper;
    this.abi = abi;
    this.events = new ContractEvents(this.contractWrapper);
    this.encoder = new ContractEncoder(this.contractWrapper);
    this.interceptor = new ContractInterceptor(this.contractWrapper);
    this.estimator = new GasCostEstimator(this.contractWrapper);
    this.publishedMetadata = new ContractPublishedMetadata(this.contractWrapper, this.storage);
    this.metadata = new ContractMetadata(this.contractWrapper, CustomContractSchema, this.storage);
    this.appURI = new ContractAppURI(this.contractWrapper, this.metadata);
  }
  onNetworkUpdated(network) {
    this.contractWrapper.updateSignerOrProvider(network);
  }
  getAddress() {
    return this.contractWrapper.readContract.address;
  }
  async call(functionName) {
    for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      args[_key - 1] = arguments[_key];
    }
    return this.contractWrapper.call(functionName, ...args);
  }
  detectRoyalties() {
    if (detectContractFeature(this.contractWrapper, "Royalty")) {
      const metadata = new ContractMetadata(this.contractWrapper, CustomContractSchema, this.storage);
      return new ContractRoyalty(this.contractWrapper, metadata);
    }
    return void 0;
  }
  detectRoles() {
    if (detectContractFeature(this.contractWrapper, "Permissions")) {
      return new ContractRoles(this.contractWrapper, ALL_ROLES);
    }
    return void 0;
  }
  detectPrimarySales() {
    if (detectContractFeature(this.contractWrapper, "PrimarySale")) {
      return new ContractPrimarySale(this.contractWrapper);
    }
    return void 0;
  }
  detectPlatformFees() {
    if (detectContractFeature(this.contractWrapper, "PlatformFee")) {
      return new ContractPlatformFee(this.contractWrapper);
    }
    return void 0;
  }
  detectErc20() {
    if (detectContractFeature(this.contractWrapper, "ERC20")) {
      return new Erc20(this.contractWrapper, this.storage, this.chainId);
    }
    return void 0;
  }
  detectErc721() {
    if (detectContractFeature(this.contractWrapper, "ERC721")) {
      return new Erc721(this.contractWrapper, this.storage, this.chainId);
    }
    return void 0;
  }
  detectErc1155() {
    if (detectContractFeature(this.contractWrapper, "ERC1155")) {
      return new Erc1155(this.contractWrapper, this.storage, this.chainId);
    }
    return void 0;
  }
  detectOwnable() {
    if (detectContractFeature(this.contractWrapper, "Ownable")) {
      return new ContractOwner(this.contractWrapper);
    }
    return void 0;
  }
};
var ContractPublisher = class extends RPCConnectionHandler {
  constructor(network, options, storage) {
    super(network, options);
    _defineProperty(this, "storage", void 0);
    _defineProperty(this, "publisher", void 0);
    this.storage = storage;
    this.publisher = new ContractWrapper(network, getContractPublisherAddress(), ContractPublisher_default, options);
  }
  updateSignerOrProvider(network) {
    super.updateSignerOrProvider(network);
    this.publisher.updateSignerOrProvider(network);
  }
  async extractConstructorParams(metadataUri) {
    return extractConstructorParams(metadataUri, this.storage);
  }
  async extractFunctions(predeployMetadataUri) {
    return extractFunctions(predeployMetadataUri, this.storage);
  }
  async fetchCompilerMetadataFromPredeployURI(predeployUri) {
    return fetchPreDeployMetadata(predeployUri, this.storage);
  }
  async fetchPrePublishMetadata(prepublishUri, publisherAddress) {
    const preDeployMetadataFetched = await fetchPreDeployMetadata(prepublishUri, this.storage);
    const latestPublishedContract = publisherAddress ? await this.getLatest(publisherAddress, preDeployMetadataFetched.name) : void 0;
    const latestPublishedContractMetadata = latestPublishedContract ? await this.fetchPublishedContractInfo(latestPublishedContract) : void 0;
    return {
      preDeployMetadata: preDeployMetadataFetched,
      latestPublishedContractMetadata
    };
  }
  async fetchCompilerMetadataFromAddress(address) {
    return fetchContractMetadataFromAddress(address, this.getProvider(), this.storage);
  }
  async fetchPublishedContractInfo(contract) {
    return {
      name: contract.id,
      publishedTimestamp: contract.timestamp,
      publishedMetadata: await this.fetchFullPublishMetadata(contract.metadataUri)
    };
  }
  async fetchFullPublishMetadata(publishedMetadataUri) {
    return fetchExtendedReleaseMetadata(publishedMetadataUri, this.storage);
  }
  async resolvePublishMetadataFromCompilerMetadata(compilerMetadataUri) {
    const publishedMetadataUri = await this.publisher.readContract.getPublishedUriFromCompilerUri(compilerMetadataUri);
    if (publishedMetadataUri.length === 0) {
      throw Error(`Could not resolve published metadata URI from ${compilerMetadataUri}`);
    }
    return await Promise.all(publishedMetadataUri.filter((uri) => uri.length > 0).map((uri) => this.fetchFullPublishMetadata(uri)));
  }
  async resolveContractUriFromAddress(address) {
    const contractUri = await resolveContractUriFromAddress(address, this.getProvider());
    invariant(contractUri, "Could not resolve contract URI from address");
    return contractUri;
  }
  async fetchContractSourcesFromAddress(address) {
    const metadata = await this.fetchCompilerMetadataFromAddress(address);
    return await fetchSourceFilesFromMetadata(metadata, this.storage);
  }
  async updatePublisherProfile(profileMetadata) {
    const signer = this.getSigner();
    invariant(signer, "A signer is required");
    const publisher = await signer.getAddress();
    const profileUri = await this.storage.upload(profileMetadata);
    return {
      receipt: await this.publisher.sendTransaction("setPublisherProfileUri", [publisher, profileUri])
    };
  }
  async getPublisherProfile(publisherAddress) {
    const profileUri = await this.publisher.readContract.getPublisherProfileUri(publisherAddress);
    if (!profileUri || profileUri.length === 0) {
      return {};
    }
    return ProfileSchemaOutput.parse(await this.storage.downloadJSON(profileUri));
  }
  async getAll(publisherAddress) {
    const data = await this.publisher.readContract.getAllPublishedContracts(publisherAddress);
    const map = data.reduce((acc, curr) => {
      acc[curr.contractId] = curr;
      return acc;
    }, {});
    return Object.entries(map).map((_ref) => {
      let [, struct] = _ref;
      return this.toPublishedContract(struct);
    });
  }
  async getAllVersions(publisherAddress, contractId) {
    const contractStructs = await this.publisher.readContract.getPublishedContractVersions(publisherAddress, contractId);
    if (contractStructs.length === 0) {
      throw Error("Not found");
    }
    return contractStructs.map((d) => this.toPublishedContract(d));
  }
  async getVersion(publisherAddress, contractId) {
    let version = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : "latest";
    if (version === "latest") {
      return this.getLatest(publisherAddress, contractId);
    }
    const allVersions = await this.getAllVersions(publisherAddress, contractId);
    const versionMetadata = await Promise.all(allVersions.map((contract) => this.fetchPublishedContractInfo(contract)));
    const versionMatch = versionMetadata.find((metadata) => metadata.publishedMetadata.version === version);
    invariant(versionMatch, "Contract version not found");
    return allVersions.find((contract) => contract.timestamp === versionMatch.publishedTimestamp);
  }
  async getLatest(publisherAddress, contractId) {
    const model = await this.publisher.readContract.getPublishedContract(publisherAddress, contractId);
    if (model && model.publishMetadataUri) {
      return this.toPublishedContract(model);
    }
    return void 0;
  }
  async publish(predeployUri, extraMetadata) {
    const signer = this.getSigner();
    invariant(signer, "A signer is required");
    const publisher = await signer.getAddress();
    const predeployMetadata = await fetchRawPredeployMetadata(predeployUri, this.storage);
    const latestContract = await this.getLatest(publisher, predeployMetadata.name);
    if (latestContract && latestContract.metadataUri) {
      const latestMetadata = await this.fetchPublishedContractInfo(latestContract);
      const latestVersion = latestMetadata.publishedMetadata.version;
      if (!isIncrementalVersion(latestVersion, extraMetadata.version)) {
        throw Error(`Version ${extraMetadata.version} is not greater than ${latestVersion}`);
      }
    }
    const fetchedBytecode = await (await this.storage.download(predeployMetadata.bytecodeUri)).text();
    const bytecode = fetchedBytecode.startsWith("0x") ? fetchedBytecode : `0x${fetchedBytecode}`;
    const bytecodeHash = utils_exports.solidityKeccak256(["bytes"], [bytecode]);
    const contractId = predeployMetadata.name;
    const fullMetadata = FullPublishMetadataSchemaInput.parse({
      ...extraMetadata,
      metadataUri: predeployMetadata.metadataUri,
      bytecodeUri: predeployMetadata.bytecodeUri,
      name: predeployMetadata.name,
      analytics: predeployMetadata.analytics,
      publisher
    });
    const fullMetadataUri = await this.storage.upload(fullMetadata);
    const receipt = await this.publisher.sendTransaction("publishContract", [publisher, contractId, fullMetadataUri, predeployMetadata.metadataUri, bytecodeHash, lib_exports.AddressZero]);
    const events = this.publisher.parseLogs("ContractPublished", receipt.logs);
    if (events.length < 1) {
      throw new Error("No ContractPublished event found");
    }
    const contract = events[0].args.publishedContract;
    return {
      receipt,
      data: async () => this.toPublishedContract(contract)
    };
  }
  async unpublish(publisher, contractId) {
    return {
      receipt: await this.publisher.sendTransaction("unpublishContract", [publisher, contractId])
    };
  }
  toPublishedContract(contractModel) {
    return PublishedContractSchema.parse({
      id: contractModel.contractId,
      timestamp: contractModel.publishTimestamp,
      metadataUri: contractModel.publishMetadataUri
    });
  }
};
var UserWallet = class {
  constructor(network, options) {
    _defineProperty(this, "connection", void 0);
    _defineProperty(this, "options", void 0);
    _defineProperty(this, "events", new eventemitter3_default());
    this.connection = new RPCConnectionHandler(network, options);
    this.options = options;
    this.events = new eventemitter3_default();
  }
  connect(network) {
    this.connection.updateSignerOrProvider(network);
    this.events.emit("signerChanged", this.connection.getSigner());
  }
  async transfer(to, amount) {
    let currencyAddress = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : NATIVE_TOKEN_ADDRESS;
    const signer = this.requireWallet();
    const amountInWei = await normalizePriceValue(this.connection.getProvider(), amount, currencyAddress);
    if (isNativeToken(currencyAddress)) {
      const from = await signer.getAddress();
      const tx = await signer.sendTransaction({
        from,
        to,
        value: amountInWei
      });
      return {
        receipt: await tx.wait()
      };
    } else {
      return {
        receipt: await this.createErc20(currencyAddress).sendTransaction("transfer", [to, amountInWei])
      };
    }
  }
  async balance() {
    let currencyAddress = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : NATIVE_TOKEN_ADDRESS;
    this.requireWallet();
    const provider = this.connection.getProvider();
    let balance;
    if (isNativeToken(currencyAddress)) {
      balance = await provider.getBalance(await this.getAddress());
    } else {
      balance = await this.createErc20(currencyAddress).readContract.balanceOf(await this.getAddress());
    }
    return await fetchCurrencyValue(provider, currencyAddress, balance);
  }
  async getAddress() {
    return await this.requireWallet().getAddress();
  }
  async getChainId() {
    return await this.requireWallet().getChainId();
  }
  isConnected() {
    try {
      this.requireWallet();
      return true;
    } catch (e) {
      return false;
    }
  }
  async sign(message) {
    const signer = this.requireWallet();
    return await signer.signMessage(message);
  }
  recoverAddress(message, signature) {
    const messageHash = ethers_exports.utils.hashMessage(message);
    const messageHashBytes = ethers_exports.utils.arrayify(messageHash);
    return ethers_exports.utils.recoverAddress(messageHashBytes, signature);
  }
  async sendRawTransaction(transactionRequest) {
    const signer = this.requireWallet();
    const tx = await signer.sendTransaction(transactionRequest);
    return {
      receipt: await tx.wait()
    };
  }
  requireWallet() {
    const signer = this.connection.getSigner();
    invariant(signer, "This action requires a connected wallet. Please pass a valid signer to the SDK.");
    return signer;
  }
  createErc20(currencyAddress) {
    return new ContractWrapper(this.connection.getSignerOrProvider(), currencyAddress, IERC20_default, this.options);
  }
};
var ThirdwebSDK = class extends RPCConnectionHandler {
  static async fromWallet(wallet, network) {
    let options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    let storage = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : new ThirdwebStorage();
    const signerOrProvider = getProviderForNetwork(network);
    const provider = Signer.isSigner(signerOrProvider) ? signerOrProvider.provider : typeof signerOrProvider === "string" ? getReadOnlyProvider(signerOrProvider) : signerOrProvider;
    const signer = await wallet.getSigner(provider);
    return ThirdwebSDK.fromSigner(signer, network, options, storage);
  }
  static fromSigner(signer, network) {
    let options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    let storage = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : new ThirdwebStorage();
    const sdk = new ThirdwebSDK(network || signer, options, storage);
    sdk.updateSignerOrProvider(signer);
    return sdk;
  }
  static fromPrivateKey(privateKey, network) {
    let options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    let storage = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : new ThirdwebStorage();
    const signerOrProvider = getProviderForNetwork(network);
    const provider = Signer.isSigner(signerOrProvider) ? signerOrProvider.provider : typeof signerOrProvider === "string" ? getReadOnlyProvider(signerOrProvider) : signerOrProvider;
    const signer = new ethers_exports.Wallet(privateKey, provider);
    return ThirdwebSDK.fromSigner(signer, network, options, storage);
  }
  constructor(network) {
    let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    let storage = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : new ThirdwebStorage();
    const signerOrProvider = getProviderForNetwork(network);
    super(signerOrProvider, options);
    _defineProperty(this, "contractCache", /* @__PURE__ */ new Map());
    _defineProperty(this, "_publisher", void 0);
    _defineProperty(this, "storageHandler", void 0);
    _defineProperty(this, "deployer", void 0);
    _defineProperty(this, "wallet", void 0);
    _defineProperty(this, "storage", void 0);
    _defineProperty(this, "auth", void 0);
    this.storageHandler = storage;
    this.storage = storage;
    this.wallet = new UserWallet(signerOrProvider, options);
    this.deployer = new ContractDeployer(signerOrProvider, options, storage);
    this.auth = new WalletAuthenticator(signerOrProvider, this.wallet, options);
    this._publisher = new ContractPublisher(signerOrProvider, this.options, this.storageHandler);
  }
  async getNFTDrop(contractAddress) {
    return await this.getContract(contractAddress, "nft-drop");
  }
  async getSignatureDrop(contractAddress) {
    return await this.getContract(contractAddress, "signature-drop");
  }
  async getNFTCollection(contractAddress) {
    return await this.getContract(contractAddress, "nft-collection");
  }
  async getEditionDrop(contractAddress) {
    return await this.getContract(contractAddress, "edition-drop");
  }
  async getEdition(contractAddress) {
    return await this.getContract(contractAddress, "edition");
  }
  async getTokenDrop(contractAddress) {
    return await this.getContract(contractAddress, "token-drop");
  }
  async getToken(contractAddress) {
    return await this.getContract(contractAddress, "token");
  }
  async getVote(contractAddress) {
    return await this.getContract(contractAddress, "vote");
  }
  async getSplit(contractAddress) {
    return await this.getContract(contractAddress, "split");
  }
  async getMarketplace(contractAddress) {
    return await this.getContract(contractAddress, "marketplace");
  }
  async getPack(contractAddress) {
    return await this.getContract(contractAddress, "pack");
  }
  async getMultiwrap(contractAddress) {
    return await this.getContract(contractAddress, "multiwrap");
  }
  async getContract(address, contractTypeOrABI) {
    if (this.contractCache.has(address)) {
      return this.contractCache.get(address);
    }
    let newContract;
    if (!contractTypeOrABI || contractTypeOrABI === "custom") {
      const resolvedContractType = await this.resolveContractType(address);
      if (resolvedContractType === "custom") {
        try {
          const publisher = this.getPublisher();
          const metadata = await publisher.fetchCompilerMetadataFromAddress(address);
          newContract = await this.getContractFromAbi(address, metadata.abi);
        } catch (e) {
          throw new Error(`Error fetching ABI for this contract

${e}`);
        }
      } else {
        const contractAbi = await PREBUILT_CONTRACTS_MAP[resolvedContractType].getAbi(address, this.getProvider());
        newContract = await this.getContractFromAbi(address, contractAbi);
      }
    } else if (typeof contractTypeOrABI === "string" && contractTypeOrABI in PREBUILT_CONTRACTS_MAP) {
      newContract = await PREBUILT_CONTRACTS_MAP[contractTypeOrABI].initialize(this.getSignerOrProvider(), address, this.storage, this.options);
    } else {
      newContract = await this.getContractFromAbi(address, contractTypeOrABI);
    }
    this.contractCache.set(address, newContract);
    return newContract;
  }
  async getBuiltInContract(address, contractType) {
    return await this.getContract(address, contractType);
  }
  async resolveContractType(contractAddress) {
    try {
      const contract = new Contract(
        contractAddress,
        IThirdwebContract_default,
        this.getProvider()
      );
      const remoteContractType = ethers_exports.utils.toUtf8String(await contract.contractType()).replace(/\x00/g, "");
      return getContractTypeForRemoteName(remoteContractType);
    } catch (err) {
      return "custom";
    }
  }
  async getContractList(walletAddress) {
    var _a;
    const addresses = await ((_a = await this.deployer.getRegistry()) == null ? void 0 : _a.getContractAddresses(walletAddress)) || [];
    const addressesWithContractTypes = await Promise.all(addresses.map(async (address) => {
      let contractType = "custom";
      try {
        contractType = await this.resolveContractType(address);
      } catch (e) {
      }
      let metadata;
      if (contractType === "custom") {
        try {
          metadata = (await this.getContract(address)).metadata;
        } catch (e) {
          console.warn(`Couldn't get contract metadata for custom contract: ${address} - ${e}`);
        }
      } else {
        metadata = (await this.getContract(address, contractType)).metadata;
      }
      return {
        address,
        contractType,
        metadata
      };
    }));
    return addressesWithContractTypes.filter((e) => e.metadata).map((_ref) => {
      let {
        address,
        contractType,
        metadata
      } = _ref;
      invariant(metadata, "All ThirdwebContracts require metadata");
      return {
        address,
        contractType,
        metadata: () => metadata.get()
      };
    });
  }
  updateSignerOrProvider(network) {
    super.updateSignerOrProvider(network);
    this.updateContractSignerOrProvider();
  }
  updateContractSignerOrProvider() {
    this.wallet.connect(this.getSignerOrProvider());
    this.auth.updateSignerOrProvider(this.getSignerOrProvider());
    this.deployer.updateSignerOrProvider(this.getSignerOrProvider());
    this._publisher.updateSignerOrProvider(this.getSignerOrProvider());
    for (const [, contract] of this.contractCache) {
      contract.onNetworkUpdated(this.getSignerOrProvider());
    }
  }
  async getContractFromAbi(address, abi) {
    if (this.contractCache.has(address)) {
      return this.contractCache.get(address);
    }
    const [, provider] = getSignerAndProvider(this.getSignerOrProvider(), this.options);
    const contract = new SmartContract(this.getSignerOrProvider(), address, abi, this.storageHandler, this.options, (await provider.getNetwork()).chainId);
    this.contractCache.set(address, contract);
    return contract;
  }
  async getBalance(address) {
    return fetchCurrencyValue(this.getProvider(), NATIVE_TOKEN_ADDRESS, await this.getProvider().getBalance(address));
  }
  getPublisher() {
    return this._publisher;
  }
};
var ContractFactory = class extends ContractWrapper {
  constructor(factoryAddr, network, storage, options) {
    super(network, factoryAddr, TWFactory_default, options);
    _defineProperty(this, "storage", void 0);
    _defineProperty(this, "DEFAULT_VERSION_MAP", {
      [NFTDropInitializer.contractType]: 3,
      [NFTCollectionInitializer.contractType]: 1,
      [SignatureDropInitializer.contractType]: 4,
      [MultiwrapInitializer.contractType]: 1,
      [EditionDropInitializer.contractType]: 2,
      [EditionInitializer.contractType]: 1,
      [TokenDropInitializer.contractType]: 2,
      [TokenInitializer.contractType]: 1,
      [VoteInitializer.contractType]: 1,
      [SplitInitializer.contractType]: 1,
      [MarketplaceInitializer.contractType]: 2,
      [PackInitializer.contractType]: 2
    });
    this.storage = storage;
  }
  async deploy(contractType, contractMetadata, version) {
    const contract = PREBUILT_CONTRACTS_MAP[contractType];
    const metadata = contract.schema.deploy.parse(contractMetadata);
    const contractURI = await this.storage.upload(metadata);
    const implementationAddress = await this.getImplementation(contract, version);
    if (!implementationAddress || implementationAddress === lib_exports.AddressZero) {
      throw new Error(`No implementation found for ${contractType}`);
    }
    const ABI = await contract.getAbi(implementationAddress, this.getProvider());
    const encodedFunc = Contract.getInterface(ABI).encodeFunctionData("initialize", await this.getDeployArguments(contractType, metadata, contractURI));
    const blockNumber = await this.getProvider().getBlockNumber();
    const salt = ethers_exports.utils.formatBytes32String(blockNumber.toString());
    const receipt = await this.sendTransaction("deployProxyByImplementation", [implementationAddress, encodedFunc, salt]);
    const events = this.parseLogs("ProxyDeployed", receipt.logs);
    if (events.length < 1) {
      throw new Error("No ProxyDeployed event found");
    }
    return events[0].args.proxy;
  }
  async deployProxyByImplementation(implementationAddress, implementationAbi, initializerFunction, initializerArgs) {
    const encodedFunc = Contract.getInterface(implementationAbi).encodeFunctionData(initializerFunction, initializerArgs);
    const blockNumber = await this.getProvider().getBlockNumber();
    const receipt = await this.sendTransaction("deployProxyByImplementation", [implementationAddress, encodedFunc, ethers_exports.utils.formatBytes32String(blockNumber.toString())]);
    const events = this.parseLogs("ProxyDeployed", receipt.logs);
    if (events.length < 1) {
      throw new Error("No ProxyDeployed event found");
    }
    return events[0].args.proxy;
  }
  async getDeployArguments(contractType, metadata, contractURI) {
    let trustedForwarders = contractType === PackInitializer.contractType ? [] : await this.getDefaultTrustedForwarders();
    if (metadata.trusted_forwarders && metadata.trusted_forwarders.length > 0) {
      trustedForwarders = metadata.trusted_forwarders;
    }
    switch (contractType) {
      case NFTDropInitializer.contractType:
      case NFTCollectionInitializer.contractType:
        const erc721metadata = NFTDropInitializer.schema.deploy.parse(metadata);
        return [await this.getSignerAddress(), erc721metadata.name, erc721metadata.symbol, contractURI, trustedForwarders, erc721metadata.primary_sale_recipient, erc721metadata.fee_recipient, erc721metadata.seller_fee_basis_points, erc721metadata.platform_fee_basis_points, erc721metadata.platform_fee_recipient];
      case SignatureDropInitializer.contractType:
        const signatureDropmetadata = SignatureDropInitializer.schema.deploy.parse(metadata);
        return [await this.getSignerAddress(), signatureDropmetadata.name, signatureDropmetadata.symbol, contractURI, trustedForwarders, signatureDropmetadata.primary_sale_recipient, signatureDropmetadata.fee_recipient, signatureDropmetadata.seller_fee_basis_points, signatureDropmetadata.platform_fee_basis_points, signatureDropmetadata.platform_fee_recipient];
      case MultiwrapInitializer.contractType:
        const multiwrapMetadata = MultiwrapInitializer.schema.deploy.parse(metadata);
        return [await this.getSignerAddress(), multiwrapMetadata.name, multiwrapMetadata.symbol, contractURI, trustedForwarders, multiwrapMetadata.fee_recipient, multiwrapMetadata.seller_fee_basis_points];
      case EditionDropInitializer.contractType:
      case EditionInitializer.contractType:
        const erc1155metadata = EditionDropInitializer.schema.deploy.parse(metadata);
        return [await this.getSignerAddress(), erc1155metadata.name, erc1155metadata.symbol, contractURI, trustedForwarders, erc1155metadata.primary_sale_recipient, erc1155metadata.fee_recipient, erc1155metadata.seller_fee_basis_points, erc1155metadata.platform_fee_basis_points, erc1155metadata.platform_fee_recipient];
      case TokenDropInitializer.contractType:
      case TokenInitializer.contractType:
        const erc20metadata = TokenInitializer.schema.deploy.parse(metadata);
        return [await this.getSignerAddress(), erc20metadata.name, erc20metadata.symbol, contractURI, trustedForwarders, erc20metadata.primary_sale_recipient, erc20metadata.platform_fee_recipient, erc20metadata.platform_fee_basis_points];
      case VoteInitializer.contractType:
        const voteMetadata = VoteInitializer.schema.deploy.parse(metadata);
        return [voteMetadata.name, contractURI, trustedForwarders, voteMetadata.voting_token_address, voteMetadata.voting_delay_in_blocks, voteMetadata.voting_period_in_blocks, BigNumber.from(voteMetadata.proposal_token_threshold), voteMetadata.voting_quorum_fraction];
      case SplitInitializer.contractType:
        const splitsMetadata = SplitInitializer.schema.deploy.parse(metadata);
        return [await this.getSignerAddress(), contractURI, trustedForwarders, splitsMetadata.recipients.map((s) => s.address), splitsMetadata.recipients.map((s) => BigNumber.from(s.sharesBps))];
      case MarketplaceInitializer.contractType:
        const marketplaceMetadata = MarketplaceInitializer.schema.deploy.parse(metadata);
        return [await this.getSignerAddress(), contractURI, trustedForwarders, marketplaceMetadata.platform_fee_recipient, marketplaceMetadata.platform_fee_basis_points];
      case PackInitializer.contractType:
        const packsMetadata = PackInitializer.schema.deploy.parse(metadata);
        return [await this.getSignerAddress(), packsMetadata.name, packsMetadata.symbol, contractURI, trustedForwarders, packsMetadata.fee_recipient, packsMetadata.seller_fee_basis_points];
      default:
        return [];
    }
  }
  async getDefaultTrustedForwarders() {
    const chainId = await this.getChainID();
    return getDefaultTrustedForwarders(chainId);
  }
  async getImplementation(contract, version) {
    const encodedType = ethers_exports.utils.formatBytes32String(contract.name);
    const chainId = await this.getChainID();
    const approvedImplementation = getApprovedImplementation(chainId, contract.contractType);
    if (approvedImplementation && approvedImplementation.length > 0 && version === void 0) {
      return approvedImplementation;
    }
    return this.readContract.getImplementation(encodedType, version !== void 0 ? version : this.DEFAULT_VERSION_MAP[contract.contractType]);
  }
  async getLatestVersion(contractType) {
    const name = getContractName(contractType);
    if (!name) {
      throw new Error(`Invalid contract type ${contractType}`);
    }
    const encodedType = ethers_exports.utils.formatBytes32String(name);
    return this.readContract.currentVersion(encodedType);
  }
};
var FactoryEvents = class extends ContractEvents {
  constructor(contractWrapper) {
    super(contractWrapper);
  }
  addDeployListener(listener) {
    this.addTransactionListener(async (event) => {
      if (!event.transactionHash) {
        return;
      }
      const receipt = await this.contractWrapper.getProvider().getTransactionReceipt(event.transactionHash);
      const events = this.contractWrapper.parseLogs("ProxyDeployed", receipt.logs);
      if (events.length > 0) {
        listener({
          ...event,
          contractAddress: events[0].args.proxy
        });
      }
    });
  }
};
var ContractRegistry = class extends ContractWrapper {
  constructor(registryAddress, network, options) {
    super(network, registryAddress, TWRegistry_default, options);
  }
  async getContractAddresses(walletAddress) {
    return (await this.readContract.getAll(walletAddress)).filter((adr) => utils_exports.isAddress(adr) && adr.toLowerCase() !== lib_exports.AddressZero);
  }
  async addContract(contractAddress) {
    return await this.addContracts([contractAddress]);
  }
  async addContracts(contractAddresses) {
    const deployerAddress = await this.getSignerAddress();
    const encoded = [];
    contractAddresses.forEach((address) => {
      encoded.push(this.readContract.interface.encodeFunctionData("add", [deployerAddress, address]));
    });
    return {
      receipt: await this.multiCall(encoded)
    };
  }
  async removeContract(contractAddress) {
    return await this.removeContracts([contractAddress]);
  }
  async removeContracts(contractAddresses) {
    const deployerAddress = await this.getSignerAddress();
    const encoded = [];
    contractAddresses.forEach((address) => {
      encoded.push(this.readContract.interface.encodeFunctionData("remove", [deployerAddress, address]));
    });
    return {
      receipt: await this.multiCall(encoded)
    };
  }
};
var ContractDeployer = class extends RPCConnectionHandler {
  constructor(network, options, storage) {
    super(network, options);
    _defineProperty(this, "_factory", void 0);
    _defineProperty(this, "_registry", void 0);
    _defineProperty(this, "events", void 0);
    _defineProperty(this, "storage", void 0);
    this.storage = storage;
    this.getFactory();
    this.getRegistry();
  }
  async deployNFTCollection(metadata) {
    return await this.deployBuiltInContract(NFTCollectionInitializer.contractType, metadata);
  }
  async deployNFTDrop(metadata) {
    return await this.deployBuiltInContract(NFTDropInitializer.contractType, metadata);
  }
  async deploySignatureDrop(metadata) {
    return await this.deployBuiltInContract(SignatureDropInitializer.contractType, metadata);
  }
  async deployMultiwrap(metadata) {
    return await this.deployBuiltInContract(MultiwrapInitializer.contractType, metadata);
  }
  async deployEdition(metadata) {
    return await this.deployBuiltInContract(EditionInitializer.contractType, metadata);
  }
  async deployEditionDrop(metadata) {
    return await this.deployBuiltInContract(EditionDropInitializer.contractType, metadata);
  }
  async deployToken(metadata) {
    return await this.deployBuiltInContract(TokenInitializer.contractType, metadata);
  }
  async deployTokenDrop(metadata) {
    return await this.deployBuiltInContract(TokenDropInitializer.contractType, metadata);
  }
  async deployMarketplace(metadata) {
    return await this.deployBuiltInContract(MarketplaceInitializer.contractType, metadata);
  }
  async deployPack(metadata) {
    return await this.deployBuiltInContract(PackInitializer.contractType, metadata);
  }
  async deploySplit(metadata) {
    return await this.deployBuiltInContract(SplitInitializer.contractType, metadata);
  }
  async deployVote(metadata) {
    return await this.deployBuiltInContract(VoteInitializer.contractType, metadata);
  }
  async deployBuiltInContract(contractType, contractMetadata) {
    let version = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : "latest";
    const activeChainId = (await this.getProvider().getNetwork()).chainId;
    const parsedMetadata = PREBUILT_CONTRACTS_MAP[contractType].schema.deploy.parse(contractMetadata);
    const factory = await this.getFactory();
    if (activeChainId === ChainId.Hardhat || activeChainId === ChainId.Localhost) {
      let parsedVersion = void 0;
      try {
        parsedVersion = parseInt(version);
        if (isNaN(parsedVersion)) {
          parsedVersion = void 0;
        }
      } catch (e) {
        parsedVersion = void 0;
      }
      return await factory.deploy(contractType, parsedMetadata, parsedVersion);
    }
    const contractName = getContractName(contractType);
    invariant(contractName, "contract name not found");
    const contractURI = await this.storage.upload(parsedMetadata);
    const constructorParams = await factory.getDeployArguments(contractType, parsedMetadata, contractURI);
    return this.deployReleasedContract(
      "0xdd99b75f095d0c4d5112aCe938e4e6ed962fb024",
      contractName,
      constructorParams,
      version
    );
  }
  async getLatestBuiltInContractVersion(contractType) {
    const factory = await this.getFactory();
    return await factory.getLatestVersion(contractType);
  }
  async deployReleasedContract(releaserAddress, contractName, constructorParams) {
    let version = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : "latest";
    const release = await new ThirdwebSDK("polygon").getPublisher().getVersion(releaserAddress, contractName, version);
    if (!release) {
      throw new Error(`No release found for '${contractName}' at version '${version}' by '${releaserAddress}'`);
    }
    return await this.deployContractFromUri(release.metadataUri, constructorParams);
  }
  async deployViaFactory(factoryAddress, implementationAddress, implementationAbi, initializerFunction, initializerArgs) {
    const signer = this.getSigner();
    invariant(signer, "signer is required");
    const proxyFactory = new ContractFactory(factoryAddress, this.getSignerOrProvider(), this.storage, {});
    return await proxyFactory.deployProxyByImplementation(implementationAddress, implementationAbi, initializerFunction, initializerArgs);
  }
  async deployProxy(implementationAddress, implementationAbi, initializerFunction, initializerArgs) {
    const encodedInitializer = Contract.getInterface(implementationAbi).encodeFunctionData(initializerFunction, initializerArgs);
    const {
      TWProxy__factory
    } = await import("./thirdweb-dev-contracts-js-factories-TWProxy__factory.esm-4DJFQMDY.js");
    return this.deployContractWithAbi(TWProxy__factory.abi, TWProxy__factory.bytecode, [implementationAddress, encodedInitializer]);
  }
  async getRegistry() {
    if (this._registry) {
      return this._registry;
    }
    return this._registry = this.getProvider().getNetwork().then(async (_ref) => {
      let {
        chainId
      } = _ref;
      const registryAddress = getContractAddressByChainId(chainId, "twRegistry");
      return new ContractRegistry(registryAddress, this.getSignerOrProvider(), this.options);
    });
  }
  async getFactory() {
    if (this._factory) {
      return this._factory;
    }
    return this._factory = this.getProvider().getNetwork().then(async (_ref2) => {
      let {
        chainId
      } = _ref2;
      const factoryAddress = getContractAddressByChainId(chainId, "twFactory");
      const factory = new ContractFactory(factoryAddress, this.getSignerOrProvider(), this.storage, this.options);
      this.events = new FactoryEvents(factory);
      return factory;
    });
  }
  updateSignerOrProvider(network) {
    super.updateSignerOrProvider(network);
    this.updateContractSignerOrProvider();
  }
  updateContractSignerOrProvider() {
    var _a, _b;
    (_a = this._factory) == null ? void 0 : _a.then((factory) => {
      factory.updateSignerOrProvider(this.getSignerOrProvider());
    }).catch(() => {
    });
    (_b = this._registry) == null ? void 0 : _b.then((registry) => {
      registry.updateSignerOrProvider(this.getSignerOrProvider());
    }).catch(() => {
    });
  }
  async deployContractFromUri(publishMetadataUri, constructorParamValues, options) {
    const signer = this.getSigner();
    invariant(signer, "A signer is required");
    const compilerMetadata = await fetchPreDeployMetadata(publishMetadataUri, this.storage);
    let isDeployableViaFactory;
    let isDeployableViaProxy;
    let factoryDeploymentData;
    try {
      const extendedMetadata = await fetchExtendedReleaseMetadata(publishMetadataUri, this.storage);
      isDeployableViaFactory = extendedMetadata.isDeployableViaFactory;
      isDeployableViaProxy = extendedMetadata.isDeployableViaProxy;
      factoryDeploymentData = FactoryDeploymentSchema.parse(extendedMetadata.factoryDeploymentData);
    } catch (e) {
    }
    const forceDirectDeploy = (options == null ? void 0 : options.forceDirectDeploy) || false;
    if (factoryDeploymentData && (isDeployableViaProxy || isDeployableViaFactory) && !forceDirectDeploy) {
      const chainId = (await this.getProvider().getNetwork()).chainId;
      invariant(factoryDeploymentData.implementationAddresses, "implementationAddresses is required");
      const implementationAddress = factoryDeploymentData.implementationAddresses[chainId];
      invariant(implementationAddress, `implementationAddress not found for chainId '${chainId}'`);
      invariant(factoryDeploymentData.implementationInitializerFunction, `implementationInitializerFunction not set'`);
      const initializerParamTypes = extractFunctionParamsFromAbi(compilerMetadata.abi, factoryDeploymentData.implementationInitializerFunction).map((p) => p.type);
      const paramValues2 = this.convertParamValues(initializerParamTypes, constructorParamValues);
      if (isDeployableViaFactory) {
        invariant(factoryDeploymentData.factoryAddresses, "isDeployableViaFactory is true so factoryAddresses is required");
        const factoryAddress = factoryDeploymentData.factoryAddresses[chainId];
        invariant(factoryAddress, `isDeployableViaFactory is true and factoryAddress not found for chainId '${chainId}'`);
        return await this.deployViaFactory(factoryAddress, implementationAddress, compilerMetadata.abi, factoryDeploymentData.implementationInitializerFunction, paramValues2);
      } else if (isDeployableViaProxy) {
        return await this.deployProxy(implementationAddress, compilerMetadata.abi, factoryDeploymentData.implementationInitializerFunction, paramValues2);
      }
    }
    const bytecode = compilerMetadata.bytecode.startsWith("0x") ? compilerMetadata.bytecode : `0x${compilerMetadata.bytecode}`;
    if (!ethers_exports.utils.isHexString(bytecode)) {
      throw new Error(`Contract bytecode is invalid.

${bytecode}`);
    }
    const constructorParamTypes = extractConstructorParamsFromAbi(compilerMetadata.abi).map((p) => p.type);
    const paramValues = this.convertParamValues(constructorParamTypes, constructorParamValues);
    return this.deployContractWithAbi(compilerMetadata.abi, bytecode, paramValues);
  }
  convertParamValues(constructorParamTypes, constructorParamValues) {
    if (constructorParamTypes.length !== constructorParamValues.length) {
      throw Error("Passed the wrong number of constructor arguments");
    }
    return constructorParamTypes.map((p, index) => {
      if (p === "tuple" || p.endsWith("[]")) {
        if (typeof constructorParamValues[index] === "string") {
          return JSON.parse(constructorParamValues[index]);
        } else {
          return constructorParamValues[index];
        }
      }
      if (p === "bytes32") {
        invariant(ethers_exports.utils.isHexString(constructorParamValues[index]), `Could not parse bytes32 value. Expected valid hex string but got "${constructorParamValues[index]}".`);
        return ethers_exports.utils.hexZeroPad(constructorParamValues[index], 32);
      }
      if (p.startsWith("bytes")) {
        invariant(ethers_exports.utils.isHexString(constructorParamValues[index]), `Could not parse bytes value. Expected valid hex string but got "${constructorParamValues[index]}".`);
        return constructorParamValues[index];
      }
      if (p.startsWith("uint") || p.startsWith("int")) {
        return BigNumber.from(constructorParamValues[index].toString());
      }
      return constructorParamValues[index];
    });
  }
  async deployContractWithAbi(abi, bytecode, constructorParams) {
    const signer = this.getSigner();
    invariant(signer, "Signer is required to deploy contracts");
    const deployer = await new ethers_exports.ContractFactory(abi, bytecode).connect(signer).deploy(...constructorParams);
    const deployedContract = await deployer.deployed();
    return deployedContract.address;
  }
};
var ContractOwner = class {
  constructor(contractWrapper) {
    _defineProperty(this, "featureName", FEATURE_OWNER.name);
    _defineProperty(this, "contractWrapper", void 0);
    this.contractWrapper = contractWrapper;
  }
  async get() {
    return this.contractWrapper.readContract.owner();
  }
  async set(address) {
    return {
      receipt: await this.contractWrapper.sendTransaction("setOwner", [address])
    };
  }
};
var PAPER_API_BASE = `https://paper.xyz/api`;
var PAPER_API_VERSION = `2022-08-12`;
var PAPER_API_URL = `${PAPER_API_BASE}/${PAPER_API_VERSION}/platform/thirdweb`;
var PAPER_CHAIN_ID_MAP = {
  [ChainId.Mainnet]: "Ethereum",
  [ChainId.Goerli]: "Goerli",
  [ChainId.Polygon]: "Polygon",
  [ChainId.Mumbai]: "Mumbai",
  [ChainId.Avalanche]: "Avalanche"
};
function parseChainIdToPaperChain(chainId) {
  invariant(chainId in PAPER_CHAIN_ID_MAP, `chainId not supported by paper: ${chainId}`);
  return PAPER_CHAIN_ID_MAP[chainId];
}
async function fetchRegisteredCheckoutId(contractAddress, chainId) {
  const paperChain = parseChainIdToPaperChain(chainId);
  const res = await fetch(`${PAPER_API_URL}/register-contract?contractAddress=${contractAddress}&chain=${paperChain}`);
  const json = await res.json();
  invariant(json.result.id, "Contract is not registered with paper");
  return json.result.id;
}
var DEFAULT_PARAMS = {
  expiresInMinutes: 15,
  feeBearer: "BUYER",
  sendEmailOnSuccess: true,
  redirectAfterPayment: false
};
async function createCheckoutLinkIntent(contractId, params) {
  const res = await fetch(`${PAPER_API_URL}/checkout-link-intent`, {
    method: "POST",
    headers: {
      "Content-Type": "application/json"
    },
    body: JSON.stringify({
      contractId,
      ...DEFAULT_PARAMS,
      ...params,
      metadata: {
        ...params.metadata,
        via_platform: "thirdweb"
      },
      hideNativeMint: true,
      hidePaperWallet: !!params.walletAddress,
      hideExternalWallet: true,
      hidePayWithCrypto: true,
      usePaperKey: false
    })
  });
  const json = await res.json();
  invariant(json.checkoutLinkIntentUrl, "Failed to create checkout link intent");
  return json.checkoutLinkIntentUrl;
}
var PaperCheckout = class {
  constructor(contractWrapper) {
    _defineProperty(this, "contractWrapper", void 0);
    this.contractWrapper = contractWrapper;
  }
  async getCheckoutId() {
    return fetchRegisteredCheckoutId(this.contractWrapper.readContract.address, await this.contractWrapper.getChainID());
  }
  async isEnabled() {
    try {
      return !!await this.getCheckoutId();
    } catch (err) {
      return false;
    }
  }
  async createLinkIntent(params) {
    return await createCheckoutLinkIntent(await this.getCheckoutId(), params);
  }
};

export {
  mod,
  AmountSchema,
  NFTInputOrUriSchema,
  DEFAULT_QUERY_ALL_COUNT,
  _defineProperty,
  invariant,
  require_browser_ponyfill,
  IERC20_default,
  require_bs58,
  require_base64_js,
  require_ieee754,
  require_buffer,
  require_dist,
  require_fast_deep_equal,
  BigNumberishSchema,
  AddressSchema,
  RawDateSchema2 as RawDateSchema,
  ChainId,
  SUPPORTED_CHAIN_IDS,
  NATIVE_TOKENS,
  DEFAULT_RPC_URLS,
  getProviderForNetwork,
  ListingNotFoundError,
  DropErc721ContractSchema,
  DropErc1155ContractSchema,
  MarketplaceContractSchema,
  PackContractSchema,
  SplitsContractSchema,
  TokenErc20ContractSchema,
  TokenErc721ContractSchema,
  TokenErc1155ContractSchema,
  VoteContractSchema,
  ContractWrapper,
  isNativeToken,
  normalizePriceValue,
  fetchCurrencyMetadata,
  fetchCurrencyValue,
  hasERC20Allowance,
  convertToReadableQuantity,
  getRoleHash,
  FEATURE_NFT_REVEALABLE,
  ContractEncoder,
  ContractMetadata,
  ContractRoles,
  ContractRoyalty,
  ContractPrimarySale,
  uploadOrExtractURI,
  DelayedReveal,
  ListingType,
  VoteType,
  GasCostEstimator,
  DropClaimConditions,
  DropErc1155ClaimConditions,
  DropErc1155History,
  Erc20SignatureMintable,
  TokenERC20History,
  StandardErc20,
  Erc721WithQuantitySignatureMintable,
  Erc721,
  StandardErc721,
  Erc1155SignatureMintable,
  Erc1155,
  StandardErc1155,
  isTokenApprovedForTransfer,
  mapOffer,
  MarketplaceDirect,
  MarketplaceAuction,
  DropErc20ContractSchema,
  MultiwrapContractSchema,
  ContractEvents,
  ContractInterceptor,
  ContractPlatformFee,
  UserWallet,
  ThirdwebSDK,
  ContractOwner,
  PaperCheckout
};
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */
/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */
/** @preserve
	(c) 2012 by Cdric Mesnil. All rights reserved.

	Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:

	    - Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
	    - Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.

	THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*/
/** @preserve
 * Counter block mode compatible with  Dr Brian Gladman fileenc.c
 * derived from CryptoJS.mode.CTR
 * Jan Hruby jhruby.web@gmail.com
 */
//# sourceMappingURL=chunk-HDJNXEED.js.map
